---PAGE 1---












Aragon Developer Documentation - Aragon Developer Documentation




















Links
Aragon Developer Documentation
Welcome to the Aragon Developer Documentation. What you need to get started building with Aragon.
Get started 
here
.
Take the tutorial 
here
.
General tools:
​
 
aragonPM
: Decentralized package manager based on aragonOS that handles upgreadability of smart contracts and arbitrary data blobs, such as webapps.
​
 
aragonOS
 
Framework: that enables flexible and upgradeable governance mechanisms by creating and assigning permissions to multiple entities.
​
 
aragonAPI
 Standard: set of APIs and specifications used to interact with aragonOS-powered contracts by handling transaction pathing, upgradeability, and contract state.
​
 
aragonUI
: Aragon-native toolkit of React UI components for decentralized apps that implement aragonDS. Slick, fast and easily extendable.
​
 
aragonCLI
: Tool for creating, testing and publishing Aragon applications. Also allows for creating custom Aragon organizations.
​
 
aragonDS
: The Aragon Design System defines a set of user behaviours and guidelines to ensure consistency across all Aragon apps.
Products tools: 
For Aragon 
Govern
 documentation go 
here
.
For Aragon 
Vocdoni
 documentation go 
here
.
​
Next
 - Developers
General Tools
Last modified 
4mo ago
Copy link









---PAGE 2---












General Tools - Aragon Developer Documentation




















Links
General Tools
Here are the articles in this section:
The Basics
Guides
aragonOS
aragonCLI
aragonPM
aragonAPI
aragonUI
aragonDS
Aragon Connect
App Center
Previous
Aragon Developer Documentation
Next
The Basics
Last modified 
7mo ago
Copy link









---PAGE 3---












Product Tools - Aragon Developer Documentation




















Links
Product Tools
Here are the articles in this section:
Aragon Govern
Aragon Vocdoni
Previous
Submitting Your App to the App Center
Next
Aragon Govern
Last modified 
7mo ago
Copy link









---PAGE 4---












Aragon Client - Aragon Developer Documentation




















Links
Aragon Client
Find below a list of unique terms that you may encounter when using Aragon Client. You can learn more about these concepts and why they matter to you as an Aragon Client user by reading through the rest of the 
Aragon Client documentation
.
​
Access Control List
 (ACL)
 
The ACL is a mapping of who has permission to execute an action in an Aragon app and who can re-grant or revoke that permission.
Aragen
Tool that automatically generates everything that is needed to run Aragon on a local Ethereum chain.
aragonAPI
Standard set of APIs and specifications used to interact with aragonOS-powered contracts by handling transaction pathing, upgradeability, and contract state. Reference implementations in specific languages: 
JavaScript
​
​
aragonCLI
​
Tool for creating, testing and publishing Aragon applications.
aragonID
aragonID is a lightweight identity system using 
ENS
.
​
aragonOS
 
Framework that enables flexible and upgradeable governance mechanisms by creating and assigning permissions to multiple entities.
​
aragonPM
​
Decentralized package manager based on aragonOS that handles upgradability of smart contracts and arbitrary data blobs, such as web apps.
aragonPM Repository
Smart contract deployed inside aragonPM
 
that keeps track of the versions for a package.
​
aragonUI
​
Aragon-native toolkit of UI components for decentralized apps.
Aragon apps
Apps that use aragonOS, aragonAPI, and integrate inside the Aragon client.
​
Aragon client
​
Client to interact with aragonOS-powered decentralized organizations. It implements a signer with transaction pathing, notifications and a sandboxed environment for aragonOS-based apps using aragonAPI.
DAO
Stands for Decentralized Autonomous Organization. Here, a DAO means a set of aragonOS smart contracts.
​
DAO Template
​
Smart contracts that can be used as templates for creating pre-configured DAOs in just one transaction.
DAO Kit
 
Have been deprecated for DAO Templates.
Etherum Providers
Apps which provide your browser access to the Ethereum network and support signing Ethereum transactions. Mobile Web3 browsers generally have a built-in Ethereum provider and wallet functionality.
Hardware wallet
Keeps your private keys - the computer code that is used to sign transactions and authorize funds transfers - secured separately from your computer, protecting the private keys from malware that may be on your computer.
Previous
Aragon Vocdoni
Last modified 
5mo ago
Copy link
On this page
Access Control List (ACL) 
Aragen
aragonAPI
aragonCLI
aragonID
aragonOS 
aragonPM
aragonPM Repository
aragonUI
Aragon apps
Aragon client
DAO
DAO Template
DAO Kit 
Etherum Providers
Hardware wallet









---PAGE 5---












Quick start - Aragon Developer Documentation




















Links
Quick start
Up and running
Now that we've got you all excited, let's go through what you need to get started building with Aragon 😊
Note before starting: Windows is not officially supported by aragonCLI at the moment.
For more support about using Windows go 
here
.
Environment setup
Node.js
First off, we need to be sure we have the right version of Node.js installed to prevent errors.
Dependencies of aragonCLI are constantly 
updated
 which result in Node version errors. Use 
NVM
 
to install and select the right Node version. For compatibility across OS use 
Node v12.7 LTS
 version.
​
Also using 
yarn
 instead of 
npm
 as package manager is advised in some cases. Find how to install 
yarn
.
To see which version of Node you have installed, from the command line run:
node -v
​
Web3 provider
Next, we'll need what we call a 
web3 provider
 to actually sign and send transactions to the Ethereum (or another) blockchain.
In general, if you have a hardware wallet, we recommend you use 
Frame
 as your web3 provider -- we'll go over how to do this in the
 tutorial
 that follows. 
For now in this section, to interact with the 
Aragon app
 we'll be using Metamask. If you haven't please proceed with the installation of 
Metamask.
​
The aragonCLI
The 
aragonCLI
 (or Aragon Command Line Interface) is a tool used for complex interactions with DAOs, like installing a new app, granting permissions with specific parameters or executing transactions through the 
Agent app
.
Now install aragonCLI from the command line running:
npm i -g @aragon/cli
Again: It is recommended to have 
NVM
 installed so that you can switch to 
Node v12.7 LTS
 to install the cli. At the moment the product isn't compatible with the later versions of node anymore.
If the installation takes a long time don't worry. It can happen, wait until the process is completed (sometimes it takes 30 min!).
Check with 
aragon -v
 whether the package has indeed installed.
If you're having trouble with this step, you should take a look at the installing aragonCLI section of the 
troubleshooting guide
. If that doesn't fix things, please don't hesitate to reach out to us in the 
#dev-space channel
 off our Discord server.
The Aragon Builder plugin
The 
Aragon Builder plugin
 is a user-friendly tool for developing apps on top of Aragon. The plugin is automatically installed when using the boilerplate templates but we can suggest to install now with the following command:
npm i @aragon/buidler-aragon
Getting Started 
In order to get up and running quickly, 
we’ll build our first DAO
 using some basic scaffolding. Just like real scaffolding in a construction site, when we talk about scaffolding in this context, we mean a simple prebuilt structure for your project, on top of which you can build the real one.
To create your first (scaffolded) DAO, from the command line run:
npx create-aragon-app first-dao.aragonpm.eth
Don't worry about fully understanding this line right now. Really. We'll cover that in the 
tutorial 
coming up. Right now, you just need to know that the scaffolding relies on some generated code, magically created by the 
create-aragon-app
 command.
If you're unsure what the difference is between 
npx
 and 
npm
, we recommend you read through this 
medium post
 and this 
stackoverflow post.
​
Now if you look at your terminal, you should see a five step process:
​
✅
Preparing initialization
​
✅
Cloning app template
​
✅
Preparing template
​
✅
Installing package dependencies
​
✅
Created new application first-dao.aragonpm.eth in first-dao.
Once all 5 have ticks next to them, you should run the following:
cd first-dao
yarn start
where:
cd first-dao
, just moves us into the directory where the scaffolded app was created.
yarn start
, sets up everything for us in the background so we can quickly live test our DAO.
If you've made it this far congrats 🤗. You've just created your first DAO! It’s running on your local network and as soon as it's ready it will open in your browser at 
localhost:3000
!
Interacting with your first DAO
Once your browser is open at the right address, you should see a screen that looks like the one below.
DAO Home
As you can see on the left, this DAO is made up of two Aragon apps:
Home
first-dao (Counter)
Right now, we're in the Home app. This app just displays a welcome message with no possible user interactions.
Click on first-dao to open up the (slightly) more interesting Counter app.
Counter app
Right now the count is at 0. Let's increment it.
Note that incrementing the counter triggers a blockchain transaction that saves the new value to the chain. But before the transaction can be sent, we need to sign it (to prove it was us that really sent it).
Click on the + button, which opens a Metamask transaction and sign it. For help on how to sign a transaction on Metamask go through these steps:
First of all, you have to connect your 
first-dao
 app to Metamask. 
Here
 you can learn to setup a Metamask wallet. 
Here
 how to import your 
first-dao
 seed phrase. And 
here
 on how to sign a 
first-dao
 transaction using Metamask. 
After the transaction is completed, you should see Count: 1.
Done! We hope you enjoyed that 😊! 
Next steps
Now that you’ve built your first DAO, feel free to take a look at the docs. If you're interested in understanding things at a deeper level go ahead to this 
tutorial
! 
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Before starting
Next
Tech Stack
Last modified 
5mo ago
Copy link
On this page
Up and running
Environment setup
Node.js
Web3 provider
The aragonCLI
The Aragon Builder plugin
Getting Started 
Interacting with your first DAO
Next steps









---PAGE 6---












How to create your first custom DAO using Aragon CLI! - Aragon Developer Documentation




















Links
How to create your first custom DAO using Aragon CLI!
This guide will show you the process to deploy a 
blank DAO
 using Aragon CLI and configure it as a 
custom DAO
 for a cooperative organisation, let's say a cooperative of dairy farmers.
We assume you have a general understanding of Aragon stack.
Environment setup
Before starting you need to check if you have already installed all these prerequisites:
the right version of 
node.js
 (recommended 
v12.7 LTS
 version)
web3 provider: 
Frame
 or 
Metamask
 (Frame is necessary for this guide).
the 
aragonCLI
 (Aragon Command Line Interface) 
an 
IPFS server.
​
If installing IPFS on Linux, it can be easily done with: 
sudo snap install ipfs
If you haven't already installed them or if you need more info about this goes to the "
Enviroment Setup
" paragraph 
here
.
Creating a blank DAO
Warning
Installing Frame is necessary for this step. Read 
here
 how to setup a Frame wallet. Select 'RINKEBY' network and make sure you open your new account (unfold it) in Frame for the transaction to appear.
Let's create a blank DAO! Insert and run the following command in your terminal:
 dao new --use-frame --env aragon:rinkeby
In the Frame app now a 'permission request' from aragonCLI should show up. 'Sign' the request.
After this a transaction to create the DAO should show up in Frame, also 'sign' this transaction:
​
​
​
​
Hint
Make sure you have sufficient Rinkeby Ethereum (ETH) in your wallet for the transaction fees. If not you can request for Rinkeby ETH 
here
. The transaction could take long. Increase the 'gas fees' to speed up the transaction.
Well done you just created your first DAO! You should now be able to open the DAO on: 
https://client.aragon.org/#/<dao-address>
Find the DAO address in the terminal, and make sure you select the 'Rinkeby' network in Aragon Client for your DAO to load (since Ethereum mainnet is default). You can change to Rinkeby network from here in the top right hand corner: 
https://client.aragon.org/#/
​
The DAO was created with the default 
bare-template
. So it won’t have a token manager, vault, finance, or voting app installed yet.
Note

The 
bare-kit
 has been deprecated and 
bare-template
 should be used instead. To learn more about templates check the
 introduction about them
.
The above command used the 
--use-frame
 and 
--env
 flags. You can find other possible flags 
here
, or by adding the 
--help
 flag to the command. 
Adding a Token and Token Manager to your DAO
Next we will add a token and a token-manager to your DAO. The following types of tokens can be created:
Membership
: a non-transferrable token limited to 1 per account.
Reputation
: a non-transferrable token without balance restriction.
Equity
: a transferrable token without balance restriction.
For the dairy cooperative we want to start with a membership token: one farmer, one member.
First we need to deploy a MiniMe token. The 
dao new token
 command takes the following variables:
dao token new <token-name> <symbol> [decimal-units] [transfer-enabled]
Note
The 
MiniMeToken
 contract is a standard ERC20 token with extra functionality.
For our membership token we take 
"Member"
 as  
token-name
, with 
"MBR"
 as 
symbol
.
We want to set 
decimal-units
 to 
0
 (the default is 
18
).
The default of 
tranfer-enabled
 is 
true
. By leaving 
transfered-enabled
 out of the command it takes the default value automatically, which is good for now since we will restrict transferability using the token-manager in a later step.
Warning
For the next step it is necessary to start an instance of 
Aragon Devchain
. To do so open up an new tab or window in your terminal and run the following command:
aragon devchain --env aragon:rinkeby
So now run the following command in your terminal:
dao token new "Member" "MBR" 0 --use-frame --env aragon:rinkeby
Copy the 
token address
 from the terminal as we will need it later!
Next we need to deploy an instance of the 
token-manager
 app which will serve as the token-controller for the membership token we just created.
Note
The token-manager cannot be initialized unless it's already the controller of a MiniMe token. So in this case we want to use the 
dao install
 command with the 
--app-init none
 flag. In that way we can perform some actions before we initialize the token-manager. Read more about this 
flag
 here.
Insert the DAO address in the below command and run it in your terminal:
dao install <dao-address> token-manager --app-init none --use-frame --env aragon:rinkeby
In order to get the token-manager address we need to run the following command:
dao apps <dao-address> --all --use-frame --env aragon:rinkeby
You should see a list of apps, and a token-manager instance listed under permissionless apps. Copy this address as we will need it later.
Next are going to set the token-address as the token-controller on our token, by running the following command:
dao token change-controller <token-address> <token-manager-address> --use-frame --env aragon:rinkeby
Now we are creating a 
MINT_ROLE
 permission for the token-manager so more farmers can be added as members to the dairy-DAO at a later point in time. Run the following command:
dao acl create <dao-address> <token-manager-address> MINT_ROLE <your-address> <your-address> --use-frame --env aragon:rinkeby
Warning
Make sure you do not accidentally include multiple spaces instead of 1 space between each variable in the command. Since if you do, you will run into this error:
✖ Not enough non-option arguments: got 4, need at least 5
We can now initialize the token manager using the 
dao exec
 command. The token-manager’s initialise function takes 3 parameters:
1.
minime token
: token-address of a MiniMe token.
2.
transferrable
: a boolean indicating if the token should be transferrable or not.
3.
uint
: determining max number of tokens an address can control (use 
0
 if you do not want to restrict balances).
Note
You can find more info about 
dao exec
 commands 
here
.
We would not like dairy farmers to transfer their membership tokens, so we set the boolean to 
false
. Then we want one address to control a maximum of 1 membership token, so the 
unit
 will be set to 
1
. Insert the data of the variables in the below command, and run it in your terminal: 
dao exec <dao-address> <token-manager-address> initialize <token-address> false 1 --use-frame --env aragon:rinkeby
At this point if you open your DAO in a web browser you should be able to see the 
token manager app installed
, and should be able to mint tokens from 
your-address
. Open your DAO UI from here: 
https://client.aragon.org/#/<dao-address>
​
Warning
Even though we have initialized the token manager as 
transferrable = false
, and token transfers fail, there is what appears to be a UI bug where the token manager will list the token as transferrable even though it is not. 
GitHub issue
.
Adding a Voting App to your DAO
Adding a 
voting-app
 allows actions to be protected by a vote. This to ensure that the required support and quorum is reached in case of changes to your DAO. The dairy-DAO might want to transfer control to another member, such as change can then only be executed when the required majority of members is met.
Since we already have a token and token-manager deployed all we have to do is install the voting-app. This can be done in one step using the 
dao install
 command and passing arguments via 
--app-init-args
.
The voting-app requires the following initialization parameters:
minime token
: token-address of a MiniMe token.
support required percentage
: percentage of yeas in casted votes for a vote to succeed (expressed as a percentage of 
10^18
; eg. 
10^16 = 1%
, 
10^18 = 100%
).
min accept quorum
: percentage of yeas in total possible votes for a vote to succeed (expressed as a percentage of 
10^18
; eg. 
10^16 = 1%
, 
10^18 = 100%
).
vote time
: seconds that a vote will be open for token holders to vote (unless enough yeas or nays have been cast to make an early decision).
So if we want a voting-app instance with a support requirement of 60% and min accept quorum of 25% and a voting period of 7 days we would use the following command. Run the command in your terminal:
dao install <dao-address> voting --app-init-args <token-address> 600000000000000000 250000000000000000 604800 --use-frame --env aragon:rinkeby
Next you will need to assign the create votes permission. If you want all token holders to be able to create votes, we can assign the 
CREATE_VOTES_ROLE
 to the 
token-manager-address
.
The following command grants token holders (so all members of the dairy-DAO) the ability to create votes. Also from now a vote will be required to manage changes to the permissions. Run the command:
dao acl create <dao-address> <voting-app-address> CREATE_VOTES_ROLE <token-manager-address> <voting-app-address> --use-frame --env aragon:rinkeby
At this point you should be able to open your organization in the browser and be able to create votes! 
👏
​
Note
You can find more info about 
dao acl
 commands 
here
.
Adding a Vault and Finance App
Note
The 
vault-app
 is intended to securely store and manage funds but does not have its own user interface (UI). The 
finance-app
 provides an interface for the vault-app and provides some limited budgeting capabilities. In the future, it may make sense to install the vault app without the finance app, or the finance app with a different version of the vault app, but for now these two apps generally make sense to install as a pair.
The vault-app can be installed without passing any specific initialization parameters. Run the following command in the terminal:
dao install <dao-address> vault --use-frame --env aragon:rinkeby
Copy the provided 
vault-address
 from the terminal, which will be needed later.
​
The finance-app however requires two initialization parameters:
1.
vault-address.
2.
budgeting period
 (in seconds).
If you are familiar with the finance-app in the UI, you may have noticed that there is not way to configure or set a budget. However, the smart-contracts allow you to set a per-asset budget which is reset each time period.
Eventually the UI will be updated to support these functions. If you don’t intend to use any of the budgetting functionality the budget period parameter doesn't matter but it does need to be passed. If you do plan on using the budgeting functionality however here is how it works:
For a given budget period 
P
, a budget 
B
 can be set for asset 
A
. The total volume of transfers of 
A
 cannot exceed its budget within a period 
P
. So for example, if we initialize 
P
 as 1 Month, we could set a budget for DAI of 1000, and even if the vault contains more than 1000 DAI it will not be able to spend more than 1000 DAI per month. Keep in mind that the budget cannot be seen from the UI, so transactions which exceed the budget will just fail.
For demonstrations purposes, let's set install the finance-app with a budget period of 30 days (in seconds). Run the following command:
dao install <dao-address> finance --app-init-args <vault-address> 2592000 --use-frame --env aragon:rinkeby
Now we want to create a permission that grants the finance-app the 
TRANSFER_ROLE
 on the vault. For future possible changes we will also make voting required. Run the following command to do so:
dao acl create <dao-address> <vault-address> TRANSFER_ROLE <finance-address> <voting-address> --use-frame --env aragon:rinkeby
We also want to grant some permissions to the voting app on the finance-app. In that way voting will be required do the dairy-DAO members wish to make changes to the roles. Run the follwoing commands in the terminal:
dao acl create <dao-address> <finance-address> CREATE_PAYMENTS_ROLE <voting-address> <voting-address> --use-frame --env aragon:rinkeby
​
dao acl create <dao-address> <finance-address> EXECUTE_PAYMENTS_ROLE <voting-address> <voting-address> --use-frame --env aragon:rinkeby
​
dao acl create <dao-address> <finance-address> MANAGE_PAYMENTS_ROLE <voting-address> <voting-address> --use-frame --env aragon:rinkeby
For more information on what each of these roles do as well as additional roles made available by the finance-app, see the 
repository
.
At this point you should be able to open your custom DAO in the web browser and manage tokens, create votes, and manage funds using  the vault and finance apps! 
🎉
​
Review & Finalize Permissions
While we have a mostly functional dairy-DAO 
the permissions
 need to be cleaned up because we do not want our personal address to have root authority in the organization. These steps can be done from the permissions UI (see image below), or directly from Aragon CLI.
​
To see what permissions are currently assigned, run the following 
dao acl
 command:
dao acl <dao-address> --use-frame --env aragon:rinkeby
You will notice that some key permissions have been granted and are managed by the address you used to perform these commands. By following these steps you are transferring authority as creator of the organization to other applications and entities defined above, 
Warning
Transferring permissions is an irreversible process, so be careful not to revoke a permission before granting it to an appropriate entity!
You’ll want to grant permissions which are currently only assigned to your address to another entity (eg. 
voting-address
):
dao acl grant <dao-address> <app-address> <ROLE> <voting-address> --use-frame --env aragon:rinkeby
You’ll want to revoke permissions for yourself once they have been granted to another entity:
dao acl revoke <dao-address> <app-address> <ROLE> <your-address> --use-frame --env aragon:rinkeby
You’ll want change the permission manager for permissions from your address to another entity (eg. 
voting-address
):
dao acl set-manager <dao-address> <app-address> <ROLE> <voting-address> --use-frame --env aragon:rinkeby
At this point you should have changed permissions. Well done you successfully set up a custom DAO for the dairy-farmers cooperation. Let's toast to that! 
🐮
​
🥛
​
🥛
​
🐮
​
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Guides
Next
How to use the Agent App
Last modified 
6mo ago
Copy link
On this page
Environment setup
Creating a blank DAO
Adding a Token and Token Manager to your DAO
Adding a Voting App to your DAO
Adding a Vault and Finance App
Review & Finalize Permissions









---PAGE 7---












aragonPM - Aragon Developer Documentation




















Links
aragonPM
In this section, we will explore the 
aragonPM
. A 
Decentralised package manager
 based on aragonOS that handles 
upgradability of smart contracts
 and 
arbitrary data blobs 
such as web apps.
Previous
Global configuration
Next
Introduction
Last modified 
7mo ago
Copy link









---PAGE 8---












aragonOS - Aragon Developer Documentation




















Links
aragonOS
In this section, we will explore 
aragonOS
. A Framework that enables 
flexible and upgradeable governance
 mechanisms by 
creating and assigning permissions
 to multiple entities.
Previous
Troubleshooting
Next
Introduction
Last modified 
7mo ago
Copy link









---PAGE 9---












aragonAPI - Aragon Developer Documentation




















Links
aragonAPI
In this section, we will explore 
aragonAPI
. A standard 
set of APIs 
and specifications used 
to interact with aragonOS-powered contracts
 by handling transaction pathing, upgradeability, and contract state.
Previous
Reference documentation
Next
Introduction
Last modified 
7mo ago
Copy link









---PAGE 10---












aragonUI - Aragon Developer Documentation




















Links
aragonUI
In this section, we will explore 
aragonUI.
 An Aragon-native 
toolkit of React UI components
 for decentralized apps that implement aragonDS. Slick, fast and easily extendable.
Plug and play UI elements for Aragon apps:
​
Github
​
​
​
​
​
​
Previous
Background Scripts
Next
Getting started
Last modified 
7mo ago
Copy link









---PAGE 11---












aragonCLI - Aragon Developer Documentation




















Links
aragonCLI
In this section, we will explore the 
Aragon CLI
. A tool for 
creating, testing and publishing Aragon applications
. Also allows for creating 
custom Aragon organizations (DAOs)
.
Previous
KernelStorage
Next
Introduction
Last modified 
7mo ago
Copy link









---PAGE 12---












aragonDS - Aragon Developer Documentation




















Links
aragonDS
In this section, we will explore 
aragonDS
. The Aragon Design System defines a 
set of user behaviours
 and 
guidelines 
to ensure consistency across all Aragon apps.
Previous
Viewport
Next
Guidelines
Last modified 
7mo ago
Copy link









---PAGE 13---












Aragon Govern - Aragon Developer Documentation




















Links
Aragon Govern
In this section we are going to the Aragon Govern software for creating and governing organizations such as DeFi projects, open source projects, gaming guilds, cooperatives, nonprofits, clubs, companies, and any other type of organization you can imagine. 
Developers - 
Previous
Product Tools
Next
README
Last modified 
7mo ago
Copy link









---PAGE 14---












Aragon Vocdoni - Aragon Developer Documentation




















Links
Aragon Vocdoni
The Vocdoni Documents can be found here: 
https://docs.vocdoni.io/
​
The Vocdoni Documents are stored on Github and are the source of truth: 
https://github.com/vocdoni/docs
​
Previous
govern.js
Next
 - GLOSSARY
Aragon Client
Last modified 
6mo ago
Copy link









---PAGE 15---












The Basics - Aragon Developer Documentation




















Links
The Basics
In this section, you will find the basic information and settings necessary to deploy and run your first Aragon Client DAO using the command-line. 
We will walk through these main concepts for understanding the Aragon tools structure:
What is the Aragon Stack?
What are the App Permissions?
What is the Forwarding?
What is the Upgradeability?
What is the Package Manager?
What are the Templates?
What is the Aragon Client?
What are the Human readable transactions?
​
Developers - 
Previous
General Tools
Next
Before starting
Last modified 
7mo ago
Copy link









---PAGE 16---












Guides - Aragon Developer Documentation




















Links
Guides
In this section, we will walk you through several Guides:
how to create your first Aragon app?
how to migrate an Aragon app from the 
aragonCLI
 to the new 
Buidler plugin
?
how to publish the Aragon app to aragonPM?
how to deploy a blank Organization and configure it as a custom Organization using Aragon CLi?
We will show you how to use the Agent app.
​
Previous
Human readable transactions
Next
How to create your first custom DAO using Aragon CLI!
Last modified 
7mo ago
Copy link









---PAGE 17---












Aragon Connect - Aragon Developer Documentation




















Links
Aragon Connect
Welcome to the Aragon Connect documentation.
The 
Guides
 section contains guides that will help you build a dapp using Aragon Connect.
The 
Advanced
 section contains guides that are helpful if you want to write your own app connector or want to gain a deeper understanding of everything under the hood.
The 
Connectors
 section contains in-depth documentation of the Connectors available.
The 
API Reference
 section contains complete documentation of the functions and objects exposed by the library.
If you are not familiar with Aragon at all, we highly recommend starting with the 
Aragon Basics
 guide.
If you have never interacted with the library before, the 
Getting Started
 guide contains everything you need to start connecting 👷🔌.
Previous
Overview
Next
Guides
Last modified 
7mo ago
Copy link









---PAGE 18---












App Center - Aragon Developer Documentation




















Links
App Center
In this section, we will explore the 
App Center: 
what is it
how to prepare and send your App to the App Center.
Previous
Errors
Next
App Center
Last modified 
7mo ago
Copy link









---PAGE 19---












Submitting Your App to the App Center - Aragon Developer Documentation




















Links
Submitting Your App to the App Center
For the time being, we ask that you submit an 
issue to the 
aragon/aragon
 repo
 as a 
Feature request
 with the following:
Name of your application
Link to its development repo
Link to an organization with the application installed
Current development status
Short summary explaining what the application does
Please double check that your app includes the relevant assets and that they are in the correct formats (
see guide
).
We will update this page accordingly as we build more community-governed infrastructure for curating apps in the future.
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Preparing Assets
Next
 - Developers
Product Tools
Last modified 
7mo ago
Copy link









---PAGE 20---












APPS - Aragon Developer Documentation




















Links
APPS
Here are the articles in this section:
AppProxyBase
AppProxyPinned
AppProxyUpgradeable
AppStorage
AragonApp
UnsafeAragonApp
Previous
Repo
Next
AppProxyBase
Last modified 
7mo ago
Copy link









---PAGE 21---












Page not found - Aragon Developer Documentation




















Links
Page not found
Sorry, but the page you were looking for could not be found.
Back to front page









---PAGE 22---












Page not found - Aragon Developer Documentation




















Links
Page not found
Sorry, but the page you were looking for could not be found.
Back to front page









---PAGE 23---












Page not found - Aragon Developer Documentation




















Links
Page not found
Sorry, but the page you were looking for could not be found.
Back to front page









---PAGE 24---












Page not found - Aragon Developer Documentation




















Links
Page not found
Sorry, but the page you were looking for could not be found.
Back to front page









---PAGE 25---












Page not found - Aragon Developer Documentation




















Links
Page not found
Sorry, but the page you were looking for could not be found.
Back to front page









---PAGE 26---












Before starting - Aragon Developer Documentation




















Links
Before starting
Before starting to go into depth into the command-line-interface, creating Aragon apps, etc., first some important basics:
What is Web3?
Unless you've been living under a rock for the last few years, you've probably come across the term 
Web3
 😋. 
But what does it mean exactly? And why do we care about it in the context of Aragon?
Web3 is the vision of a fully 
decentralized web
. One of the craziest things to wrap your head around is that in web3, apps don't need a central server to fetch data from!
How is this possible? 
In a nutshell: thanks to something called 
peer-to-peer data architectures
. The key point is that in a P2P architecture, instead of requesting data from a central server, you request it from multiple computers (peers) around you.
While this is nothing new in itself -- P2P architectures have existed since the 1990’s (where they rose to fame with file sharing programs like BitTorrent and Napster) -- what's new is the addition of 
cryptography and economic incentives
 to these architectures.
The fusion of these seemingly disparate disciplines was the big innovation behind Bitcoin, and has since led to the emergence of a new field of research devoted to their intersection (what we now call cryptoeconomics).
While we won't get into the details here, the key takeaway:
Cryptoeconomics is the big unlock that has allowed us to start moving from centralized data structures (web2) to more decentralized or fully distributed data architectures (web3).
Centralized vs Decentralized
Note that there’s a spectrum from fully centralized (left) to fully decentralized (right).
IPFS (InternetPlanetary File System)
While blockchains -- like Bitcoin and Ethereum -- are key to this Web3 vision, it's important to note that there are 
other essential parts
 of the Web3 stack that are not covered by them.
For example, since blockchains are relatively expensive to 
store data
 on, it turns out that they don't make great file systems. That's why there's also a need for decentralized file systems like the
 
IPFS (InterPlanetary File System)
 which Aragon also makes use of.
IPFS is a distributed system for storing and accessing files, websites, applications, and data.
What is a Web3 provider?
Definition: a Web3 provider an abstraction of a connection to the Ethereum Network, providing a concise, consistent interface to standard Ethereum node functionality.
In poor words, a Web3 provider is "something" that can actually sign and send transactions to the Ethereum blockchain.
If you're new to the decentralized web you might be wondering why we have to use a separate provider to interact with the blockchain. 
Why don't decentralized apps (like Aragon's) just do it themselves?
In short, while it's possible for dapps (decentralized apps) to interact directly with the blockchain, using a Web3 provider allows users to interact with dapps without trusting every one of them with their private keys (the keys to their funds).
Without a Web3 provider, users have to have total trust in every dapp they use. With a Web3 provider, they just need to trust that provider.
Examples of web3 providers are 
Metamask
 and 
Frame
.
Metamask
Metamask is a browser plugin that allows users to make Ethereum transactions through regular websites. It does this by injecting a javascript library called Web3.js into the namespace of each page your browser loads.
Web3.js is written by the Ethereum core team and has functions that regular web pages can use to make read and write requests to the blockchain. Eventually, we'll have browsers with this sort of functionality built-in (Brave and Opera are working on this). But for now, we need plugins like Metamask to help us bridge the gap between Web2 and Web3.
For instructions on how to use Metamask as your Web3 provider, please follow our 
Metamask guide.
​
Further resources
​
DAOs and the Web3 vision
​
​
Why The Internet Needs IPFS Before It’s Too Late
​
​
A hands-on introduction to IPFS
​
​
Blockchain infrastructure landscape: a first principles framing
​
​
The case for decentralization
​
​
What comes after open source?
​
​
Fat protocols
​
Previous
The Basics
Next
Quick start
Last modified 
5mo ago
Copy link
On this page
What is Web3?
IPFS (InternetPlanetary File System)
What is a Web3 provider?
Metamask
Further resources









---PAGE 27---












Tech Stack - Aragon Developer Documentation




















Links
Tech Stack
For 
creating DAOs, dapps
 and 
protocols
.
From a technical perspective, Aragon can be seen as an 
operating system for human organizations
. Therefore, the 
Aragon stack
 can be thought of as an 
operating system
, just like macOS or Linux.
A computer operating system manages which processes have access to the computer's resources. They do that with the following components:
A Kernel, which has drivers that let the software control the hardware
A permission system, to manage which processes can access each resource
A self-upgrade system, for bugs and enhancements
You wouldn't want a Tetris app to own full control over your computer's RAM. That would enable tampering with other apps or stealing precious information. Similarly, you wouldn't want a CryptoKitties app to have full control over the funds of your DAO.
The role of the OS, and in this case of the Aragon stack, is to create an environment in which 
apps can abstract over the underlying resources
 while ensuring security.
You can read more and see how they work 
here
.
The layers of the stack
This is a diagram of the Aragon stack, from the Ethereum Virtual Machine to the User Interface
The Kernel
The Kernel is a very simple smart contract. It keeps track of an Access Control List (ACL) app which it uses for 
permission management of the entire DAO
.
The Kernel also knows where to find its installed apps and handles upgradeability of the apps by keeping references to the actual code that apps run.
You can read more about the Kernel 
here
. 
Permission management
In conventional operating systems you just have normal users and admins but for decentralized governance, you need much more.
aragonOS contains a 
rich permissions system
. Any resource or functionality can be assigned a 
role
. Only entities that have permission to call that role can access that resource. Those permissions are all set in the 
Access Control List
.
With aragonOS, permissions work the following way:
Entity 
E
 can call 
Function 
F
 (protected by 
Role 
R
 and parameterized by 
Params 
P
...) on 
App 
A,
 
                                                                      only 
Only if 
Entity 
E
 holds a permission for 
Role 
R
 on 
App 
A
 and their arguments to 
Function 
F
 satisfy 
Rules 
R
. 
​
A 
Permission Manager 
M
 can revoke or reassign that permission.
Which simplified would be:
An entity can call a function on an app and its manager can revoke or reassign that permission.
This enables a great amount of flexibility in permission configuration. You can read more about Permissions 
here
.
Permission escalation
In a conventional OS there is usually just one way to escalate permissions, by using tools like 
sudo
.
With aragonOS, since permissions are so rich, there may be 
many paths to escalate permissions
.
Example:
A token holder may have permission to create a vote, and the voting app may have permission to withdraw funds. In that case, the Aragon client tells the user that option when they attempt to withdraw funds. 
Users can show their intent for performing an action by trying to execute it directly without having to know the process for executing the action. By traversing the Access Control List, Aragon can automatically determine the path needed for executing the action.
Full sandboxing
Permission management is key for allowing security at the smart contract level. This is similar to the Kernel, filesystem and process security in a conventional OS.
Yet the Aragon client is a frontend too, so security is also paramount in the UI environment. This is similar to how many operating systems impose 
app sandboxing
. An app shouldn't be able to access or tamper with another running app. It would be disastrous if a malicious app could inject code or modify the frontend of another app.
Aragon's approach to frontend sandboxing is a combination of 
sandboxed iframes
 and 
cross-origin messaging
 through a custom RPC protocol built specifically for Aragon. Apps do not have direct access to Web3 or Ethereum.
The Aragon Client uses 
aragonAPI 
to provide apps APIs for accessing smart contracts, displaying notifications and signing transactions. When signing transactions, a panel opens up in the client, not in the app. Apps cannot prompt users to sign transactions directly and they cannot interact with the contracts of other apps—in reality, they can only send action "intents". Thus all transactions are securely handled by the Aragon Client, decreasing the attack surface.
You can read more about the Aragon Client 
here
.
Cohesive UI
It is commonly thought that iframes degrade the user experience and are not best practice. Though 
aragonUI
 uses iframes, it has been built to mitigate this issue. Additionally, it allows all apps to look and behave the same to provide a consistent experience for users across Aragon apps.
You can read more about aragonUI 
here
.
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Quick start
Next
App permissions
Last modified 
5mo ago
Copy link
On this page
The layers of the stack
The Kernel
Permission management
Permission escalation
Full sandboxing
Cohesive UI









---PAGE 28---












App permissions - Aragon Developer Documentation




















Links
App permissions
Use the 
Access Control List (ACL)
 to control who can access your app's functionality.
How does it work?
The ACL essentially just contains a set of who has permission to execute an action in an Aragon app and who can re-grant or revoke that permission. 
Most generally, an 
Entity
 can hold the permission to call a function protected by 
Role
 in an 
App
, and their permission is managed by a 
Manager
, who can revoke or regrant that permission.
​
Example
Now let's say we have these 3 apps:
A 
Token Manager
 app, which represents BOB token holders and forwards all their intents to another app
A 
Voting
 app, which executes any arbitrary action after a voting of BOB token holders passes
A 
Finance
 app, which controls the funds of the organization
Entity
App
Role
Manager
Token Manager
Voting
OPEN_VOTE
Voting
Voting
Finance
WITHDRAW
Voting
With the simple mapping in the table above, we have done the following:
Given permission to BOB token holders, using the 
Token Manager
, to open votes in the 
Voting
 app
Given permission to the 
Voting
 app to withdraw funds from the 
Finance
 app
We have achieved a fully democratic way of withdrawing funds in Ethereum! 
🎉
​
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Tech Stack
Next
Forwarding
Last modified 
7mo ago
Copy link
On this page
How does it work?
Example









---PAGE 29---












Forwarding - Aragon Developer Documentation






















Links
Forwarding
Use 
forwarders
 to allow app interoperability and governance.
How does it work?
The ACL allows Aragon apps to be interoperable by creating and managing permissions.
A 
Forwarder
 is a contract that, given some conditions, will pass along a certain action to other contract(s).
Example
A 
Token Manager
 app may send an action to the 
Voting
 app so if a vote passes the 
Voting
 app can withdraw funds from the 
Finance
 app.
This is possible thanks to Forwarders. 
Below is an extract of our 
Voting
 app and is all the code required to make it a Forwarder:
pragma
 
solidity
 
0.4.24
;
​
import
 
"@aragon/os/contracts/apps/AragonApp.sol"
;
import
 
"@aragon/os/contracts/common/IForwarder.sol"
;
​
contract
 
Voting
 
is
 IForwarder
,
 AragonApp 
{
 
/**
    * @notice Creates a vote to execute the desired action, and casts a support vote
    * @dev IForwarder interface conformance
    * @param _evmScript Start vote with script
    */
 
function
 
forward
(
bytes
 _evmScript
)
 
public
 
{
 
require
(
canForward
(
msg
.
sender
,
 _evmScript
));
 
_newVote
(
_evmScript
,
 
""
,
 
true
);
 
}
​
 
function
 
canForward
(
address
 _sender
,
 
bytes
 _evmCallScript
)
 
public
 
view
 
returns
 
(
bool
)
 
{
 
return
 
canPerform
(
_sender
,
 CREATE_VOTES_ROLE
,
 
arr
());
 
}
​
 
function
 
isForwarder
()
 
public
 
pure
 
returns
 
(
bool
)
 
{
 
return
 
true
;
 
}
}
canForward
 checks if a caller 
canPerform
 the action 
CREATE_VOTES_ROLE
. If it can, it means the caller can create a vote.
forward
 checks if a caller 
canForward
, and if it can, it creates a new vote with an 
_evmScript
.
This 
_evmScript
 is the action that will be executed if the voting passes, which can be withdrawing some funds from a 
Finance
 app, for example, but it can be any other action. The action is abstracted and doesn't need to be known in advance.
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
App permissions
Next
Upgradeability
Last modified 
7mo ago
Copy link
On this page
How does it work?
Example









---PAGE 30---












Upgradeability - Aragon Developer Documentation






















Links
Upgradeability
Make your app 
upgradeable
 to fix bugs and push enhancements.
How does it work?
The ACL and Forwarders allow you to create apps that are interoperable and generic so you don't have to reimplement any governance or authentication logic whatsoever. This is thanks to Proxies. 
A 
Proxy
 is a very simple smart contract that consists of decoupling the instance of a particular smart contract with the location of its actual business logic.
All a Proxy does is 
delegate calls to another contract that contains its actual logic
.
This allows for 
upgradeability
 since 
you can always interact with the same Ethereum address for the smart contract
 but its logic can be upgraded over time.
Proxies help enable the decoupling of authentication and logic since you do not need to authenticate any particular version of the smart contract but rather a reference to it that never changes.
We created 
EIP897
, which has been merged, in order to standardize how Proxy interfaces work across all the ecosystem.
The 
aragonOS Kernel
 takes care of maintaining the mapping between the Proxy address of an app and the address where its actual logic lives. 
Then, upgrading an app is as easy as:
    kernel
.
setApp
(
kernel
.
APP_BASES_NAMESPACE
(),
 appId
,
 newAppCodeAddr
)
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Forwarding
Next
Package management
Last modified 
7mo ago
Copy link









---PAGE 31---












Package management - Aragon Developer Documentation




















Links
Package management
Publishing and upgrading
 Aragon apps.
How does it work?
To ease upgrades 
for Aragon apps, both 
app smart contracts and frontend
 can be upgraded using 
aragonPM
.
aragonPM is a DAO built on top of aragonOS (taking advantage of upgradeability and the ACL).
aragonPM allows for multiple package registries to exist with different governance models for package publishing and releasing new versions. 
There is an official Aragon curated aragonPM, 
aragonpm.eth
, which has very strict restrictions of what gets published and very high-quality standards that we use for publishing our core components.
Different aragonPM registries in which everyone can publish their packages are expected to be created by the community. You can create your own registry and have full control over it.
You can read more about aragonPM 
here
.
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Upgradeability
Next
Templates
Last modified 
7mo ago
Copy link









---PAGE 32---












Templates - Aragon Developer Documentation




















Links
Templates
Create templates
 for easy DAO setup.
How does it work?
Creating a DAO with all the desired apps and permissions requires multiple operations that must be properly orchestrated. In the context of Ethereum, performing all these operations would require sending many transactions. This would not only be very costly, as every transaction needs to pay for gas, also the integrity of the deployment depends on all operations occurring in the right order.
For these reasons, the 
recommended way of creating Aragon DAOs
 is using what we call 
templates
, on-chain 
deployment scripts
 that create a DAO and perform all the required configuration steps in an 
atomic manner
 without the possibility of an attacker interacting with the DAO while it is still being set up. 
Templates allow creating a DAO in just one transaction
 and when the transaction is processed the DAO is already 
fully configured and functional
.
Templates can also be thought of as 
DAO templates
 as every template can 
create a DAO
 with 
specific settings
 for an organization type. 
The two DAO configurations that one can choose from when using the 
Aragon client
 correspond to the beta templates (
Democracy
 and 
Multisig
) available in the 
DAO templates repository
.
The above Democracy and Multisig 
kits
 have been deprecated and 
templates
 should now be used instead. You may still find the 
kits
 notation in some places while we make the transition.
Environment setup
Before starting you need to check if you have already installed all these prerequisites:
the right version of 
node.js
 (recommended 
v12 LTS
 version)
Metamask
 web3 provider
the 
aragonCLI
 (Aragon Command Line Interface) 
the 
Aragon Buidler plugin
If you haven't already installed them or if you need more info about this go to the "
Environment Setup
" paragraph 
here
.
Getting started with templates using the aragonCLI
Now we are ready to build our DAO with the templates.
The 
aragonCLI
 (>= v4.1.0) supports using templates to create a DAO to interact with the apps being developed.
To quickly get started developing your own templates:
npx create-aragon-app app
That command will create a new Aragon app project. A sample template for this 
Counter example app 
can be found here in 
Template.sol
​
Import this in the app under the 
contracts
 folder. Then install the 
@aragon/templates-shared
 package which contains contract, deployment, and testing utilities to help you build your own template.
Then to run your DAO enter:
cd app
yarn start
When modifying the name of your contract or app name be sure to update those in 
Template.sol
 otherwise running the template will fail.
The client should load within few minutes. In case of not, please terminate it and then restart it. 
Template structure
All templates follow a similar structure:
1.
Use a 
DAOFactory
 to create a DAO.
2.
Assign the template contract the necessary permissions in the DAO needed for installation (usually only 
APP_MANAGER_ROLE
).
3.
Create app proxy instances for all the apps (
dao.newAppInstance(...)
).
4.
Initialize apps (
app.initialize(...)
).
5.
Set up permissions for the apps and the DAO.
6.
Clean up the permissions temporarily assigned to the template.
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Package management
Next
Aragon client
Last modified 
7mo ago
Copy link
On this page
How does it work?
Environment setup
Getting started with templates using the aragonCLI
Template structure









---PAGE 33---












Aragon client - Aragon Developer Documentation




















Links
Aragon client
How the user experiences an Aragon DAO
How does it work?
The 
Aragon client
 is a 
full dapp
 that can 
create and manage decentralized organizations
 by running Aragon apps inside it.
The client provides Aragon app developers with the following capabilities:
Sandboxing
: The client is running code from third-party developers and so in order to mitigate risk (such as cross-site scripting and phishing attempts by manipulating the DOM) we sandbox apps.
App listing
: It traverses the organization to find all the relevant apps for it.
Transaction pathing
: It checks with the 
ACL 
to see if the user can perform an action (e.g. withdrawing funds) and if not, it gives the user alternative paths to perform it (e.g. maybe by opening a vote)
Human readable transactions
: It uses 
Radspec
 and describes the user action in a human-readable way
Notifications
: Aragon apps can send notifications to the user when something relevant happens
It looks like this: 
The Aragon Client
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Templates
Next
Human readable transactions
Last modified 
7mo ago
Copy link









---PAGE 34---












Human readable transactions - Aragon Developer Documentation






















Links
Human readable transactions
Keeping 
users informed.
How does it work?
A big part of Aragon is user-friendliness, and one of the most unfriendly things in the Ethereum world is transaction data. 
Examine this screenshot of a transaction in MetaMask:
UTF8 string in MetaMask
Would you know what this transaction does? Not even a developer could tell. This is why we created 
Radspec
.
Radspec is a secure alternative to Natspec
. Natspec was supposed to be a way to describe transactions from a Natspec 
expression
 and some transaction data.
The issue with Natspec, however, is that it is insecure. Any JavaScript can execute in Natspec which opens up a lot of potential attacks, like cross-site scripting, which might successfully phish users.
How to use Radspec
It's as easy as adding 
@notice
 to functions in the smart contracts.
contract
 
Counter
 
is
 AragonApp 
{
 
/**
     * @notice Increment the counter by `step`
     */
 
function
 
increment
(
int
 step
)
 
auth
(
INCREMENT_ROLE
)
 
external
 
{
 
// ...
 
}
​
 
/**
     * @notice Decrement the counter by `step`
     */
 
function
 
decrement
(
int
 step
)
 
auth
(
DECREMENT_ROLE
)
 
external
 
{
 
// ...
 
}
}
These Radspec expressions are 
written in comments in your source code
, and they will be grabbed by 
aragon
 and bundled with your app.
The 
Aragon client 
will display these 
with
 the transaction a user is about to perform so that they have a clear understanding of what they're about to sign.
Screenshot of signer showing Radspec
Our Radspec expressions show up while signing a transaction.
Obviously, this is a super trivial example as we are not actually evaluating anything but we could instead write something more complex.
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Aragon client
Next
Guides
Last modified 
5mo ago
Copy link
On this page
How does it work?
How to use Radspec









---PAGE 35---












Troubleshooting - Aragon Developer Documentation






















Links
Troubleshooting
Installing aragonCLI
Unix considerations
If you're seeing several installation errors (e.g. 
node-gyp rebuild
), the problem is probably due to an outdated Node.js version.
aragonCLI currently supports the latest releases of the following Node.js versions: 10, 11 and 12. Recommended version is 
node 12.7
 
Errors could also be do to the need for 
python2
 as a dependency. In that case run:
sudo apt install python2
npm config set python "/usr/bin/python2.7"
If you're seeing errors similar to:
EACCES: permission denied
It's probably because you originally installed Node with root permissions. Because of this, writing to your npm directory (
npm -i -g
) requires root permissions too.
While it's not a good idea to have Node installed this way, one way to quickly give yourself root permissions is to run the slightly modified command:
sudo npm i -g --unsafe-perm @aragon/cli
An arguably better way to fix the problem is to follow the steps outlined in this 
stackoverflow answer.
​
In case of 
​
Windows considerations
Windows is not officially supported by aragonCLI at the moment.
You might need to run the shell with administrator rights when installing the aragonCLI, because our 
go-ipfs
 dependency will need to create a symlink to work correctly.
If you have problems during the instalation of aragonCLI or any other dependencies. You probably need to install 
windows-build-tools
 or similar package.
Again, if you're having trouble fixing things, please reach out to us in our 
#questions-channel
 on the Discord Server. 
Note on Git
You might need to have 
Git
 installed. If you're unsure what Git is, or whether you have it installed, we recommend you follow 
this tutorial.
​
Resetting the devchain
After upgrading aragonCLI, or if unexpected errors are being experienced, 
resetting the devchain
 (by doing 
aragon devchain --reset
 or 
aragon run --reset
) is sometimes useful as it will restart the chain from the snapshot.
The ~/.aragon directory
The aragonCLI creates the 
.aragon
 directory under the user directory where it saves the state of the devchain and the 
Aragon client.
​
In case the client is not loading properly, deleting the 
~/.aragon
 directory will make 
aragon run
 recreate the environment the next time it is used and may solve the issue.
Set a private key
For interacting with aragonCLI you can configure a private key in 
~/.aragon
. Create a file 
<network>_key.json
 (eg. 
rinkeby_key.json
) with this structure:
{
 
"rpc"
:
 
"https://<network>.eth.aragon.network"
,
 
"keys"
:
 
[
"put-your-priv-key-here"
]
}
Then if you use 
--environment aragon:<network>
 when using the aragonCLI commands it will use that account.
You can also define a 
~/.aragon/mnemonic.json
 file like:
{
 
"mnemonic"
:
 
"explain tackle mirror kit ..."
}
Verifying your contracts
You can validate the smart contract and other files of a specific app installed in your Aragon organization with:
dao apps <org-address>
For example 
[email protected]
. We can check the information for that deployment in the 
deploys.yml
 file
. Be sure to look in the environment you are working (eg. rinkeby).
You can check the 
commitHash
 in aragon-apps GitHub repo and view the smart contract code that was deployed for that specific version. For 
v1.1.5
 this is the 
code deployed
.
IPFS
IPFS version
If you have a version older than 
0.4.22
, you should first uninstall your current version with 
aragon ipfs uninstall
 and install IPFS again with 
aragon ipfs install
.
Resetting IPFS
After upgrading aragonCLI, or if unexpected errors are being experienced, resetting IPFS by deleting the 
~/.ipfs
 directory and then run 
aragon ipfs
 sometimes help.
Local IPFS node having trouble loading information from Aragon's IPFS server
The best way around this is to:
1.
Keep trying on the local ipfs daemon
2.
Try accessing that same file in a more generic gateway, like 
ipfs.io/ipfs
3.
Downloading our 
deployments repo
 and running 
npm run pin
 to load all of the previous deployments into your local ipfs daemon (this is 
a lot
 of data though; ~2gb right now). Alternatively you can decompress the archive you need and then just pin that.
Propagating your content hash through IPFS
When publishing a package via 
aragon apm publish
, you will be returned an IPFS content (root) hash. For the Aragon client to load these files through its default IPFS configuration, this hash needs to be accessible at: 
https://ipfs.eth.aragon.network/ipfs/<hash>
.
The best way to propagate and keep your app's content accessible is to pin it via a cloud IPFS-pinning service like 
Pinata
 or 
Temporal
. These services generally offer a generous free-tier that will allow you to host your app if it is not too large.
Otherwise, as a quick fix, if you are running into issues with your hash being propagated to this URL, try running 
ipfs propagate <hash>
 or the following steps.
1.
If you have 
aragon ipfs
 running, quit that daemon.
2.
Run the command 
ipfs daemon --enable-namesys-pubsub
.
3.
Propagate your content through public gateways.
Request your content hash at the following gateways. The 
index.html
 will automatically be loaded if it's available in the hash's root directory:
https://ipfs.eth.aragon.network/ipfs/<hash>
https://ipfs.io/ipfs/<hash>
https://ipfs.infura.io/ipfs/<hash>
​
Check this list
 for additional gateways if you are having trouble with propagating.
If your content also includes an 
artifact.json
 or 
manifest.json
, make sure to separately request these as they will usually not be requested by the 
index.html
:
<gateway>/ipfs/<hash>/artifact.json
<gateway>/ipfs/<hash>/manifest.json
Keep retrying if any files don't immediately become available.
4.
Once successful with step 3, request your hash at the Aragon gateway to double check it has propagated and is immediately accessible by the Aragon client:
https://ipfs.eth.aragon.network/ipfs/<hash>
(If applicable) 
https://ipfs.eth.aragon.network/ipfs/<hash>/artifact.json
(If applicable) 
https://ipfs.eth.aragon.network/ipfs/<hash>/manifest.json
Note that it is best practice to pin the content hash to an IPFS server you manage to ensure its future availability.
Metamask
Using Metamask
To interact with your organization using 
Metamask
 you must make sure that:
It's unlocked
Private network (
Localhost 8545
) is chosen
The first account provided by 
aragon run
 or 
aragon devchain
 is imported and selected. To import the account, copy the private key (something like 
a8a5...1563
), go to the Metamask accounts upper icon (to the left of the hamburguer button), scroll down, click on "Import account" and paste the value you copied.
Issues sending transactions
Because of the way that Metamask caches the account nonces for the different networks, you may be getting the following error when interacting with your app:
Error: the tx doesn't have the correct nonce. account has nonce of: 157 tx has nonce of: 158
The workaround is to switch to a different network (e.g. Rinkeby) and then switch back to the 
Localhost 8545
 network. This will refresh Metamask's account nonce cache. Sending transactions should now succeed.
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Sign a Transaction with Frame
Next
aragonOS
Last modified 
7mo ago
Copy link
On this page
Installing aragonCLI
Unix considerations
Windows considerations
Note on Git
Resetting the devchain
The ~/.aragon directory
Set a private key
Verifying your contracts
IPFS
IPFS version
Resetting IPFS
Local IPFS node having trouble loading information from Aragon's IPFS server
Propagating your content hash through IPFS
Metamask
Using Metamask
Issues sending transactions









---PAGE 36---












How to build your first Aragon App! - Aragon Developer Documentation
































Links
How to build your first Aragon App!
In this guide, we will walk you through building your first 
Aragon App
 using 
aragonOS
, the JavaScript implementation of 
aragonAPI
, 
aragonUI
 and the 
Aragon builder plugin
.
Environment setup
Before starting you need to check if you have already installed all these prerequisites:
the right version of 
node.js
 (recommended
v12 LTS
 version)
Metamask
 web3 provider
the 
aragonCLI
 (Aragon Command Line Interface) 
the 
Aragon Buidler plugin
If you haven't already installed them or if you need more info about this goes to the "
Environment Setup
" paragraph 
here
.
The setup
Let's first set up and bootstrap our project:
npx create-aragon-app foo tutorial
For this particular command switching from 
node v12
 to 
node v14 LTS or v16 LTS
 might be required to prevent a node error on install. In that case you have to switch, do not forget to switch back to 
v12 LTS
 afterwards!
This will create a new directory named 
foo
, with files cloned from 
your first Aragon app template
. This particular boilerplate includes everything you need to get started:
​
buidler
 (now Hardhat), 
aragonOS,
aragonAPI.
Structure
This boilerplate has the following structure:
root
├── app
├ ├── src
├ ├ ├── App.js
├ ├ ├── index.js
├ ├ └── script.js
├ └── package.json
├── contracts
├ └── CounterApp.sol
├── scripts
├ └── buidler-hooks.js
├── arapp.json
├── manifest.json
├── buidler.config.js
└── package.json
app
: Frontend folder. Completely encapsulated, has its package.json and dependencies.
src
: Source files.
App.js
: Aragon app root component.
index.js
: Aragon app entry point.
script.js
: Aragon app background script.
​
package.json
: Frontend npm configuration file.
contracts
: Smart Contracts folder.
CounterApp.sol
: Aragon app contract.
scripts
: Scripts folder.
buidler-hooks.js
: Buidler script hook.
​
arapp.json
: Aragon configuration file. Includes Aragon-specific metadata for your app.
​
manifest.json
: Aragon configuration file. Includes web-specific configurations.
​
buidler.config.js
: Buidler (now Hardhat) configuration file.
​
package.json
: Main npm configuration file.
Stuck?
If you get stuck at any point come back 
here
 to check the diff with changes after the tutorial is completed.
If you need help, please reach out to Aragon core contributors and community members in the 
#dev-space channel
 off our Discord server.
Now let's start with it 💪.
Writing a simple contract
To illustrate how easy it is to use aragonOS, we will build our app as a vanilla smart contract, without any Aragon-specific interfaces at all.
Today, we will build a simple counter app — you can increment it, you can decrement it, and it will all be decentralized. Decentralized coffee counter, anyone? If yes, then add the below code to 
CounterApp.sol
:
// contracts/CounterApp.sol
pragma
 
solidity
 
^
0.4.24
;
​
import
 
"@aragon/os/contracts/lib/math/SafeMath.sol"
;
​
​
contract
 
CounterApp
 
{
 
using
 
SafeMath
 
for
 
uint256
;
​
 
/// Events
 
event
 
Increment
(
address
 
indexed
 entity
,
 
uint256
 step
);
 
event
 
Decrement
(
address
 
indexed
 entity
,
 
uint256
 step
);
​
 
/// State
 
uint256
 
public
 value
;
​
 
function
 
increment
(
uint256
 step
)
 
external
 
{
        value 
=
 value
.
add
(
step
);
 
emit
 
Increment
(
msg
.
sender
,
 step
);
 
}
​
 
function
 
decrement
(
uint256
 step
)
 
external
 
{
        value 
=
 value
.
sub
(
step
);
 
emit
 
Decrement
(
msg
.
sender
,
 step
);
 
}
}
Pretty simple, right? You might wonder why we would bother adding events to this smart contract, but it comes in handy later for illustration purposes — and we can also create an activity feed from it, if we wanted to.
Note

We use 
SafeMath
 for uint256. Using SafeMath is a security convention that allows handling math operations with safety checks that revert on error preventing the risk of overflows.
3 steps to governance and upgradeability
Now for the interesting part: making our simple smart contract an Aragon app.
First
, inherit from the Aragon app smart contract. Integrate this code in 
CounterApp.sol
:
import
 
"@aragon/os/contracts/apps/AragonApp.sol"
;
​
contract
 
CounterApp
 
is
 AragonApp 
{
 
// ...
}
Second
, define the roles that you want your app to have. 
A role can be assigned to other apps or people and those entities will have access to methods guarded by that role.
In this example, we will define a role for incrementing and a role for decrementing but note that you can have a single role to guard all methods in your contract if you find that appropriate. Integrate this code in 
CounterApp.sol
:
contract
 
CounterApp
 
is
 AragonApp 
{
 
// ...
 
bytes32
 
constant
 
public
 INCREMENT_ROLE 
=
 
keccak256
(
"INCREMENT_ROLE"
);
 
bytes32
 
constant
 
public
 DECREMENT_ROLE 
=
 
keccak256
(
"DECREMENT_ROLE"
);
 
// ...
}
Third
, guard the methods with the 
auth()
 modifier that the 
AragonApp
 interface gives you and add an 
initialize function 
to your contract; we use 
initValue
 as the starting value of the counter. Integrate this code in 
CounterApp.sol
:
contract
 
CounterApp
 
is
 AragonApp 
{
 
// ...
​
 
function
 
initialize
(
uint256
 _initValue
)
 
public
 onlyInit 
{
        value 
=
 _initValue
;
​
 
initialized
();
 
}
​
 
function
 
increment
(
uint256
 step
)
 
auth
(
INCREMENT_ROLE
)
 
external
 
{
 
// ...
 
}
​
 
function
 
decrement
(
uint256
 step
)
 
auth
(
DECREMENT_ROLE
)
 
external
 
{
 
// ...
 
}
}
That's it. In 3 steps, you now have an Aragon app, with full upgradeability and modular governance. 
Here
 you can double check whether your code is right.
Descriptive transactions
Aragon wants to be as user friendly as possible, so it provides an easy way for developers to describe what their smart contracts do in a human-readable way. It's called 
Radspec.
 It works by putting 
@notice
 statements alongside a human-readable description for the function. In our example, we use the input 
step
 to describe what is doing our function at runtime.
contract
 
CounterApp
 
is
 AragonApp 
{
 
/**
     * @notice Increment the counter by `step`
     * @param step Amount to increment by
     */
 
function
 
increment
(
uint256
 step
)
 
auth
(
INCREMENT_ROLE
)
 
external
 
{
 
// ...
 
}
​
 
/**
     * @notice Decrement the counter by `step`
     * @param step Amount to decrement by
     */
 
function
 
decrement
(
uint256
 step
)
 
auth
(
DECREMENT_ROLE
)
 
external
 
{
 
// ...
 
}
}
Building the frontend
Because apps inside the 
Aragon client 
are sandboxed, it also means that apps do not have direct access to Web3.
Apps are run inside an iframe, which means that it only has access to their own DOM, not the outlying DOM. The app can communicate with the client over our custom RPC protocol.
Then the client takes care of connecting to Ethereum via Web3, and also handles things like signing transactions, displaying notifications and more to the end-user.
All of this is achieved by using 
aragonAPI
. aragonAPI is split into two parts: one for clients and one for apps. The client portion of aragonAPI reads 
requests
 from the app over RPC, sandboxes apps and performs Web3 actions, whereas the app portion provides a simple API to communicate with the client (to read state, send transactions and more).
Background scripts and building state
Apps usually want to listen to events using Web3 and build an application state from those events. This concept is also known as 
event sourcing
.
aragonAPI was built with event sourcing in mind. To build the state continually without having the app loaded indefinitely, though, we need to run a background script.
Thankfully the 
Aragon client 
will run background scripts specified in the manifest files of our app (more on manifest files later).
Let's start by writing a background script that listens for our 
Increment
 and 
Decrement
 events, and builds a state, for this example, the current value of our counter. Add the below code to 
script.js
:
// app/src/script.js
import
 
'core-js/stable'
import
 
'regenerator-runtime/runtime'
import
 Aragon
,
 
{
 events 
}
 
from
 
'@aragon/api'
​
const
 app 
=
 
new
 
Aragon
()
​
app
.
store
(
 
async
 
(
state
,
 
{
 event 
}
)
 
=>
 
{
 
const
 nextState 
=
 
{
 
...
state
,
 
}
​
 
try
 
{
 
switch
 
(
event
)
 
{
 
case
 
'Increment'
:
 
return
 
{
 
...
nextState
,
 
count
:
 
await
 
getValue
()
 
}
 
case
 
'Decrement'
:
 
return
 
{
 
...
nextState
,
 
count
:
 
await
 
getValue
()
 
}
 
case
 events
.
SYNC_STATUS_SYNCING
:
 
return
 
{
 
...
nextState
,
 
isSyncing
:
 
true
 
}
 
case
 events
.
SYNC_STATUS_SYNCED
:
 
return
 
{
 
...
nextState
,
 
isSyncing
:
 
false
 
}
 
default
:
 
return
 state
 
}
 
}
 
catch
 
(
err
)
 
{
      console
.
log
(
err
)
 
}
 
},
 
{
 
init
:
 
initializeState
(),
 
}
)
​
/***********************
 *   Event Handlers    *
 ***********************/
​
function
 
initializeState
()
 
{
 
return
 
async
 
cachedState
 
=>
 
{
 
return
 
{
 
...
cachedState
,
 
count
:
 
await
 
getValue
(),
 
}
 
}
}
​
async
 
function
 
getValue
()
 
{
 
// Get current value from the contract by calling the public getter
 
// app.call() returns a single-emission observable that we can immediately turn into a promise
 
return
 
parseInt
(
await
 
app
.
call
(
'value'
).
toPromise
(),
 
10
)
}
If you've worked with 
Redux
 before, this might look vaguely familiar.
The 
store
 method takes in a reducer function with the signature 
(state, event) => state
, where 
state
 is whatever you want it to be (in this example it is an integer), and 
event
 is a 
Web3 event
. The reducer function 
must always
 return a state, even if it is the same state as before. Returning undefined will reset the reduced state to its initial null state. Also note that the initial state is always null, not undefined, because of JSONRPC limitations.
The 
store
 should be used as the main "event loop" in an application's background script (running inside a WebWorker). Listens for events, passes them through reducer, caches the resulting state, and re-emits that state for easy chaining. Optionally takes a configuration object comprised of an init function, to re-initialize cached state, and an externals array for subscribing to external contract events. See below for more details.
The store has block caching automatically applied, such that subsequent loads of the application only fetch new events from a cached ("committed") block height (rather than from 0 or the app's initialization block). This state can be observed in the view portion of your app. Also, note that the 
store
 method returns an observable of states. This is a recurring theme in the JavaScript implementation of aragonAPI—almost everything is an 
RxJS
 observable.
Learn more about it on the 
store() documentation
.
​
Here
 you can double check whether your code is right.
Displaying State
Now let's write the view portion of our app. In our case, this is a simple HTML file, and a simple React app with the 
useAragonApi
 
React Hook
 that observes the state that our background script builds for us and returns the data needed to interact with the app contract. Add this code to 
app/index.html
:
<!-- app/index.html !-->
<!
DOCTYPE
 
html
>
<
html
>
 
<
head
>
 
<
title
>
Aragon App
</
title
>
 
</
head
>
 
<
body
>
 
<
div
 
id
=
"
root
"
>
</
div
>
 
<
script
 
src
=
"
src/index.js
"
>
</
script
>
 
</
body
>
</
html
>
Add this code to 
app/src/index.js
:
// app/src/index.js
import
 React 
from
 
'react'
import
 ReactDOM 
from
 
'react-dom'
import
 
{
 AragonApi 
}
 
from
 
'@aragon/api-react'
import
 App 
from
 
'./App'
​
const
 
reducer
 
=
 
state
 
=>
 
{
 
if
 
(
state 
===
 
null
)
 
{
 
return
 
{
 
count
:
 
0
,
 
isSyncing
:
 
true
 
}
 
}
 
return
 state
}
​
ReactDOM
.
render
(
 
<
AragonApi reducer
=
{
reducer
}
>
 
<
App 
/>
 
</
AragonApi
>
,
  document
.
getElementById
(
'root'
)
)
Before using any Hook provided, you need to declare the component 
AragonApi
 to connect the app. It is generally a good idea to do it near the top level of your React tree. It should only be declared once. It has an optional reducer prop, which lets you process the state coming from the background script. If not provided, the state is passed as-is.
​
Here
 you can double check whether your code is right.
App root component
Add this code to 
App.js
:
// app/src/App.js
import
 React 
from
 
'react'
import
 
{
 useAragonApi 
}
 
from
 
'@aragon/api-react'
import
 
{
  Box
,
  Button
,
 
GU
,
  Header
,
  IconMinus
,
  IconPlus
,
  Main
,
  SyncIndicator
,
  Text
,
  textStyle
,
}
 
from
 
'@aragon/ui'
​
function
 
App
()
 
{
 
const
 
{
 appState 
}
 
=
 
useAragonApi
()
 
const
 
{
 count
,
 isSyncing 
}
 
=
 appState
​
 
return
 
(
 
<
Main
>
 
{
isSyncing 
&&
 
<
SyncIndicator 
/>
}
 
<
Header
        primary
=
"Counter"
        secondary
=
{
 
<
Text
            css
=
{
`
 
${
textStyle
(
'title2'
)
}
 
`
}
 
>
 
{
count
}
 
</
Text
>
 
}
 
/>
 
<
Box
        css
=
{
`
          display: flex;
          align-items: center;
          justify-content: center;
          text-align: center;
          height: 
${
50
 
*
 
GU
}
px;
 
${
textStyle
(
'title3'
)
}
;
 
`
}
 
>
 
Count
:
 
{
count
}
 
</
Box
>
 
</
Main
>
 
)
}
​
export
 
default
 App
useAragonApi()
 is a React Hook that returns the data needed to interact with the app contract. As with any React Hook, please ensure that you follow the 
Rules of Hooks
. It returns an object containing the following entries:
appState
: Is the app state, after having passed the background script 
state
 through the reducer prop of AragonApi.
api
: This is the current AragonApp instance. Use it to call methods on the contract.
These are not all the entries but the ones we are going to use in the tutorial. To learn about all of them check the 
useAragonApi documentation
.
Note

We are using several components from aragonUI. aragonUI is a React library based on aragonDS, the Aragon design system. It aims to provide the elements needed to build Aragon apps that feel native to the Aragon ecosystem. We are not going into details of aragonUI on this tutorial. If you feel like to learn more, check the 
Getting started guide
.
Sending transactions
Our users need to be able to increment and decrement the counter. For this, we send what is called an 
intent
 to the client. An intent is an action you would like to occur on a specific contract. This intent is handled by the client, which will calculate a 
transaction path
 using the ACL of our DAO.
To understand transaction paths, we must first understand a little bit about how the ACL works.
The
 ACL (Access Control List) 
is a simple mapping of 
who
 can perform 
what
 actions 
where
. In our case, 
someone
 can perform an action guarded by a specific role (the 
what
) on our app (the 
where
).
However, it's entirely possible that users can not perform actions directly. For example, to increment the counter, we might want a decision-making process, such as a vote. The beauty of aragonOS is that we never need to specify this directly, as this is handled by the ACL.
We simply say that the only one (
who
) that can perform increments and decrements (
what
) on our app (
where
) is the voting app. This is not done at compile-time, it is done at run time.
This works because of a concept called 
forwarders
. A forwarder is simply an app that can execute transactions on someone's behalf, if the ACL permits it, and that app can have its 
arbitrary conditions
 under which it wants to execute your transaction! In the example of the voting app, the voting app will only execute your transaction if the vote passes.
It's really simple to use. Let's add our intents to our app. Integrate this code into 
App.js
:
// ...
​
function
 
App
()
 
{
 
const
 
{
 api
,
 appState 
}
 
=
 
useAragonApi
()
 
const
 
{
 count
,
 isSyncing 
}
 
=
 appState
 
const
 step 
=
 
2
​
 
return
 
(
 
<
Main
>
 
<
Box
>
 
<
div
>
 
<
Button
            display
=
"icon"
            icon
=
{
<
IconMinus 
/>
}
            label
=
"Decrement"
            onClick
=
{()
 
=>
 api
.
decrement
(
step
).
toPromise
()}
 
/>
 
<
Button
            display
=
"icon"
            icon
=
{
<
IconPlus 
/>
}
            label
=
"Increment"
            onClick
=
{()
 
=>
 api
.
increment
(
step
).
toPromise
()}
            css
=
{
`
              margin-left: 
${
2
 
*
 
GU
}
px;
 
`
}
 
/>
 
</
div
>
 
</
Box
>
 
</
Main
>
 
)
}
That's it! Now, whenever the user clicks one of either the increment or decrement buttons, an intent is sent to the wrapper, and it will show the user a transaction to sign.
​
Here
 you can double check whether your code is right.
Writing the manifest files
For aragonAPI to function, it needs some metadata about your app. This metadata is specified in two manifest files; 
manifest.json
 and 
arapp.json
.
arapp.json
arapp.json
 defines the smart contract and aragonPM-specific things like the roles in your app or different environments.
Let's modify 
arapp.json
 so that it knows about the roles we defined previously and use the development environment. Add this code to 
arapp.json
:
{
 
"roles"
:
 
[
 
{
 
"name"
:
 
"Increment the counter"
,
 
"id"
:
 
"INCREMENT_ROLE"
,
 
"params"
:
 
[]
 
},
 
{
 
"name"
:
 
"Decrement the counter"
,
 
"id"
:
 
"DECREMENT_ROLE"
,
 
"params"
:
 
[]
 
}
 
],
 
"environments"
:
 
{
 
"default"
:
 
{
 
"network"
:
 
"rpc"
,
 
"appName"
:
 
"foo.aragonpm.eth"
 
}
 
},
 
"path"
:
 
"contracts/CounterApp.sol"
}
Notice that we input a fully qualified 
ENS
 name for 
appName
. Let's examine the ENS name we entered because it is not entirely arbitrary.
The first label in the ENS name is the name of our app. This can be anything you want, given that the full ENS name is not taken.
The second and third label is the name of the 
aragonPM
 registry that your repository will be (or is) registered to. For the sake of simplicity, this guide assumes that you have rights to create repositories on aragonpm.eth, but you could deploy your aragonPM registry if you so desire.
manifest.json
manifest.json
 defines end-user specific things like the human-readable name of your app, icons, and a small description of your app. It also (optionally) defines background scripts, of which we have one.
Let's modify it accordingly. Add this code to 
manifest.json
:
{
 
"name"
:
 
"Counter"
,
 
"description"
:
 
"My first Aragon app"
,
 
"script"
:
 
"/script.js"
,
 
"start_url"
:
 
"/index.html"
}
Buidler script hooks
These hooks are called by the Aragon Buidler plugin during the start task's lifecycle. All hooks receive two parameters:
Params object that may contain other objects that pertain to the particular hook.
A "bre" or BuidlerRuntimeEnvironment object that contains environment objects like web3, Truffle artifacts, etc.
We are going to use the 
getInitParam
 hook. Must return an array with the proxy's init parameters.
That is called when the start task needs to know the app proxy's initialized parameters, 
_initValue
 for our 
CounterApp
 initialize function. Add tis code to 
buidler-hooks.js
:
// scripts/buidler-hooks.js
module
.
exports 
=
 
{
 
// ...
 
getInitParams
:
 
async
 
(
{},
 
{
 web3
,
 artifacts 
}
)
 
=>
 
{
 
return
 
[
15
]
 
},
 
// ...
}
​
Here
 you can double check whether your code is right.
Running your app locally
To test out your app without deploying a DAO yourself, installing apps, setting up permissions and setting up aragonPM, you can simply run:
yarn
yarn start
Please check you have the right compiler version. It is necessary 0.4.24. If not, select the correct one and run 
npm start
 again.
If you receive a lot of errors on the console, please be sure to run the right node.js (
v12 is required
).
This will do a couple of things for you:
It will start a development chain you can interact with (it uses 
ganache-core
, so it's a full testrpc instance) and prints 10 accounts.
It compiles the contracts.
It deploys the aragonOS bases (ENS, DAO factory, aragonPM registry).
It deploys an Aragon DAO with apps and development permissions (i.e. everyone can do everything)
It builds your app front-end. Since we're importing Node.js modules in our front-end, we need a build script. For this, we opted to use 
parcel
 because it has zero-config, but you can use your favorite bundler.
It publishes your app to a local aragonPM instance.
It installs your app.
It initializes the app proxy with the parameter we defined in 
getInitParams
 hook.
It starts the client locally, installing it if it's not cached.
After running this command a browser tab should pop up with your freshly created DAO, complete with permissions and your local app installed.
Login to metamask (if not already logged in), select the 
Localhost 8545 network
  and import the 
12 words seed phrase
 (account mnemonic) listed on the console (if not already done). Select the account you want to use.
At this point feel free to play around. Both front-end and smart contract files have hot reloading. Yes, even smart contract code, we do a proxy swap on every change under the hood 😎, enjoy.
If you've made it this far, congratulations! 😊🎉😊🎉
Stuck?
If you got stuck at any point check back 
here
 to check whether there's a diff with your code.
Next steps
Tests
If you feel like to keep learning about the Aragon stack right away. A great way of doing it is including some tests on your app. Check the 
test examples
 of the react boilerplate repo for ideas.
Publishing
Now that we're confident that our app will work and amaze the world, we should publish it. You can follow the publishing guide to learn
 how to publish in different environments.
​
Documentation
A good place to go from here would be to check out 
our existing apps
. They are fairly self-contained and use some patterns you might find helpful.
There is much more to 
aragonOS
 and 
aragonAPI
, and we even have our own 
UI toolkit
. We encourage you to explore all 3 and provide us feedback.
Community
Join the conversation and ask questions on 
GitHub
, 
Aragon Technical Forum
 and Discord 
#dTech-general 
channel and make sure to tell us if you build something amazing!
Now you just need to share the great news on Twitter and Reddit, to let people know that you've built something great!
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Interacting with Aragon Agent
Next
How to publish an Aragon App to aragonPM
Last modified 
7mo ago
Copy link
On this page
Environment setup
The setup
Structure
Writing a simple contract
3 steps to governance and upgradeability
Descriptive transactions
Building the frontend
Background scripts and building state
Displaying State
App root component
Writing the manifest files
arapp.json
manifest.json
Buidler script hooks
Running your app locally
Next steps
Tests
Publishing
Documentation
Community









---PAGE 37---












How to use the Agent App - Aragon Developer Documentation




















Links
How to use the Agent App
This guide will show you how to 
install and use the Agent App
.
Introduction
The Agent app (or Aragon Agent) is an Aragon app that can be installed in any Aragon DAO. It's main feature is its ability to perform arbitrary calls to contracts. This means it can be thought of as the 
external interface of a DAO
.
Put another way:
Aragon Agent is a fully-fledged Ethereum account owned by an Aragon organization. 
It's like a multi-signature account on steroids that enables organizations to interact with any Ethereum contract or protocol.
 For example trading tokens on 0x or Uniswap, opening a Maker CDP, managing names in ENS, owning digital LAND parcels, or even breeding digital cats.
In technical terms, it's a superset of the 
Vault app
, which means it can hold valuable assets (ETH and 
ERC-20
 tokens).
Concretely, the Agent app allows for things like:
An Aragon DAO to interact with other Ethereum smart contracts or protocols without the need to implement a custom Aragon app for every protocol.
Members of DAOs to identify themselves as their DAO when using any Ethereum dApp.
An Aragon DAO to participate as a stakeholder in another DAO.
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
How to create your first custom DAO using Aragon CLI!
Next
Installing Aragon Agent from aragonCLI
Last modified 
7mo ago
Copy link









---PAGE 38---












Setting up a Metamask Wallet - Aragon Developer Documentation




















Links
Setting up a Metamask Wallet
In this section, you will learn how to set up a Metamask wallet and how to configure it for use with the 
Quick Start section
.
We recommend using 
Metamask
 as your Web3 wallet. 
Metamask is a browser plugin that lets you make Ethereum (and other blockchains) transactions through regular websites.
 
This guide focuses on a 
Chrome extension
. However, the process is similar for all browsers.
Getting started
Visit the 
Metamask homepage
 and download the browser extension. Once it is downloaded, you should be automatically directed to a welcome page: 
​
Setup your Metamask account following the instructions.
Once your Metamask setup is complete, you should be redirected to your newly created Ethereum wallet:
Metamask account
If you have made it this far, congratulations 🎉.
Account address
If you click on the
 "three dots"
 button below your account name - in our case 
Account 1
 - a popup will appear with your account address. It should look similar to the example below:
0x931D387731bBbC988B312206c74F77D004D6B84b
This is your public address (or public key). You can share this with other people to receive ETH or other tokens.
Selected networks
In the top right you should see a dropdown menu with 
Main Ethereum Network
 selected. With this option, you are able to interact directly with the main Ethereum blockchain.
If you click on it, a selection of other networks will be shown: 
Drop down menu for selecting the network.
Why should you select other networks? 
Before launching a project (or dapp) on the main Ethereum network, it is good practice to deploy a version to an Ethereum test network (like Rinkeby) or on other main networks (like Polygon or Harmony) with low-cost fees to save on costs for transaction fees.
The benefits of using a test net
The main reason for using a test net ETH is that it can be obtained without having to pay real money. This gives developers and the community a chance to iron out any problems before real money is involved.
There are four test nets: 
Ropsten
Kovan
Rinkeby
Goerli
At this stage don't worry about the differences between these networks. 
All you need to know is that they simulate Ethereum and can be used without having to pay real money.
Using private networks
Finally, you can also interact with private Ethereum networks by selecting 
Localhost 8545
. Private in this case doesn't mean more secure. It just means that the nodes are not connected to the main or test network nodes. 
Perfect for rapid experimentation and testing.
Remember that if you want to use different networks, you need to set up your wallet and load your wallet with enough funds for paying the transaction fees. 
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
How to sign with Web3 providers
Next
Import your seed phrase into Metamask
Last modified 
5mo ago
Copy link
On this page
Getting started
Account address
Selected networks
Why should you select other networks? 
The benefits of using a test net
Using private networks









---PAGE 39---












Import your seed phrase into Metamask - Aragon Developer Documentation




















Links
Import your seed phrase into Metamask
In this section, we'll go through how to 
import the 
first-dao
 seed phrase
 into the Metamask wallet.
Log in to your Metamask wallet
The first step is to open up the Metamask browser extension and log in. If you're using Chrome you should be able to open Metamask by clicking on the fox icon located to the right of your address bar 
(see the image below)
. 
If you can't see it, 
click here
. This will open up an interface to your Ethereum wallet. 
Since we will import a new seed phrase, save the seed phrase of your current Metamask account by going to: Settings > Securty & Privacy > Reveal Secret Recovery Phrase.
Click on the 
circle
 in the top right
You should see a black drop-down menu appear 
(see image below):
​
​
Click on the 
Lock
 button in the top right off this menu
You'll be taken to a 
Welcome Back
 page:
​
​
Importing seed phrase
Importing the 12 words phrase will allow you to use Metamask with your 
first-dao.
If you are running the Aragon Client, enter the path and type:
cd first-dao


yarn start
Click on 
Forgot password
. Metamask should now open up in a new window with a heading 
Reset Wallet
. 
Now, what you need to do is to look at the output of your terminal after you run 
yarn start
. You should see the following at the start:
main     | Starting Aragon app development...
main     | App name: first-dao
main     | App id: 0x4c93e09d64b5a9a4c770869d95fd637936feb6ae784413a480ae0aa65889348a
main     | Accounts mnemonic "explain tackle mirror kit van hammer degree position ginger unfair soup bonus"
These 12 words phrases will allow us to use Metamask to access an account that has permission to update the Counter in our Counter app.
Note that your seed phrase (or 
mnemonic phrase
) won't be the same as mine. So make sure you copy yours from your terminal, and not from this blog.
Create a new password
Once you copied the 12 word seed phrase, paste it into the wallet seed text box, and create a new password (see image below):
Click on the 
Restore
 button at the bottom of the page 
The imported account will appear in the 
My account list
 when clicking on the top right circle.
You've now connected Metamask to your 
first-dao
.
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Setting up a Metamask Wallet
Next
Import your private key into Metamask
Last modified 
5mo ago
Copy link
On this page
Log in to your Metamask wallet
Click on the circle in the top right
Click on the Lock button in the top right off this menu
Importing seed phrase
Create a new password
Click on the Restore button at the bottom of the page 









---PAGE 40---












Sign a transaction with Metamask - Aragon Developer Documentation




















Links
Sign a transaction with Metamask
Select the 
first-dao
 account on Metamask
Login to your Metamask wallet, select the 
first-dao
 account which you have imported (see 
here
 how to do this) and select 
Localhost 8545
. 
Increment the Counter
Navigate to your DAO (on 
localhost:3000
) and click on the
 Increment 
button in the Counter app. 
You should see a panel slide in from the right with an error message. The message (in a blue box) basically says you can't perform any actions unless you enable Metamask. 
You should see that the final line inside the blue box reads: 
Please unlock and enable Metamask
. Click on 
enable
 and open up Metamask again.
You should see a connection request from Aragon. Click on the 
Connect
 button to accept it. 
Now go back to the Counter app. 
A possible error 
If you haven't connected your Metamask account to the right network (in this case private network Localhost 8545) you got an error message 😔.
If you have connected your Metamask account to the right network you can skip this section and go 
here
.
In our example, the message says we need to connect MetaMask to the private network. 
Why are we getting this error?
Remember, Metamask defaults to selecting the main Ethereum network when you make a transaction. But our DAO is actually running on a private local network, not the mainnet.
Why are we using a private network?
Remember that using the mainnet requires purchasing ETH with real money. And that using the mainnet or testnets requires us to download the entire past transaction history of the blockchain: this takes a considerable amount of time, and requires a lot of local disk space. In contrast, a private network requires almost no local disk space and can be operated without having to purchase ETH with real money. So it's perfect for rapid experimentation and testing.
Remember, we can connect to a local (private) network by opening up Metamask and selecting 
Localhost 8545
. So let's go ahead and do that.
Close the panel and open MetaMask again. Now, click on the selected network  -  
Main Ethereum 
Network -  and select 
Localhost 8545
 from the dropdown menu that appears. 
You should now see that your account has some ETH. Quite a lot in fact. Unfortunately, this is not real ETH, but it will allow you to perform transactions within your local private network (in other words, increment and decrement the counter).
Now, go back to the 
Counter app
, and click on the 
Increment 
button again.
Confirm the transaction
This time, instead of an error message, you should see an explanation of the action you are about to perform. 
Double check that the action that's about to be triggered is the one you wish to perform. Then click on 
Create transaction.
The app will now signal to you that it's waiting for your signature. 
Open MetaMask again to sign your transaction. You'll be asked to confirm a transaction from Account 1 (your account) to the address of your newly created DAO. The total amount you're sending is about 0.001 ETH: basically just the 
Gas fee
.
 
In case you're unfamiliar with the concept of 
Gas
, the 
Gas fee
 is what's used to incentivize miners to add your transaction to the blockchain. You can think of it as a small tip. Remember that this transaction is taking place on a local (private) network, so this isn't real money. If you're happy with the details of the transaction, click on 
Confirm
.
Now, if you go back to you're first DAO you should see that the counter has finally  incremented! 
If you've made it all the way here, well done! You've just signed your first blockchain transaction with Metamask. 🎉🎉😊
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Import your private key into Metamask
Next
Setting up a Frame Wallet
Last modified 
5mo ago
Copy link
On this page
Select the first-dao account on Metamask
Increment the Counter
A possible error 
Confirm the transaction









---PAGE 41---












How to publish an Aragon App to aragonPM - Aragon Developer Documentation






















Links
How to publish an Aragon App to aragonPM
This guide will show you how to publish an App to 
aragonPM
 
on different environments.
​
Note

1. Publishing your app requires an on-chain action so you must connect an Ethereum account with enough funds on the selected environment to send a publish transaction.
2. Secondly, your app's frontend content is uploaded to IPFS and it becomes 
your responsibility
 to ensure that it stays available to users. Click 
here
 to learn more about IPFS and 
pinning files
.
Environment setup
Before starting you need to check if you have already installed all these prerequisites:
the right version of 
node.js
 (recommended 
v12 LTS
 version)
Metamask
 web3 provider
the 
aragonCLI
 (Aragon Command Line Interface) 
the 
Aragon Buidler plugin
an 
IPFS server.
​
If you haven't already installed them or if you need more info about this goes to the "
Environment Setup
" paragraph 
here
.
Setup
We'll start from the Aragon 
React boilerplate
.
npx create-aragon-app <app name>
Make sure you choose a unique app name which has not yet been registered in the 
aragonpm.eth
 or 
open.aragonpm.eth
 registries since that would lead to an error later on.
This will create a new directory named 
<app name>
  with everything you need.
To interact with aragonPM we will use the 
Aragon Buidler plugin
 already installed in the boilerplate repository.
We will also need a running IPFS server. Open a new Terminal tab and run:
ipfs init
ipfs daemon
For this tutorial, we will assume that the IPFS server is running locally with its:
API port set to 
5001
gateway port set to 
8080
.
If you need an IPFS pinning services, you can chose service like 
Pinata
 and 
Eternum
. They are also available for a reasonable price.
Introduction to environments
This App has 3 environments defined:
Environment
Network
default
localhost
rinkeby
rinkeby
mainnet
mainnet
It is a prerequisite to have a ENS Registry address defined.
Environments are defined in 
arapp.json
, for example 
rinkeby
 points to:
An ENS registry: 
0x98df287b6c145399aaa709692c8d308357bc085d
An app name (repository and registry of aragonPM): 
<app name>.aragonpm.eth
An Ethereum network: 
rinkeby
Note

The 
default
 environment which points to 
localhost
 does not have an ENS Registry address specified because the Buidler plugin will default the value to 
0xB9462EF3441346dBc6E49236Edbb0dF207db09B7
 (the ENS Registry pre-deployed on the local development chain).
Publish a major version: content + contract
To publish the app on aragonPM we will use the following builder task for this tutorial:
npx buidler publish major --network rinkeby
aragonpm.eth
 is a curated ens registry. So unless your app has been curated by Aragon, you can publish your app on 
open.aragonpm.eth.
Read more about it 
here
. 
​
You will likely run into the following error:
Account 0xb4124cEB3451635DAcedd11767f004d8a28c6eE7 does not have permissions to create a new repo in registry aragonpm.eth
​
To solve this open 
arapp.json
 and replace 
<app name>.aragonpm.eth
 with 
<app name>.
open
.aragonpm.eth
 for the network you are publishing to (in this case Rinkeby).
This command will:
Apply version bump (major).
Compile
 and 
deploy
 the app's contract (by default the output lives in 
build
).
Build
 the app's 
frontend (by default the output lives in 
dist
)
.
Generate application artifact.
Publish the app to the 
rinkeby
 environment.
Upload the app's frontend to the IPFS server.
Sample output:
main     
|
   App name:          app.aragonpm.eth
main     
|
   Initial version:   
1.0
.0
main     
|
   Manager address:   0x5Ddb5ec4fF143fDaBCCD0a47F30FF2ce319C2a01
main     
|
   Contract address:  0x2e25c8F88c5cCcbC9400e5bc86cF9C58C7604327
main     
|
   ContentURI:        QmTBapuxxzFHzxdbxxZUmdEmyRxQohxoK7qiXiJ6id36tu
main     
|
 
main     
|
   http://localhost:8080/ipfs/QmTBapuxxzFHzxdbxxZUmdEmyRxQohxoK7qiXiJ6id36tu
main     
|
 
main     
|
 
main     
|
   Tx sent
main     
|
 
main     
|
   Tx hash:  0x954fa737215152d2c9be5893bcda91cf889b30dd5e26bada10b657e87b89692f
main     
|
 
main     
|
 
main     
|
   Tx mined
main     
|
 
main     
|
   Status:        Success
main     
|
   Block number:  
6293860
main     
|
   Gas used:      
960591
In case of 'outdated' or 'cannot resolve dependencies' errors, update and install dependencies.
Note

You can also deploy a major version with only frontend changes by passing the flag: 
--only-content
.
The contract location is defined in 
arapp.json
 under 
path
.
Task syntax and options
The publish task has the following syntax:
npx buidler publish [global options] <bump> [task options]
Where 
global options
 are Buidler's (now Hardhat) 
global options
 and 
bump
 is the version bump (either 
major
, 
minor
 or 
patch
) or the semantic version. E.g. 
minor
 would increase version 
1.2.0
 to 
1.3.0
.
The following 
task options
 are available:
contract
: Address of the app's deployed smart contract.
manager-address
: Permissions manager of the app's aragonPM repo. Must be provided in the initial release.
ipfs-api-url
 (default: 
http://localhost:5001
): IPFS API URL to connect to an IPFS server.
only-content
 (flag): Prevents contract compilation, deployment and artifact generation.
verify
 (flag): Enables Etherscan verification.
dry-run
 (flag): Output transaction data without broadcasting.
Check published versions
To fetch the versions published on aragonPM, we can use the 
aragon apm versions
 
command from aragonCLI.
Command:
aragon apm versions --environment rinkeby
Sample output:
 ℹ app.aragonpm.eth has 
2
 published versions
 ✔ 
1.0
.0: 0xE636bcA5B95e94F749F63E322a04DB59362299F1 ipfs:QmR695Wu5KrHNec7pRP3kPvwYihABDAyVYdX5D5vwLgxCn
 ✔ 
1.0
.1: 0xE636bcA5B95e94F749F63E322a04DB59362299F1 ipfs:QmUYv9cjyNVxCyAJGK2YXjkbzh6u4iW2ak81Z9obdefM1q
If you have an error similar to:
 didn't find any truffle.js 
You need to add a 
truffle.js
 file to the root folder where you are running the command. 
Add the following content and saveshell:
 module.exports = require("@aragon/truffle-config-v4")
Fetch other packages versions
We will fetch the published versions of the official 
voting
 app on the rinkeby (
rinkeby
 network) environment.
Command:
aragon apm versions voting.aragonpm.eth --environment rinkeby
Sample output:
ℹ voting.aragonpm.eth has 
24
 published versions
 ✔ 
1.0
.0: 0x8C06aEBF29F20A2e09b32F5d44cEa49Db3EC2eE0 ipfs:QmQHhcbZRoTKkbjWdwXwqqWZzTNHUFzECPrfqie8f8oq45
 ✔ 
1.1
.0: 0x8C06aEBF29F20A2e09b32F5d44cEa49Db3EC2eE0 ipfs:QmT27VvGNiNeWj4tsZ5omDCc6KxaHU3N9uebFCsoxSAEpL
 ✔ 
1.1
.1: 0x8C06aEBF29F20A2e09b32F5d44cEa49Db3EC2eE0 ipfs:QmYmQVKj44FNjaY2qT4iWMWGSpKmnoseUw7idJkh9mtjei
 ✔ 
1.1
.2: 0x8C06aEBF29F20A2e09b32F5d44cEa49Db3EC2eE0 ipfs:QmWsfxKYLTUyVokhEWEQG9w3Y8VgGbaNGnrL7yx72yPVan
 ✔ 
1.1
.3: 0x8C06aEBF29F20A2e09b32F5d44cEa49Db3EC2eE0 ipfs:QmU6kD8qo4HDnqBmka16DTA61FBUkttarVJumZxrizvduP
 ✔ 
1.1
.4: 0x8C06aEBF29F20A2e09b32F5d44cEa49Db3EC2eE0 ipfs:QmUJoRBNYebTLQu62fmPUjrGQxrA2reWNfiBxKxcf9ydRc
 ✔ 
1.1
.5: 0x8C06aEBF29F20A2e09b32F5d44cEa49Db3EC2eE0 ipfs:QmW3URtbrnZeVQkMP2bLTBe2uF4Eyz9uu2818kVvgJ76c7
 ✔ 
1.1
.6: 0x8C06aEBF29F20A2e09b32F5d44cEa49Db3EC2eE0 ipfs:QmcE6bw5WVwGL6Ewc5qYym6KPCeQfE2xbqeRXESmUuEssC
 ✔ 
1.1
.7: 0x8C06aEBF29F20A2e09b32F5d44cEa49Db3EC2eE0 ipfs:QmTCYzgvrjtV4ETkhM3ZNgrVYNi2roXhNxCRmwsePNqL1B
 ✔ 
2.0
.0: 0xb4fa71b3352D48AA93D34d085f87bb4aF0cE6Ab5 ipfs:QmVpxvSBWY4dLqPzW33UhLXeL17kej1VQJSopaKWjBnu4u
 ✔ 
2.0
.1: 0xb4fa71b3352D48AA93D34d085f87bb4aF0cE6Ab5 ipfs:QmeJq7vK5wUg7AsjTsr6oe8bNDGJzAYuZyk4yY2XBhSdVC
 ✔ 
2.0
.2: 0xb4fa71b3352D48AA93D34d085f87bb4aF0cE6Ab5 ipfs:QmZJbfNXwV5RrRNmKJUsabMzJsupMM7pqtGdcetnb2CHQz
 ✔ 
2.0
.3: 0xb4fa71b3352D48AA93D34d085f87bb4aF0cE6Ab5 ipfs:QmcgUz9PXaZwvA3m7fXPgjsEVKteuivLNSCDvxKGv8ztMa
Building frontends
Your application's frontend will have another build script associated with it, to transpile, bundle, and pack all of its assets (e.g. scripts, images, fonts, etc) together.
If you've used the Aragon React boilerplate, this has already been set up for you with 
parcel-bundler
 and 
aragonUI
.
If you need to add, modify, or remove assets or the way the frontend is built, it's important to remember to 
always
 use 
relative paths
 to serve those assets. Usually, this can be accomplished by adding a 
./
 in front of the path.
This is important because in production, the Aragon client usually fetches all of an app's assets via an IPFS gateway, and non-relative paths break gateway resolutions. You can test this for yourself by attempting to access your app when it's published by going to an IPFS gateway and making sure its assets are being loaded correctly.
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
How to build your first Aragon App!
Next
How to migrate existing Aragon App to Buidler plugin
Last modified 
7mo ago
Copy link
On this page
Environment setup
Setup
Introduction to environments
Publish a major version: content + contract
Task syntax and options
Check published versions
Fetch other packages versions
Building frontends









---PAGE 42---












How to migrate existing Aragon App to Buidler plugin - Aragon Developer Documentation


























Links
How to migrate existing Aragon App to Buidler plugin
This guide aims to describe the basic steps needed to migrate an 
existing Aragon App 
from the 
aragonCLI
 
to the new 
Buidler plugin
. This new Aragon tool offers a more user-friendly and stable developer experience. You can learn more about the Buidler plugin 
here
.
For this tutorial, we will assume that you have existing Aragon App which was setup with aragonCLI and now needs migration to the new Builder plugin.
1. Install dependencies
The first step is to install the following NPM development dependencies:
"@aragon/buidler-aragon"
: "^0.1.0"
"@aragon/contract-test-helpers"
: "0.0.1"
"@nomiclabs/buidler"
: "^1.0.2"
"@nomiclabs/buidler-truffle5"
: "^1.1.2"
"@nomiclabs/buidler-web3"
: "^1.1.2"
"bignumber.js"
: "^9.0.0"
"web3"
: "^1.2.6"
The command for installing the dependencies is:
yarn add <dependencies>
Most of these dependencies should be new to your project and are related to Nomic Labs' 
Buidler
 (now Hardhat), a task runner for Ethereum smart contract developers. However, one dependency that you may need to upgrade is 
web3
, since Aragon's plugin requires 
v1.2.6
 or higher. This may introduce some breaking changes, mostly in tests. See the 
Migrate tests
 section for more information.
2. Add/replace npm scripts
Since the app won't use 
aragonCLI
 anymore, some NPM scripts need to be changed.
In 
package.json
:
"postinstall": "yarn compile && yarn build-app"
"build-app": "cd app && npm install && cd .."
"compile": "buidler compile --force"
"start": "buidler start"
"test": "buidler test --network buidlerevm"
Also, make sure that you have the following two scripts in 
app/package.json
 (note that this is a different 
package.json
 than you just edited!):
serve
: Launches the webserver (Previously called 
devserver
 script in most projects)
watch
: Watches for file changes (Previously called 
watch:script
 script in most projects)
3. Update 
.gitignore
 file
Add the following two folders to your 
.gitignore
 file:
artifacts
cache
4. Create the Buidler config file
Add the following 
buidler.config.js
 file to the root of your project:
const
 
{
 usePlugin 
}
 
=
 
require
(
'@nomiclabs/buidler/config'
)
​
usePlugin
(
'@aragon/buidler-aragon'
)
​
module
.
exports 
=
 
{
 
defaultNetwork
:
 
'localhost'
,
 
networks
:
 
{
 
localhost
:
 
{
 
url
:
 
'http://localhost:8545'
,
 
},
 
},
 
solc
:
 
{
 
version
:
 
'0.4.24'
,
 
optimizer
:
 
{
 
enabled
:
 
true
,
 
runs
:
 
10000
,
 
},
 
},
 
aragon
:
 
{
 
appServePort
:
 
1234
,
 
clientServePort
:
 
3000
,
 
appSrcPath
:
 
'app/'
,
 
appBuildOutputPath
:
 
'dist/'
,
 
hooks
:
 
require
(
'./scripts/buidler-hooks'
),
 
},
}
You can find more information about the Buidler configuration file 
here
 (now Hardhat). As for the 
aragon
 section, it contains 5 main options:
appServePort
: The app server port started by the 
serve
 script of the 
app
 folder. (Default: 
1234
)
clientServePort
: Aragon client server port.
appSrcPath
: Frontend source for the app.
appBuildOutputPath
: Built app path.
hooks
: Aragon hooks functions. (See 
Hooks
 section for more information)
5. Hooks
Hooks are custom functions called at various stages of an app initialization. They can be used to execute any logic before or after the app is created and also to specify the app's 
initialize()
 function parameters. For example, initializing the app with a 
uint256
 and a 
string
 would be as simple as writing the following hook:
getInitParams
:
 
async
 
(
{},
 
{
 web3
,
 artifacts 
}
)
 
=>
 
{
 
return
 
[
23
,
 
'Hello, World!'
]
}
If you were using a template contract before to initialize organization state during 
aragon run
, you should convert the smart contract logic into the hooks. Because hooks are much easier to write, maintain, and debug, the Buidler plugin will not be supporting template contracts. You can find complete examples in 1Hive's 
Conviction Voting
 and 
Payroll
 apps. In our case, we will simply add empty functions since we don't need any initialization logic. So we will create a file named 
buidler-hooks.js
 in the 
scripts
 folder and add the following code:
module
.
exports 
=
 
{
 
// Called before a dao is deployed.
 
preDao
:
 
async
 
(
{},
 
{
 web3
,
 artifacts 
}
)
 
=>
 
{},
​
 
// Called after a dao is deployed.
 
postDao
:
 
async
 
(
{
 dao 
},
 
{
 web3
,
 artifacts 
}
)
 
=>
 
{},
​
 
// Called after the app's proxy is created, but before it's initialized.
 
preInit
:
 
async
 
(
{
 proxy 
},
 
{
 web3
,
 artifacts 
}
)
 
=>
 
{},
​
 
// Called after the app's proxy is initialized.
 
postInit
:
 
async
 
(
{
 proxy 
},
 
{
 web3
,
 artifacts 
}
)
 
=>
 
{},
​
 
// Called when the start task needs to know the app proxy's init parameters.
 
// Must return an array with the proxy's init parameters.
 
getInitParams
:
 
async
 
(
{},
 
{
 web3
,
 artifacts 
}
)
 
=>
 
{
 
return
 
[]
 
},
​
 
// Called after the app's proxy is updated with a new implementation.
 
postUpdate
:
 
async
 
(
{
 proxy 
},
 
{
 web3
,
 artifacts 
}
)
 
=>
 
{},
}
5. Migrate tests
Since the Aragon Buidler plugin uses truffle 5, you may have to migrate part of your tests. You can follow 
this guide
 or the 
truffle team announcement
.
Nevertheless, the following tips can be helpful:
Async/Await
Most truffle contract functions are now asynchronous, so code like this:
const
 dao 
=
 Kernel
.
at
(
'0x9d1C272D0541345144D943470B3a90f14c56910c'
)
should become:
const
 dao 
=
 
await
 Kernel
.
at
(
'0x9d1C272D0541345144D943470B3a90f14c56910c'
)
Web3.js 1.2
Truffle 5 is using Web3.js 
1.2
 instead of 
0.20
, which comes with a few changes:
​
PromiEvent
 objects.
Addresses are now mixed-case instead of lower-case.
Many Web3 utility functions have been moved to 
web3.utils
​
Numbers returned directly from Web3 are now strings.
Functions that return multiple values now return an object with both named and indexed keys.
BN.js
Truffle 5 has also replaced 
bignumber.js
 with 
BN.js
. Instances of 
web3.BigNumber()
 will therefore have to be changed to 
web3.utils.toBN()
.
Ethereum addresses
You now need to use full Ethereum addresses instead of partial ones like 
0x0
. So this address:
const
 
ZERO
 
=
 
'0x00'
would become:
const
 
ZERO
 
=
 
'0x0000000000000000000000000000000000000000'
Coverage
A useful Buidler plugin is available 
here
 for Solidity code coverage.
6. Start the app and uninstall unnecessary dependencies
You are now ready to start your app:
yarn start
You can also uninstall dependencies that are no longer required:
@aragon/cli
ganache-cli
truffle
yarn remove <dependencies>
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
How to publish an Aragon App to aragonPM
Next
How to change the Quorum of your DAO
Last modified 
7mo ago
Copy link
On this page
1. Install dependencies
2. Add/replace npm scripts
3. Update .gitignore file
4. Create the Buidler config file
5. Hooks
5. Migrate tests
Async/Await
Web3.js 1.2
BN.js
Ethereum addresses
Coverage
6. Start the app and uninstall unnecessary dependencies









---PAGE 43---












How to change the Quorum of your DAO - Aragon Developer Documentation




















Links
How to change the Quorum of your DAO
Did you setup a DAO on Aragon Client, only to later realize that you want to change the 
minimum Quorum
 (turnout) for votes in your DAO? Then this guide is for you!
But also if you want to change the default 
minimum Quorum Percentage
, or something else, you can use the same principles as in this guide.
As they say: 'there is more than one road leading to Rome'! In this case we will show you the two easiest options to do it:
1.
​
Using the inbuilt (hidden) 
Console
 in Aragon Client
​
2.
​
Using
 EVM Crispr
, a tool to edit the 'DNA' of DAOs
​
​
Previous
How to migrate existing Aragon App to Buidler plugin
Next
Change Quorum using Aragon Console
Last modified 
7mo ago
Copy link









---PAGE 44---












Deploying Aragon Client in new Chains - Aragon Developer Documentation






















Links
Deploying Aragon Client in new Chains
Introduction
This guide will run you through how to 
deploy Aragon to other EVM compatible chains.
This deployment is self-sufficient and does not pose a requirement on other contracts already deployed to the target chain.
Before you begin, make sure that there are no official deployments to the network you will be targeting.
Official Aragon Client deployments
Network Name
ENS Registry
Type
Deployment
Ethereum Mainnet
0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e
Official
​
Aragon
​
Ethereum Rinkeby
0x98df287b6c145399aaa709692c8d308357bc085d
Official
​
Aragon
​
Ethereum Ropsten
0x6afe2cacee211ea9179992f89dc61ff25c61e923
Official
​
Aragon
​
Polygon Mumbai
0x431f0eed904590b176f9ff8c36a1c4ff0ee9b982
Official
​
Aragon
​
Polygon Mainnet
0x3c70a0190d09f34519e6e218364451add21b7d4b
Official
​
Aragon
​
Harmony Testnet
0xbc7828fa8665c637901ad5abd5c7e647c9ab140f
Official
​
Aragon
​
xDAI
0xaafca6b0c89521752e559650206d7c925fd0e530
Trusted Partner
​
1Hive
​
Harmony
0x843ddfab8406e752d03fa75dbb275070f368658d
Official
​
Aragon
​
BSC Testnet
0x843ddfab8406e752d03fa75dbb275070f368658d
Official
​
Aragon
​
​
Deployment information
​
Good Manners
1.
Please verify all contracts that you have deployed with the target network scanner unless they are automatically verified.
2.
Notify the Aragon team about your plans to deploy to the target network.
3.
Keep the team in close loops about the issues you encounter as well as any ambiguity during the process.
4.
Do not change the smart contract code.
5.
Any automation and new scripts are welcome. Create a PR for the respective Github repository.
Deploying
Before you start
1.
We will use notation 
<target network>
 to represent the network we are deploying to. It should be consistent throughout this tutorial.
2.
Make sure that you use one account thought the tutorial. You will need Private key and some network tokens to pay for gas.
Step 1
Description:
 Provide an account that will be used to deploy contracts as well as rpc connection to the target network.
This account will be the owner of the deployed Aragon infrastructure. To be considered an official deployment we will need to transfer all permissions from this account to an official Aragon account.
To provide access to an account using a Private Key:
1.
Create a file 
nano ~/.aragon/<target network>_key.json
2.
Add the following inside the file
{
  "rpc": "<RPC url for your target network, for example "<https://rpc-mainnet.matic.network>" for Polygon>",
  "keys": ["Your Private Key"]
}
To provide access to an account using a Seed Phrase:
1.
Create a file 
nano ~/.aragon/mnemonic.json
2.
Add the following inside the file
{
  "rpc": "<RPC url for your target network, for example "<https://rpc-mainnet.matic.network>" for Polygon>",
"mnemonic": "your mnemonic phrase..."
}
Step 2
Description:
 Deploy 
AragonOS
, which contains all main contracts, to the target network. This will allow creating new DAOs as well as publish apps to APM.
1.
Clone 
AragonOS
 repository
2.
Checkout to 
master
 branch instead of default 
next
 branch.
The 
master
 branch contains AragonOS v4.4.0 latest stable version. Whereas the 
next
 has more features, but we don’t want a disputable feature for now.
3.
Run 
yarn
4.
Run 
yarn add @aragon/truffle-config-v4
5.
Update 
node_modules/@aragon/truffle-config-v4/truffle-config.js
 with the new network information
Example:
mumbai
:
 
{
network_id
:
 
80001
,
provider
:
 
providerForNetwork
(
'mumbai'
),
gas
:
 
6.9e6
}
6.
Run 
yarn compile
7.
Deploy 
ENS
 to the target network
In case the network does not have an official ENS registry, one should deploy it themselves using provided 
ENSFactory
.
If there is an official ENS deployment, you can use it or deploy a new ENS. If you decide on using an official ENS, make sure to purchase the 
aragonpm.eth
 domain with the key provided in step 1.
Run the command below in AragonOS repo, substituting placeholder values:
OWNER=<Your Public Key> npx truffle exec --network <target network> scripts/deploy-test-ens.js
8.
Deploy 
DaoFactory
DAO factory will already include other contracts that are necessary for the contract deployment. It is a very large contract, and we are aware that some networks do not offer enough gas per block to deploying it.
You might encounter RPC failing due to making too many calls in a short period of time. As a solution split the deployment script into several subparts or use a more reliable RPC in step 1.
Run the command below in AragonOS repo, substituting placeholder values:
OWNER=<Your Public Key> npx truffle exec --network <target network> scripts/deploy-daofactory.js
9.
Deploy 
APM
 (Aragon Package Manager) to the target network
You should be able to deploy 
APM
 in its own repository. However, currently, it does not work due to an unknown issue. 
If you could fix it, it would be greatly appreciated and you will get rewarded!
As a workaround, you should deploy the APM in the AragonOS repository.
Run the command below in AragonOS repo, substituting placeholder values:
OWNER=<Your Public Key> ENS=<ENS Registry address from step>  DAO_FACTORY=<DAO Factory address from step 2> npx truffle exec --network <target network> scripts/deploy-apm.js
Step 3
Description:
 Deploy 
AragonID
.
1.
Clone the repo master branch.
2.
Run 
yarn
 to install packages
3.
Setup truffle-config on 
node_modules/@aragon/truffle-config-v4/truffle-config.js
 as previous step
4.
Update the 
truffle.js
 to point to the right truffle-config. Basically replace its contents with
module
.
exports 
=
 
require
(
"@aragon/truffle-config-v4"
)
5.
run 
yarn compile
 to build the contracts
6.
Run the following script:
OWNER=<Your public key> ENS=<ENS Registry address from step> npx truffle exec --network <target network> scripts/deploy-beta-aragonid.js
Step 4
Description:
 Deploy standard 
Aragon Apps
 to the AragonPM.
1.
Clone 
Aragon Apps
 repository
2.
Provide your Private Key
Create 
.env
 file in the root directory of the 
Aragon Apps
 repository with the following content:
ETH_KEYS=0x<Your Private Key>
3.
Update 
node_modules/@aragon/hardhat-config/hardhat.config.js
 with the new network information. Ex:
mumbai
:
 
providerForNetwork
(
'mumbai'
)
4.
Deploy an app
Repeat this for each app inside the 
\\apps
 directory. We will use the Finance app here as an example.
IMPORTANT:
 Do not try to deploy 
voting-disputable
 and 
agreement
 apps they require Aragon Court instance present on the target network.
1.
Navigate to the apps directory (
\\apps\\finance
)
2.
Change 
arapp.json
In the 
environment
 part add information about your target network.
For the 
registry
 variable specify ENS address that we have obtained in step 2.
    "<target netwrok>": {
      "registry": "<ENS Registry address>", 
      "appName": "finance.aragonpm.eth", // app name
      "network": "<target network>"
    }
3.
Run 
yarn
4.
Run 
yarn compile
 to generate contracts
5.
Run 
yarn build
 to build the UI App part
6.
Start a local version of IPFS with 
ipfs daemon
If you don't have IPFS installed, check here 
https://docs.ipfs.io/install/command-line/
 how to install it
7.
Publish the App to APM
npx hardhat publish major 
--
network mumbai 
--
ipfs
-
api
-
url 
<
http
://
localhost
:
5001
>
8.
Download the files that were uploaded to IPFS with 
ipfs get <CID>
. The CID is available from previous step
9.
Compress the folders that were downloaded and send to 
[email protected]
 so they can be pinned.
Step 5
Description:
 Deploy standard 
DAO Templates
 to the AragonPM.
1.
Clone 
DAO Templates
 repository
2.
Provide your Private Key
Create 
.env
 file in the root directory of the 
Aragon Apps
 repository with the following content:
ETH_KEYS=0x<Your Private Key>
3.
Go to 
/shared
 directory and run 
yarn
 and then 
yarn link
If you have problems with node version on installing dependencies, add 
--ignore-engines
 to the command
4.
Deploy a template
Repeat this for each template inside the 
/templates
 directory. We will use the Company template here as an example.
IMPORTANT:
 Please only try to deploy 
company
, 
reputation
 and 
membership
 templates, as other templates do not contain all required components.
1.
Navigate to the templates directory (
/templates/company
)
2.
Run 
yarn link @aragon/templates-shared
3.
Run 
yarn
 to install dependencies
4.
setup truffle-config on 
node_modules/@aragon/truffle-config-v4/truffle-config.js
 as previous step
5.
Change 
arapp.json
In the 
environment
 part add information about your target network.
For the 
registry
 variable specify ENS address that we have obtained in step 2.
   "<target network>": {
      "registry": "<ENS Registry address>", 
      "appName": "finance.aragonpm.eth", // app name
      "network": "<target network>",
	    "wsRPC": "<RPC url for your target network, for example wss://matic-testnet-archive-ws.bwarelabs.com for Polygon>"
    }
6.
switch to node 10
7.
Run 
yarn compile
8.
switch to node 12
9.
Change 
package.json
Add a new script below to the 
scripts
 section.
Please note that if you are using the official ENS, then you should also acquire the 
aragonid.eth
 domain for the step below to work.
"deploy:<target network>": "truffle exec ./scripts/deploy.js --network <target network> --ens <ENS Registry address from step 2> --dao-factory <DAO Factory address from step 2>"
10.
Run 
yarn deploy:<target network>
 to deploy the Template
This should deploy additionally 
AragonId
 and 
MiniMe Token Factory
. Copy the 
MiniMe Token Factory
 address and when deploying the next template add it to the script in step 7:
"deploy:<target network>": "truffle exec ./scripts/deploy.js --network <target network> --ens <ENS Registry address from step 2> --dao-factory <DAO Factory address from step 2> --mini-me-factory <MiniMe Factory address that we have just deployed>"
11.
Start a local version of IPFS with 
ipfs daemon
If you don't have IPFS installed, check here 
https://docs.ipfs.io/install/command-line/
 how to install it
12.
Publish the Template to APM
npx hardhat compile && npx hardhat publish major --contract <Template contract that we got in previous step> --network <target network> --ipfs-api-url <http://localhost:5001/>
Previous
Change Quorum using EVMcrispr
Next
Deployments information
Last modified 
7mo ago
Copy link
On this page
Introduction
Official Aragon Client deployments
Good Manners
Deploying
Before you start
Step 1
Step 2
Step 3
Step 4
Step 5









---PAGE 45---












How to Brick your DAO 🧱 - Aragon Developer Documentation




















Links
How to Brick your DAO 🧱
Warning
Don't try this at home!
 This guide is meant to make you aware of some of the mistakes you can make which will 
brick
 🧱 (ruin) your DAO.
Top ways to Brick 🧱 your DAO:
1.
Set the minimum accepted Quorum Percentage of Votes in your DAO to 100%, and then lose access to the only Wallet Account which can vote 
😱
.
Lesson
Reconsider whether a high 100% Quorum is necessary, and make sure you always have a backup of your Wallet Account secret recovery phrase.
2. Go to the Aragon Forum for help and copy/ paste the private keys of the Web3 Wallet controlling your DAO. Someone found the private keys, took control of your wallet and is now in control of your DAO 
😱
.
Lesson
Never ever share 'secrets' like your private keys, secret recovery phrase, or something else secret on a public forum, Discord server, or not even in a direct message (DM), there are a lot of scammers out there looking for this info.
3. Mint new DAO tokens to the address of the DAO, instead of to a DAO member, which makes the 'DAO address' the largest token holder. DAO addresses can not vote, and since it is the largest DAO token holder not a single vote can be enacted anymore 
😱
. 
Lesson
Only mint DAO tokens to DAO members wallet addresses, and never send them to a smart contract such as the address of your DAO.
4. You have a bad actor in your DAO and want to get rid of him by removing/ burning all of his DAO tokens. Accidentally you remove/ burn all of your own DAO tokens, and the Vote to do so has already been approved by your DAO members! Now you lost control over your DAO 
😱
. 
Lesson
It's easy to make fatal mistakes, always double-check the details when making transactions in your DAO.
Warning
Again don't try this at home! 
This guide is meant to make you aware of some of the mistakes you can make which will 
brick
 🧱 (ruin) your DAO.
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Metis Andromeda
Next
How to sign with Web3 providers
Last modified 
7mo ago
Copy link









---PAGE 46---












How to sign with Web3 providers - Aragon Developer Documentation




















Links
How to sign with Web3 providers
In this section, we will show how to set up and sign a transaction with two different web3 providers:
Metamask wallet
Frame wallet
Previous
How to Brick your DAO 🧱
Next
Setting up a Metamask Wallet
Last modified 
7mo ago
Copy link









---PAGE 47---












Setting up a Frame Wallet - Aragon Developer Documentation




















Links
Setting up a Frame Wallet
In this section, you will learn how to get started with Frame and interact with a DAO using a hardware wallet.
Install Frame
Go to the 
Frame website
 and install the Frame desktop client and browser extension.
Download Frame Page
Setup
You need a Metamask, Ledger or Trezor wallet to use Frame. 
Start by downloading Frame from the official website: 
https://frame.sh
. Afterwards, you will find Frame in your Menu bar. 
Configure your device
Metamask
To import your Metamask wallet into Frame:
Click on the 
+
 
button in the Accounts bar in top of the wallet.
Click on the 
add new accounts
 button in the frame which pop-ups on the right.
Click on the 
seed phrase
 button.
Copy and paste the seed phrase from your Metamask wallet and click 
next 
(see image below).
Your Metamask wallet should now appear in the Frame wallet.
Please note that the view can be a bit different depending on your machine / OS. 
Ledger
On Ledger devices insert your pin to unlock it. Next open Frame. 
Trezor
On Trezor devices insert your pin directly on Frame. You should now be able to select the network and account you would like to use.
 
Network
To choose the desired network, select the
 three arrows
 button on the upper right corner. This will take you to Frame menu, where you can configure its general settings. 
We will focus on the 
Connection
 option. 
Feel free to choose any of the following networks: 
Rinkeby, Mainnet, Ropsten, Kovan
.
For this tutorial we will select Rinkeby.
Accounts
The last step is to choose your account. Click on the
 Configuration 
button. You will find it on the right of the Ledger or Trezor icon. Click on the 
Accounts
 button that pops up below the icon. This will display a new menu with the available accounts on your device for the network. Select one with some test-Ether.
 If you don't have any, you can request a Rinkeby faucet 
here
 or 
here
.
In the configuration menu you can also manage the Dapp permissions you have granted for that particular account. We'll explain more about this in 
this section
. 
You are now finished setting up Frame for your device and ready to sign your first transaction.
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
About the Dev Support category
Aragon Support Forum
Previous
Sign a transaction with Metamask
Next
Sign a Transaction with Frame
Last modified 
5mo ago
Copy link
On this page
Install Frame
Setup
Configure your device
Metamask
Ledger
Trezor
Network
Accounts









---PAGE 48---












Introduction - Aragon Developer Documentation




















Links
Introduction
Upgradeability
 
Upgradeability
 is one of the key features of 
aragonOS
.
Because upgradeability implies there will be multiple versions of a package of software, we decided to build aragonPM as the main way to 
distribute different versions of the packages
 that comprise the Aragon client. As we built it, however, we realized that its use cases could extend far beyond just ours as a publicly accessible piece of infrastructure living on Ethereum.
A package or 
repository
 (repo) in an aragonPM registry keeps track of evolving versions of its contents (the webapp component typically) and smart contract code (if applicable).
aragonPM as an Aragon DAO
aragonPM is built on top of 
aragonOS
. It is a Decentralized Autonomous Organization (DAO) running on the same Aragon that‘s used to build Aragon organizations (to take advantage of upgradeability and access control)!
This allows for many aragonPM registries to exist with different governance models for package creation and publishing new versions. There is an official Aragon curated instance, 
aragonpm.eth
, which has high-quality standards and strict restrictions on what can get published, that we use for publishing our core components.
Different aragonPM registries in which everyone can publish their packages are expected to be created by the community, and we have set up 
open.aragonpm.eth
 on both the main and Rinkeby networks as an open instance available for anyone to publish to.
To get more experience with creating a custom DAO from the command line (aragonCLI), installing apps on a custom DAO, building and publishing your own apps on aragonPM, follow one of the below guides 
👇
.
Guides
1.
​
Learn how to build your first app
, so you can publish it onto an aragonPM registry
2.
​
Publish your application onto an aragonPM registry with the CLI
​
3.
​
Guide others to install your app from an aragonPM registry
, and finally,
4.
​
Submit your app to the Aragon Client's App Center
​
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
aragonPM
Next
Architecture
Last modified 
7mo ago
Copy link
On this page
Upgradeability 
aragonPM as an Aragon DAO
Guides









---PAGE 49---












Architecture - Aragon Developer Documentation




















Links
Architecture
aragonPM Architecture: Registries, Repos and versions
The architecture of an aragonPM DAO 
👇.
As a DAO, each aragonPM registry includes a number of installed applications, including one APMRegistry, one ENSSubdomainRegistrar, and many Repo instances. 
The aragonPM registry controls a 
Ethereum Name Service
 (ENS) domain through its ENSSubdomainRegistrar, allowing each new created Repo to be assigned its own subdomain. This gives users the ability to 
find repos with human-readable names
, such as 
voting.aragonpm.eth
.
We envision that many aragonPM registries will be created for different purposes and types of packages. For Aragon, we use the 
aragonpm.eth
 registry to host our core components. We also have the 
open.aragonpm.eth
 registry for community developed packages, where anyone can create repos.
At the repo level, each repo can have 
its own rules
 that govern 
how new versions can be published
 using the 
Access Control List
 from aragonOS. This allows for setting up different types of processes depending on the importance of the repo or the nature of the upgrade (major, minor or patch).
A Repo is created in a Registry and can have many versions published over time 
👇.
A repo keeps a versioned history of content and smart contract code tuples. The content is an on-chain reference to a blob of data that lives off-chain (we currently support IPFS or HTTP addressing). By using IPFS we have the assurance of the 
integrity
 of the data and that it hasn't changed since it was published. We recommend always publishing using a content-addressed network, like IPFS, but having HTTP is useful for testing or less critical code.
The smart contract code only applies to packages that have an on-chain contract component associated with a particular version. It can be the 
implementation code for 
upgradeable Proxies
 or a smart contract that can be directly used. By having these code addresses stored on-chain, smart contracts can use aragonPM directly to get the latest version of the code for a repo.
aragonPM gives users 
complete transparency
 over all deployments and 
traceability
 of what the process of publishing a new version entailed.
It is important to point out that aragonPM acts as the reference to what the last version of a repo is but 
all upgrades are opt-in
 and users of the repo, such as Aragon organizations, need to decide to upgrade or keep using an old version through their own governance mechanisms. Automatically upgrading all users of a repo is extremely dangerous regardless of the upgrade governance mechanism. That's why all upgrades are opt-in and must be started by the user. Someone could, however, build an auto-update contract that users could allow to automatically update their dependencies.
Interacting with aragonPM: apm.js and aragonCLI
In order to interact with aragonPM registries, we have built 
apm.js
 as a standalone JS library to inspect aragonPM repos, get their different versions, and fetch the referenced content. The library also allows interaction with aragonPM contracts for creating new repos or versions.
The 
aragonCLI
 also uses apm.js to provide a great developer experience for creating and publishing new versions of Aragon apps as aragonPM repos. The CLI's aragonPM commands, accessible through 
aragon apm
, are the easiest way to manage aragonPM repos.
Using the aragonCLI to publish a version to an aragonPM repo and inspect it 
👇.
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Introduction
Next
Reference documentation
Last modified 
5mo ago
Copy link
On this page
aragonPM Architecture: Registries, Repos and versions
Interacting with aragonPM: apm.js and aragonCLI









---PAGE 50---












Reference documentation - Aragon Developer Documentation




























Links
Reference documentation
aragonPM is built from three aragonOS-powered applications:
​
✅
 
APMRegistry


✅
 
ENSSubdomainRegistrar


✅
 
Repo
​
APMRegistry
APMRegistry governance
Each instance of an APMRegistry can have a different governance model. Governance of a registry is enforced directly using the DAO's ACL.
By default, a new repo will set the creator (or 
dev
 param) as the owner of the repo and it is the only address that can create new versions in the repo. However, as the permission manager, this account can grant permission to create versions for other entities. These entities can be anything from another dev to a multisig or a full-blown DAO.
ENSSubdomainRegistrar
Aragon app with the logic and permissions to add and delete subdomains to the ENS domain owned by the APMRegistry DAO.
Upon initialization, ownership of the ENS name that the APMRegistry operates is transferred to the ENSSubdomainRegistrar app that is installed in the DAO. In our deployments, we ensure this is completed on deployment through a APMRegistryFactory contract that assigns the APMRegistry the ENSSubdomainRegistrar's 
POINT_ROOTNODE_ROLE
 and then calls 
initialize()
 on the APMRegistry.
The APMRegistry also needs to have permissions for the ENSSubdomainRegistrar's 
CREATE_NAME_ROLE
 in order to create new names, which is done every time a repo is created.
API documentation
See 
APMRegistry 
and 
ENSSubdomainRegistrar.
​
Repo
After 
discovering the apps of a DAO by traversing its ACL
, we can fetch their 
app.appId()
s and use ENS to resolve their Repo contracts:
repo 
=
 
Repo
(
Resolver
(
ens
.
resolver
(
appId
)).
addr
(
appId
))
or using 
ethereum-ens
:
repo 
=
 Repo
.
at
(
await
 ens
.
addr
(
appId
))
Every individual Repo is an Aragon app that leverages the ACL in the aragonPM DAO. Depending on each aragonPM registry's governance model, the process for creating new versions in the Repo or transferring ownership may vary.
A Repo keeps versioned state over the following components:
Smart contract library code
 (
contractAddress
): the app code is the address of the deployed contract version of the app. An organization's Kernel determines which version of the app it uses by pointing to the app code address associated with that version.
Package content
 (
contentURI
): defined by a location ID of where the other components of the package (e.g. frontend) are hosted (IPFS, Swarm, etc.) and the content hash for fetching it. An 
arapp.json
 file is expected to be found in this package.
A Repo does not need to contain both components but, whatever the case, all the rules below still apply.
By versioning both the app code address and the package content we can add additional expectations for the what semantic versioning of Repos mean:
Patch
: Minor changes to the package contents (e.g. frontend). Update can be performed silently for users.
Minor
: Significant changes to the package contents but still works with the current smart contract code. Users should be notified of the update.
Major
: Any change to the smart contract app code that requires user interaction in order to upgrade.
Version upgrade rules
Before creating a new version in a repo an ACL check is performed to determine whether the entity has permission to create a new version.
After the ACL check, the Repo logic checks whether the version upgrade is allowed. A version bump for a package is defined by the following rules:
Only one member of the version is increased by 1. The version components to the left of the raised member must stay the same and the components to the right must be 0.
Example: From 
2.1.3
 the only allowed bumps are to 
3.0.0
 (major version), 
2.2.0
 (minor version), and 
2.1.4
 (patch version).
Changes to the app code address can only be done if the raise changes the major version (upgrading it to 
M.0.0
 by the above rule).
The initial version of an app must be a valid bump from version 
0.0.0
.
By having this check performed at the smart contract level we can load the correct version of the frontend just by looking at an instance of an app. This is done by checking that the version of a smart contract is linked to a given app by getting its 
appId
 and 
appCode
 (see section below 
By latest contract address
).
Fetching Repo versions
Repos offer multiple ways to fetch versions. By checking the logs for the following event, one can see all the versions ever created in a Repo:
(
Repo
)
 
NewVersion
(
uint256
 versionId
,
 
uint16
[
3
]
 semanticVersion
);
All the different methods for fetching versions return the following tuple:
repoVersion 
=
 
(
uint16
[
3
]
 semanticVersion
,
 
address
 contractAddress
,
 
bytes
 contentURI
);
By versionId
Every version can be fetched with its 
versionId
 (which starts at 
1
 and is incremented by 
1
 on each new version).
repoVersion 
=
 repo
.
getByVersionId
(
versionId
);
The total count of versions created in a Repo can be queried with:
count 
=
 repo
.
getVersionsCount
();
lastVersionId 
=
 count 
-
 
1
;
By semantic version
A version can be fetched by providing the exact semantic version:
repoVersion 
=
 repo
.
getBySemanticVersion
([
major
,
 minor
,
 patch
]);
By latest contract address
Fetching the latest version by contract address is useful for clients to easily fetch the latest minor or patch release associated with a particular major version. This makes it particularly easy for organizations to still be served the relevant frontends if they have not updated their smart contract code to the latest major version.
repoVersion 
=
 repo
.
getLatestForContractAddress
(
contractCode
);
Latest version
The latest version of a Repo can be fetched as follows:
repoVersion 
=
 repo
.
getLatest
();
API documentation
See 
Repo.
​
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Architecture
Next
aragonAPI
Last modified 
5mo ago
Copy link
On this page
APMRegistry
Repo









---PAGE 51---












Global configuration - Aragon Developer Documentation






















Links
Global configuration
The 
arapp.json file
 
contains metadata for your app, and the 
manifest.json
 defines end-user specific configurations.
The arapp.json file
The arapp.json file contains metadata for your app. These are the fields which need to be present:
roles
: An array of all the roles that your app has. Each role has the following properties:
id
: The identifier of the role as it is defined in the contract.
name
: A description of the role in the app.
params
: The names of any parameters for the role.
environments
: An object containing deploy environment configurations.
env_name
: An object containing the configuration for a specific environment. 
env_name
 can be any name you choose.
appName
: The ENS name of your app where the aragonPM repo can be located.
network
: The network to use for this environment.
wsRPC
: (optional) If present is used by aragon.js as its data provider.
registry
: (optional) The address of the ENS registry for this environment. Defaults to the default ENS registry for this network.
apm
: An object containing apm options.
ipfs
gateway
: An URI to the IPFS Gateway to read files from. Defaults to 
http://localhost:8080/ipfs
.
rpc
: An URI to the IPFS node used to publish files. Defaults to 
http://localhost:5001#default
.
path
: The path to the main contract in your app.
links
: (optional) Array of links. Each object in that array should have name and address attributes. Used to links any linkable contracts into the deploying contract bytecode.
Example
This is the arapp.json of the app build in the 
tutorial
 configure with default environments:
{
 
"roles"
:
 
[
 
{
 
"id"
:
 
"INCREMENT_ROLE"
,
 
"name"
:
 
"Increment the counter"
,
 
"params"
:
 
[]
 
},
 
{
 
"id"
:
 
"DECREMENT_ROLE"
,
 
"name"
:
 
"Decrement the counter"
,
 
"params"
:
 
[]
 
}
 
],
 
"environments"
:
 
{
 
"aragon:local"
:
 
{
 
"network"
:
 
"localhost"
,
 
"appName"
:
 
"foo.aragonpm.eth"
 
},
 
"aragon:rinkeby"
:
 
{
 
"apm"
:
 
{
 
"ipfs"
:
 
{
 
"gateway"
:
 
"https://ipfs.eth.aragon.network/ipfs"
 
}
 
},
 
"registry"
:
 
"0x98df287b6c145399aaa709692c8d308357bc085d"
,
 
"appName"
:
 
"foo.open.aragonpm.eth"
,
 
"wsRPC"
:
 
"wss://rinkeby.eth.aragon.network/ws"
,
 
"network"
:
 
"rinkeby"
 
},
 
"aragon:staging"
:
 
{
 
"apm"
:
 
{
 
"ipfs"
:
 
{
 
"gateway"
:
 
"https://ipfs.eth.aragon.network/ipfs"
 
}
 
},
 
"registry"
:
 
"0xfe03625ea880a8cba336f9b5ad6e15b0a3b5a939"
,
 
"appName"
:
 
"foo.open.aragonpm.eth"
,
 
"wsRPC"
:
 
"wss://rinkeby.eth.aragon.network/ws"
,
 
"network"
:
 
"rinkeby"
 
},
 
"aragon:mainnet"
:
 
{
 
"apm"
:
 
{
 
"ipfs"
:
 
{
 
"gateway"
:
 
"https://ipfs.eth.aragon.network/ipfs"
 
}
 
},
 
"registry"
:
 
"0x314159265dd8dbb310642f98f50c066173c1259b"
,
 
"appName"
:
 
"foo.aragonpm.eth"
,
 
"wsRPC"
:
 
"wss://mainnet.eth.aragon.network/ws"
,
 
"network"
:
 
"mainnet"
 
}
 
},
 
"path"
:
 
"contracts/CounterApp.sol"
,
 
"links"
:
 
[
 
{
 
"name"
:
 
"CounterExtension"
,
 
"address"
:
 
"0x82606d5d2dB55Ac1D36a011dbbA769c729349f56"
 
}
 
]
}
How to use environments
If you want to learn how use environments in practice check the guides to learn 
how to publish in diferent environments
.
The manifest.json file
The manifest.json defines end-user specific configurations:
name
: Human-readable name of your app.
author
: (optional) Author of the app.
description
: Small description of the app.
detail_url
: (optional) Path to markdown file with details of the app.
source_url
: (optional) Link to the source code of the app.
icons
: (optional) An array of all the icons that your app has. Each icon has the following properties:
src
: Path to the icon's image.
sizes
: Size of the icon.
screenshots
: (optional) An array of all the screenshots that your app has. Each screenshot has the following properties:
src
: Path to the screenshot's image.
script
: (optional) Background script path.
start_url
: Path to the starting URL.
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
IPFS commands
Next
aragonPM
Last modified 
7mo ago
Copy link
On this page
The arapp.json file
The manifest.json file









---PAGE 52---












Introduction - Aragon Developer Documentation




















Links
Introduction
aragonOS
 is a 
smart contract framework
 for building decentralized organizations, dapps, and protocols.
As you may have guessed, 
the OS in aragonOS stands for Operating System
. How so?
A computer operating system manages how applications access the underlying resources of the computer—the hardware.
aragonOS does the same for decentralized organizations or protocols. It abstracts away the management of how apps and external entities access the resources of the organization or protocol.
These resources can be things such as assets, cryptocurrencies, the rights to claim a premium on a loan, or the rights to upgrade a smart contract.
Its architecture is based on the idea of a decentralized organization or protocol being the aggregate of multiple components (called applications) connected by a pillar, called the 
Kernel
, which is all governed by a special 
Access Control List (ACL)
 application that controls how these applications and other entities can interact with each other.
aragonOS provides the following functionality:
Upgradability
: Smart contracts can be 
upgraded to a newer version
. Example: fixing a bug or adding a feature.
Permission control
: By using the 
auth()
 and 
authP()
 modifiers you can 
protect functionality
 such that they're only accessible by other apps or entities if given permission. This completely abstracts the authentication logic from an app, allowing you to focus on your app's business logic. Example: protecting a vault so only the organization's Voting app can initiate an action to transfer funds.
Forwarders
: aragonOS apps can communicate with each other by sending their intent to perform an action to other apps. Example: withdrawing funds from a vault only on the passing of a vote and the expiring of a time-lock.
All the above makes it very simple for aragonOS apps to incorporate 
governance
. You just need to add a voting app, configure permissions the right way, and away you go!
Useful reads:
​
✅
​
Your first Aragon app tutorial


✅
 
aragonOS reference


✅
 
aragonOS API


✅
 
Introducing aragonOS 3.0
​
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
aragonOS
Next
Motivations
Last modified 
5mo ago
Copy link









---PAGE 53---












Motivations - Aragon Developer Documentation




















Links
Motivations
Why we built aragonOS?
aragonOS was born on our path to developing modular and upgradeable smart contracts to power decentralized organizations.
As the project began maturing and we started abstracting more and more, we ended up encapsulating a lot of strong design decisions into a generic framework that could be used by any protocol or decentralized application wanting upgradeability.
Upgradeability
 is really important when developing high-stakes systems in platforms that are still evolving fast. Done well, it can allow for bug fixes and improvements with very little disruption while not causing problems at the protocol level. As a history lesson, if 
The DAO
 had had an effective upgradeability mechanism, no hard fork would have been required to fix the problem. As a community we could have avoided months of unproductive discussions, delays in the roadmap, and billions lost in the market capitalization of the protocol due to the fork's damage to network effects.
But upgradeability is a double-edged sword. It doesn't matter how secure or trustless a smart contract is, if it can be upgraded, the contract will effectively be whatever is decided by the party that can upgrade the contract. The guarantees of an upgradeable smart contract are only as strong as the 
governance mechanism
 that can upgrade it which makes governance the most important aspect of upgradeability.
In a similar way, you cannot have effective governance without a way for upgrading itself to a superior form of governance. Therefore we feel very strongly that 
upgradeability
 and 
governance
, in the context of smart contracts, are in reality 
two sides of the same coin
.
At Aragon, we are doing research in decentralized governance and the results of our research will all be made aragonOS-compatible. By using aragonOS, protocols can take advantage of our extensive research on governance, upgradeability, and every other aspect of the Aragon Network and Aragon client software.
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Introduction
Next
Developing with aragonOS
Last modified 
5mo ago
Copy link









---PAGE 54---












Developing with aragonOS - Aragon Developer Documentation
























Links
Developing with aragonOS
aragonOS enables 
apps to be upgradeable
 and 
share a generic governance interface
. To use it to its full potential, however, the following instructions need to be followed.
The AragonApp contract
Contracts using aragonOS have to inherit from the 
AragonApp
 contract. It makes the following functionality available.
The 
AragonApp
 contract manages two very important state variables in the app:
kernel
: A reference to the Kernel contract. The 
Kernel
 manages upgradeability and access control for the app.
appId
: An identifier for the app (the ENS name of the package repo of the app).
These variables are set by 
AppProxy
 on its constructor and should never be modified by the app as it could produce an unexpected state and leave the app unprotected or inaccessible.
import
 
"@aragon/os/contracts/apps/AragonApp.sol"
;
​
contract
 
MyApp
 
is
 AragonApp 
{
​
}
Upgradeability: bases and proxies
The 
DelegateProxy
 upgradeability pattern separates the contract implementation code or bases (the business logic) and the actual instances of the apps (thin proxies that use the base contract as their logic). The way upgradeability occurs is by changing the reference of the base contract in the proxy. Updating this reference effectively upgrades the logic that the proxy instances will execute when used.
In the case of aragonOS, the Kernel keeps the references for the versions of all of its installed apps. Using the 
kernel.newAppInstance(address appId, address base)
 function, an app is registered in the Kernel and a proxy for that app is created. At any point the base contract of the app can be upgraded using 
kernel.setApp(bytes32 namespace, bytes32 appId, address app)
.
Making an app available for use with upgradeable proxies requires deploying the contract to the network so its address can be used as a base. By default, if inheriting from 
AragonApp
, the base contract is disabled on deployment and cannot be used directly (only behind proxies). This is a security feature to avoid scenarios when a contract that proxies rely on can be destructed and all proxies are rendered useless.
Constructor and initialization
The constructor of a contract is executed when a contract is created. When using a proxy, however, the constructor code that is run is the proxy's constructor and not the one of the base contract. Because of this, aragonOS apps 
cannot use a constructor for initializing the contract
. An initialization function that can only be executed once is required to both be implemented and called before an app is usable.
AragonApp
 exposes the 
onlyInit
 modifier to protect a function from being called after 
initialized()
 has been completed and the 
auth()
, 
authP()
, and 
isInitialized
 modifiers to protect against a function from being called before the initialization is complete.
In the following example, if 
sendFunds()
 was called before initialization was complete, it would transfer the ETH sent with the call to 
address(0)
 since 
receiver
 wasn't set. By adding the 
isInitialized
 modifier, the function will fail until the contract has been initialized. It is a good practice to require all functions that modify state to be initialized before they can be used.
import
 
"@aragon/os/contracts/apps/AragonApp.sol"
;
​
contract
 
MyApp
 
is
 AragonApp 
{
 
address
 receiver
;
​
 
function
 
initialize
(
address
 _receiver
)
 
public
 onlyInit 
{
 
initialized
();
        receiver 
=
 _receiver
;
 
}
​
 
function
 
sendFunds
()
 
payable
 
external
 isInitialized 
{
        receiver
.
transfer
(
msg
.
value
);
 
}
}
It is important to note that, using this pattern, 
anyone can initialize a proxy
 after it has been deployed. The initialization of a proxy should occur in the same transaction that deploys the proxy to prevent initialization from being front-run by an adversary.
The 
AppProxy
 supports passing an initialization payload to its constructor. On creation, the proxy will perform a call with the provided initialization payload as the calldata to itself. This can be used to initialize the proxy in its constructor.
If using a 
DAO template
, the initialization of an app can be done right after the proxy is created.
Another important note is that if the app uses the 
ACL
 for access control, 
all access control checks will fail unless the app has been initialized
.
Global variables in apps
Because of our use of Proxies, child contracts won't initialize global variables when created. For example:
contract
 
MyFancyApp
 
is
 App 
{
 
uint
 initialState 
=
 
1
;
}
In the above example, when used behind a proxy, 
initialState
 will be 
0
, even though the expectation reading the code is that it will be 
1
.
The correct way to handle this situation is to make it something like:
contract
 
MyFancyApp
 
is
 App 
{
 
uint
 initialState
;
​
 
function
 
initialize
()
 onlyInit 
{
 initialState 
=
 
1
;
 
}
}
Roles and the Access Control List
aragonOS comes with a powerful 
Access Control List (ACL)
 that apps can leverage for protecting functionality behind permissions. Rather than coding any custom access control logic into your app, such as the infamous 
onlyOwner
, you can just protect functions by adding the 
auth()
 or 
authP()
 modifiers.
If the 
auth()
 modifier is present in a function it will check with the connected Kernel's ACL whether the entity performing the call is allowed to perform the action in the app prior to its execution.
Roles are identified by a 
bytes32
 value. This identifier can be a constant value so it doesn't take up any storage space. The standard name for a role identifier is the 
keccak256
 hash of its name as other tooling in the stack expects this to be the case. See this example:
import
 
"@aragon/os/contracts/apps/AragonApp.sol"
;
​
contract
 
MyApp
 
is
 AragonApp 
{
 
bytes32
 
public
 
constant
 SET_RECEIVER_ROLE 
=
 
keccak256
(
"SET_RECEIVER_ROLE"
);
​
 
address
 
public
 receiver
;
​
 
function
 
initialize
(
address
 _receiver
)
 
public
 onlyInit 
{
 
initialized
();
        receiver 
=
 _receiver
;
 
}
​
 
function
 
setReceiver
(
address
 _newReceiver
)
 
external
 
auth
(
SET_RECEIVER_ROLE
)
 
{
        receiver 
=
 _newReceiver
;
 
}
​
 
function
 
sendFunds
()
 
external
 
payable
 isInitialized 
{
        receiver
.
transfer
(
msg
.
value
);
 
}
}
An important note is that the 
auth()
 and 
authP()
 modifiers will also check whether the app is 
initialized
. If the 
app hasn't been initialized, the authentication check will fail
.
When adding a role to your app you will also need to add it to the 
arapp.json
 file with a description of the functionality protected by the role. You can check Aragon's 
Voting app arapp.json
 and below for an example of role descriptions:
{
 
"roles"
:
 
[
 
{
 
"name"
:
 
"Set the receiver of funds"
,
 
"id"
:
 
"SET_RECEIVER_ROLE"
,
 
"params"
:
 
[]
 
}
 
]
}
Forwarding and EVMScripts
aragonOS introduces the concept of 
forwarding
, which is a generic interface for apps to send an intent to other apps if some conditions are met. For example, a Voting app can be a forwarder that only forwards the intent if a vote passes. Another example is a Payroll app that only forwards the intents of an organization's employees.
Forwarders are passed an EVMScript that can be executed by the app. The script executed is always an array of calls that will be performed one after the other.
In order for an app to be a forwarder, it needs to implement these 3 functions in the 
IForwarder
 interface:
import
 
"@aragon/os/contracts/apps/AragonApp.sol"
;
import
 
"@aragon/os/contracts/common/IForwarder.sol"
;
​
contract
 
MyApp
 
is
 IForwarder
,
 AragonApp 
{
 
address
 receiver
;
​
 
function
 
initialize
(
address
 _receiver
)
 onlyInit 
public
 
{
 
initialized
();
        receiver 
=
 _receiver
;
 
}
​
 
function
 
isForwarder
()
 
public
 
pure
 
returns
 
(
bool
)
 
{
 
return
 
true
;
 
}
​
 
function
 
canForward
(
address
 _sender
,
 
bytes
 _evmCallScript
)
 
public
 
view
 
returns
 
(
bool
)
 
{
 
// Arbitrary logic for deciding whether to forward a given intent
 
return
 _sender 
==
 receiver
;
 
}
​
 
function
 
forward
(
bytes
 _evmScript
)
 
public
 
{
 
require
(
canForward
(
msg
.
sender
,
 _evmScript
));
​
 
// Input is unused at the moment
 
bytes
 
memory
 input 
=
 
new
 
bytes
(
0
);
​
 
// An array of addresses that cannot be called from the script
 
address
[]
 
memory
 blacklist 
=
 
new
 
address
[](
0
);
​
 
// Either immediately run the script or save it for later execution
 
runScript
(
_evmScript
,
 input
,
 blacklist
);
 
// actually executes script
 
}
}
In the example above, the app will always forward an intent if the sender happens to be the 
receiver
 in the contract.
Note that a script is only able to perform calls to addresses or contracts that are not in the address blacklist.
Fund recovery
If an app 
is
 intended to hold funds, this recovery functionality can be disabled or customized to only tokens that can be recovered:
import
 
"@aragon/os/contracts/apps/AragonApp.sol"
;
​
contract
 
MyApp
 
is
 AragonApp 
{
 
address
 receiver
;
​
 
function
 
initialize
(
address
 _receiver
)
 onlyInit 
public
 
{
 
initialized
();
        receiver 
=
 _receiver
;
 
}
​
 
function
 
allowRecoverability
(
address
 token
)
 
public
 
view
 
returns
 
(
bool
)
 
{
 
return
 token 
!=
 ETH
;
 
// turns off fund recovery for ETH
 
}
}
Recommendations
Conventions
Representing ETH as a token
If a function has a token parameter, but you would like to handle ETH as well as other token addresses in the same parameter, use 
address(0)
 as the address of ETH. aragonOS includes 
EtherTokenConstant
 to define 
ETH = address(0)
.
Representing time
As it is unlikely we'll ever need to worry about 
uint256
-precision for UNIX timestamps (in seconds) or blocks (in ~15s intervals), we generally cast these values down to 
uint64
s so we can pack them to save gas. aragonOS provides 
TimeHelpers
 and 
Uint256Helpers
 as utility contracts for obtaining these values safely.
Safety conveniences
As of 
@aragon/
[email protected]
, 
SafeERC20
 is available as a generic library to smooth out ERC20 token interactions. In particular, it adds the ability to transparently handle 
tokens that don't return properly
 as well as adding 
staticcall
 variants for common read-only interfaces in tokens.
As of 
@aragon/
[email protected]
, a 
ReentrancyGuard
 has been built into 
AragonApp
 to prevent exposed app functionality from facing re-entrancy problems. See 
the aragonOS reference documentation f
or more information on making use of it.
UNIX philosophy
The design philosophy we use when developing Aragon apps is very similar to the UNIX philosophy. We try to architect apps to do one thing and one thing well and to respect and implement the few aragonOS interfaces so that they play nicely with the rest of the ecosystem.
This results in purely technical benefits such as testability, but it also becomes very powerful when apps are combined and the output of one app becomes the input of an other one. You can think of forwarders resembling UNIX pipes in their philosophy.
Permissioning
We also recommend that all state-changing functionality in an application should be protected by a role and that each separate action should have its own role. This allows one to create granular permissioning schemes and makes securing an application easier.
Examples
We officially build and maintain a number of Aragon apps ourselves, that implement the basic functionalities to manage organizations. These apps are released alongside every Aragon release and are a good reference of how to build Aragon apps. You can view their code in the 
aragon/aragon-apps
 repo.


Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Motivations
Next
Reference documentation
Last modified 
7mo ago
Copy link
On this page
The AragonApp contract
Upgradeability: bases and proxies
Constructor and initialization
Roles and the Access Control List
Forwarding and EVMScripts
Fund recovery
Recommendations
Conventions
Safety conveniences
UNIX philosophy
Permissioning
Examples









---PAGE 55---












Reference documentation - Aragon Developer Documentation






















Links
Reference documentation
Documentation for 
aragonOS v4.0.1.
This section provides a technical 
overview of the framework's architecture
 and provides insight into its capabilities. It assumes the reader understands 
Solidity
. For a less technical introduction, visit the
 introduction
.
Looking for 
aragonOS 3 documentation
? Go 
here
.
Design philosophy
Using aragonOS allows you to write simpler code by 
decoupling
 the specific 
business logic
 of a protocol or application from its 
authentication logic
.
With aragonOS, you don't have to think about how to implement authentication or governance at all. Simply inherit from the 
AragonApp
 base class and use a special modifier to mark actions that require authentication.
Additionally, 
upgradeability
 capabilities are provided and are used by default. aragonOS implements the 
DelegateProxy
 pattern with a special implementation called 
unstructured storage
. This pattern essentially splits a contract into two instances: a 
base logic contract
, which is then depended upon by a simple, slim 
proxy contract
. The proxy delegates all its logic to the linked base contract and can modify its pointer to the base contract in order to upgrade its logic.
Components:
​
Kernel
​
​
ACL
​
​
AragonApp
​
​
Forwarders and EVMScripts
​
Kernel
The app mapping
At the core of the Kernel lives a mapping called the 
app
 mapping. You can set and get apps using the following interfaces:
function
 
setApp
(
bytes32
 namespace
,
 
bytes
 appId
,
 
address
 app
)
 
public
;
function
 
getApp
(
bytes32
 namespace
,
 
bytes32
 appId
)
 
public
 
view
 
returns
 
(
address
);
namespace:
 specifies what type of app record is being set.
appId:
 used to identify what app is being set. It is the 
ENS 
namehash
 of the aragonPM repo (e.g. 
namehash('voting.aragonpm.eth')
).
app:
 Address of a contract that can have a different meaning depending on the 
namespace
.
Warning
Modifying this mapping can have completely destructive consequences and can result in loss of funds. The permission to execute this action, 
APP_MANAGER_ROLE
, is 
critical
 and has to be well protected behind the ACL.
Namespaces
The Kernel implements three namespaces in which installed apps can be registered:
Core namespace
 (
keccak256('core')
): the core components of the Kernel. The only contract set in the core mapping should be the reference to the Kernel's base contract.
Base namespace
 (
keccak256('base')
): the base contract addresses for proxy instances.
App namespace
 (
keccak256('app')
): the "default" app address for an installed app. This is used when an app might need to reference another app in the organization, for example, the default ACL instance or the EVMScriptsRegistry.
App installation
The notion of "installing" an application in aragonOS is somewhat tricky. Although the Kernel keeps information about apps and their bases, it does not actually keep every app instance stored within its 
apps
 mapping.
As such, we attribute the "installation" of an app instance to the creation of its first permission in the 
ACL
. If an app has no permissions set, it is technically impossible to use, if developed correctly, and is not considered installed.
While aragonOS is unopinionated about using base or proxy contracts as app instances, by default it prefers using proxies to allow for upgradeability.
You can create new 
app proxy
 instances through the following interfaces:
function
 
newAppInstance
(
bytes32
 appId
,
 
address
 appBase
);
function
 
newPinnedAppInstance
(
bytes32
 appId
,
 
address
 appBase
);
appId:
 used to identify what app to link the proxy to. It is the 
ENS 
namehash
 of the aragonPM repo (e.g. 
namehash('voting.aragonpm.eth')
).
app:
 Address of the base contract for the app instance. If this app has already been installed previously, this address 
must
 be the same as the one currently set (use 
getApp(kernel.APP_BASES_NAMESPACE(), appId)
 to check).
Overloaded versions of the two functions with more options are available:
function
 
newAppInstance
(
bytes32
 appId
,
 
address
 appBase
,
 
bytes
 initializePayload
,
 
bool
 setDefault
);
function
 
newPinnedAppInstance
(
bytes32
 appId
,
 
address
 appBase
,
 
bytes
 initializePayload
,
 
bool
 setDefault
);
initializePayload
: calldata to be used to immediately initialize the app proxy, useful for atomically initializing the new app proxy in one transaction.
setDefault
: set the new app as the default instance of the app in the Kernel (i.e. also set it in the 
App
 namespace).
App permissioning
For convenience, the Kernel exposes the following interfaces for getting the default ACL as well as whether an entity has permission to invoke a particular action on an app:
function
 
acl
()
 
public
 
view
 
returns
 
(
IACL
);
function
 
hasPermission
(
address
 who
,
 
address
 where
,
 
bytes32
 what
,
 
bytes
 how
)
 
public
 
view
 
returns
 
(
bool
);
Upgradeability
Upgradeability of apps and the Kernel itself is done by setting a new address for a specific key in the 
apps
 mapping with either the 
Core
 or 
Base
 namespace.
Kernel upgradeability
Kernel instances for different organizations can share the same implementation. Every Kernel instance is a KernelProxy, allowing them to be upgradeable.
Warning
Be 
extremely
 careful when upgrading the Kernel! The logic for upgrading to a new implementation is in the implementation itself, and so an upgrade to the Kernel could render it un-upgradeable or even unusable!
Upgrading the Kernel of an organization is done by changing the 
Kernel appId
 in the 
Core
 namespace:
kernel
.
setApp
(
kernel
.
CORE_NAMESPACE
(),
 kernel
.
KERNEL_APP_ID
(),
 newKernelBaseAddr
);
AppProxies and upgradeability
In a similar fashion to the Kernel, apps can share implementation code to save gas on deployment. AppProxies rely on the Kernel for their upgradeability. Note that separate app instances in an organization are all linked to the same base contract in the Kernel, and so upgrading the base contract would effectively upgrade all of that app's instances.
Upgrading an app is done by setting a new base address for 
that app's appId
 in the 
Base
 namespace:
kernel
.
setApp
(
kernel
.
APP_BASES_NAMESPACE
(),
 votingAppId
,
 newVotingAppBaseAddr
);
aragonOS provides two different types of proxies for apps:
AppProxyUpgradeable
: an upgradeable proxy. In every call to the proxy it retrieves the current base contract address from the Kernel and forwards the call.
AppProxyPinned
: a non-upgradeable proxy. On creation, it checks and saves the base contract address in the Kernel. This cannot be upgraded unless the base contract has explicit logic to change that storage slot.
Permissions
APP_MANAGER_ROLE
 is required any time the 
apps
 mapping is modified.
Warning
APP_MANAGER_ROLE
 can be used in malicious and dangerous ways. 
Protect this permission.
Events
SetApp
 is fired any time the 
app
 mapping changes:
SetPermission
(
address
 
indexed
 
from
,
 
address
 
indexed
 to
,
 
bytes32
 
indexed
 role
,
 
bool
 allowed
);
Interface
The Kernel implements the following interface:
interface
 
IVaultRecoverable
 
{
 
function
 
transferToVault
(
address
 token
)
 
external
;
​
 
function
 
allowRecoverability
(
address
 token
)
 
external
 
view
 
returns
 
(
bool
);
 
function
 
getRecoveryVault
()
 
external
 
view
 
returns
 
(
address
);
}
​
contract
 
IKernel
 
is
 IVaultRecoverable 
{
 
event
 
SetApp
(
bytes32
 
indexed
 namespace
,
 
bytes32
 
indexed
 appId
,
 
address
 app
);
​
 
function
 
acl
()
 
public
 
view
 
returns
 
(
IACL
);
 
function
 
hasPermission
(
address
 who
,
 
address
 where
,
 
bytes32
 what
,
 
bytes
 how
)
 
public
 
view
 
returns
 
(
bool
);
​
 
function
 
setApp
(
bytes32
 namespace
,
 
bytes32
 appId
,
 
address
 app
)
 
public
;
 
function
 
getApp
(
bytes32
 namespace
,
 
bytes32
 appId
)
 
public
 
view
 
returns
 
(
address
);
}
API documentation
See 
Kernel.
​
ACL
A 
Permission
 is defined as the ability to perform actions (grouped by 
Roles
) in a certain app instance (identified by its address).
We refer to a 
permission instance
 as an entity holding a certain permission. If it helps, you can think of a permission as a 
manifestation
 of an app's role that is held by an entity.
The ACL is built entirely as an AragonApp and can be upgraded in the same way as any other application installed into a Kernel. Unlike other apps, however, the ACL is installed and initialized upon the Kernel's own initialization due to its importance.
Managing permissions
First of all, you can obtain the default ACL instance for a Kernel with:
ACL acl 
=
 
ACL
(
kernel
.
acl
());
Then you can execute the following actions:
Create Permission
acl
.
createPermission
(
address
 entity
,
 
address
 app
,
 
bytes32
 role
,
 
address
 manager
);
entity
: entity to hold the permission.
app
: app whose role will be allowed through the permission
role
: role to allow
manager
: manager of the role's permission instances
Warning
createPermission()
 will fail if that role has pre-existing permission instances or a permission manager set.
Grants 
role
 in 
app
 for an 
entity
 and set 
manager
 as the manager of the role's permission instances.
This action is identical to 
grantPermission()
 except it allows the creation of the first permission instance of a role.
Note
Creating permissions is mandatory for apps to work. Any permission checks on non-existent permissions are failed automatically.
Grant Permission
acl
.
grantPermission
(
address
 entity
,
 
address
 app
,
 
bytes32
 role
);
Warning
Only callable by the 
manager
 of the role's permission instances.
Grants 
role
 in 
app
 for an 
entity
. This 
entity
 would then be allowed to call all actions that their 
role
 can perform on that particular 
app
 until the permission manager revokes their role with 
revokePermission()
.
This action is identical to 
createPermission()
 except it can only be used by the permission manager of the role and does not set a new manager.
Note
The 
grantPermission()
 action doesn’t require protection with the ACL because only the permission manager of the role can make changes.
Revoke Permission
acl
.
revokePermission
(
address
 entity
,
 
address
 app
,
 
bytes32
 role
);
Warning
Only callable by the 
manager
 of the role's permission instances.
Revokes 
role
 in 
app
 for an 
entity
.
Note
The 
revokePermission()
 action doesn’t require protection with the ACL because only the permission manager of the role can make changes.
Basic ACL example
As an example, the following steps show a complete flow for user "Root" to create a new DAO with the basic permissions set so that a 
Voting app
 can manage the funds stored in a 
Vault app
:
1.
Deploy the Kernel and the ACL
2.
Executing 
kernel.initialize(acl, rootAddress)
, which in turns calls 
acl.initialize(rootAddress)
, creates the "permissions creator" permission under the hood 
createPermission(rootAddress, aclAddress, CREATE_PERMISSIONS_ROLE, rootAddress)
3.
Deploy the Voting app
4.
Grant the Voting app the ability to call 
createPermission()
: 
grantPermission(votingAppAddress, aclAddress, CREATE_PERMISSIONS_ROLE)
 (must be executed by 
rootAddress
)
5.
Deploy the Vault app, which has an action called 
transfer()
6.
Create a new vote via the Voting app to create the 
TRANSFER_ROLE
 permission: 
createPermission(votingAppAddress, vaultAppAddress, TRANSFER_ROLE, votingAppAddress)
7.
If the vote passes, the Voting app now has access to all actions in the Vault protected by 
TRANSFER_ROLE
, which in this case is just 
transfer()
8.
Fund transfers from the Vault can now be controlled via votes from the Voting app. Each time a user wishes to transfer funds, they can create a new vote via the Voting app to propose an execution of the Vault's 
transfer()
 action. The 
transfer()
 action will be executed if and only if the vote passes.
Note that the Voting app is also able to revoke or regrant the 
TRANSFER_ROLE
 permission as it is that permission's manager of 
TRANSFER_ROLE
 on 
vaultAppAddress
.
Permission managers
As we have seen in the 
Basic ACL example,
 when a permission is created a 
Permission Manager
 is set for that specific role. The permission manager is able to grant or revoke permission instances for that role.
Getting a role's permission manager
acl
.
getPermissionManager
(
address
 app
,
 
bytes32
 role
)
Change a permission manager
acl
.
setPermissionManager
(
address
 newManager
,
 
address
 app
,
 
bytes32
 role
);
Only callable by the 
manager
 of the role's permission instances.
Changes the permission manager to 
newManager
.
The new permission manager replaces the old permission manager resulting in the old manager losing any management power over that permission.
createPermission()
 executes a special case of this action to set the initial manager for the newly created permission. From that point forward, the manager can only be changed with 
setPermissionManager()
.
Parameter interpretation
When a permission is granted to an entity by the permission manager it can be assigned an array of parameters that will be evaluated every time the ACL is checked to see if the entity can perform the action.
Parameters allow the ACL to perform certain computations with the arguments of a permission in order to decide whether to allow the action or not. This moves the ACL from being a purely binary access list to a more sophisticated system that allows for fine-grained control.
An ACL parameter is comprised of a data structure with 3 values:
Argument Value
 (
uint240
): the value to compare against, depending on the argument. It is a regular Ethereum memory word that loses its two most significant bytes of precision. The reason for this was to allow parameters to be saved in just one storage slot, saving significant gas. Even though 
uint240
s are used, it can be used to store any integer up to 
2^30 - 1
, addresses, and bytes32. In the case of comparing hashes, losing 2 bytes of precision shouldn't be a dealbreaker if the hash algorithm is secure.
Argument ID
 (
uint8
): Determines how the comparison value is fetched. From 0 to 200 it refers to the argument index number passed to the role. After 200, there are some special 
Argument IDs
:
BLOCK_NUMBER_PARAM_ID
 (
id = 200
): sets comparison value to the block number at the time of execution. This allows for setting up timelocks depending on blocks.
TIMESTAMP_PARAM_ID
 (
id = 201
): sets comparison value to the timestamp of the current block at the time of execution. This allows for setting up timelocks on time.
id = 202
: not currently in use.
ORACLE_PARAM_ID
 (
id = 203
): checks with an oracle at the address in the 
argument value
 and returns whether it returned true or false (no comparison with the 
argument value
).
LOGIC_OP_PARAM_ID
 (
id = 204
): evaluates a logical operation and returns true or false depending on its result (no comparison with the 
argument value
).
PARAM_VALUE_PARAM_ID
 (
id = 205
): return 
argument value
. Commonly used with the 
RET
 operation to just return a value. If the value in the param is greater than 0 it will evaluate to true, otherwise it will return false.
Operation type
 (
uint8
): what operation should be done to compare the value fetched using the argument ID or the argument value. For all comparisons, both values are compared in the following order 
args[param.id] <param.op> param.value
. Therefore, for a greater than operation, with 
param = {id: 0, op: Op.GT, value: 10}
, it will interpret whether the argument 0 is greater than 10. The implemented operation types are:
None (
Op.NONE
): always evaluates to 
false
 regardless of parameter or arguments.
Equals (
Op.EQ
): evaluates to true if every byte matches between 
args[param.id]
 and 
param.value
.
Not equals (
Op.NEQ
): evaluates to true if any byte doesn't match.
Greater than (
Op.GT
): evaluates to true if 
args[param.id] > param.value
.
Less than (
Op.LT
): evaluates to true if 
args[param.id] < param.value
.
Greater than or equal (
Op.GTE
): evaluates to true if 
args[param.id] >= param.value
.
Less than or equal (
Op.LTE
): evaluates to true if 
args[param.id] <= param.value
.
Return (
Op.RET
): evaluates to true if 
args[param.id]
 is greater than one. Used with 
PARAM_VALUE_PARAM_ID
, it makes 
args[param.id] = param.value
, so it returns the associated value of the parameter.
While also representing an operation, when the argument ID is 
LOGIC_OP_PARAM_ID
 only the 
Op
s below are valid. These operations use the parameter's value to point to other parameter indices in the parameter array. Any values are encoded as 
uint32
 numbers, each left-shifted 32 bits (for example, an 
Op
 that takes two inputs with a value of 
0x00....0000000200000001
 would have input 1, 1, and input 2, 2, referring to params at index 1 and 2). Here are the available logic 
Op
s:
Not (
Op.NOT
): takes 1 parameter index and evaluates to the opposite of what the linked parameter evaluates to.
And (
Op.AND
): takes 2 parameter indices and evaluates to true if both evaluate to true.
Or (
Op.OR
): takes 2 parameter indices and evaluates to true if either evaluate to true.
Exclusive or (
Op.XOR
): takes 2 parameter indices and evaluates to true if only one of the parameters evaluate to true.
If else (
Op.IF_ELSE
): takes 3 parameters, evaluates the first parameter and if true, evaluates as the second parameter's evaluation, or as the third parameter's evaluation if false.
Parameter execution
When evaluating a rule the ACL will always evaluate the result of the first parameter. This first parameter can be an operation that links to other parameters and its evaluation depends on those parameters' evaluation. Execution is recursive and the result evaluated is always the result of the evaluation of the first parameter.
Examples of rules
The interpreter supports encoding complex rules in what would look almost like a programming language. For example, let’s look at the following 
test case
:
function
 
testComplexCombination
()
 
{
 
// if (oracle and block number > block number - 1) then arg 0 < 10 or oracle else false
    Param
[]
 
memory
 params 
=
 
new
 
Param
[](
7
);
    params
[
0
]
 
=
 
Param
(
LOGIC_OP_PARAM_ID
,
 
uint8
(
Op
.
IF_ELSE
),
 
encodeIfElse
(
1
,
 
4
,
 
6
));
    params
[
1
]
 
=
 
Param
(
LOGIC_OP_PARAM_ID
,
 
uint8
(
Op
.
AND
),
 
encodeOperator
(
2
,
 
3
));
    params
[
2
]
 
=
 
Param
(
ORACLE_PARAM_ID
,
 
uint8
(
Op
.
EQ
),
 
uint240
(
new
 
AcceptOracle
()));
    params
[
3
]
 
=
 
Param
(
BLOCK_NUMBER_PARAM_ID
,
 
uint8
(
Op
.
GT
),
 
uint240
(
block
.
number 
-
 
1
));
    params
[
4
]
 
=
 
Param
(
LOGIC_OP_PARAM_ID
,
 
uint8
(
Op
.
OR
),
 
encodeOperator
(
5
,
 
2
));
    params
[
5
]
 
=
 
Param
(
0
,
 
uint8
(
Op
.
LT
),
 
uint240
(
10
));
    params
[
6
]
 
=
 
Param
(
PARAM_VALUE_PARAM_ID
,
 
uint8
(
Op
.
RET
),
 
0
);
​
 
assertEval
(
params
,
 
arr
(
uint256
(
10
)),
 
true
);
​
    params
[
4
]
 
=
 
Param
(
LOGIC_OP_PARAM_ID
,
 
uint8
(
Op
.
AND
),
 
encodeOperator
(
5
,
 
2
));
 
assertEval
(
params
,
 
arr
(
uint256
(
10
)),
 
false
);
}
When assigned to a permission, this rule will 
evaluate to true
 (and therefore allow the action) only on the following conditions:
If an oracle accepts it, and
The block number is greater than the previous block number, and
Either the oracle allows it (again! testing redundancy too) or the first parameter of the rule is lower than 10.
The possibilities for customizing an organization or protocol's governance model are truly endless and there is no need to write any actual Solidity.
Permissions
CREATE_PERMISSION_ROLE
 protects 
createPermission()
.
Warning
CREATE_PERMISSION_ROLE
 could be used in malicious and dangerous ways. This is initially assigned when the Kernel is first initialized. 
Protect this permission.
Events
createPermission()
, 
grantPermission()
, and 
revokePermission()
 all fire the same 
SetPermission
 event that Aragon clients are expected to cache and process into a locally stored version of the ACL:
SetPermission
(
address
 
indexed
 
from
,
 
address
 
indexed
 to
,
 
bytes32
 
indexed
 role
,
 
bool
 allowed
);
​
setPermissionManager()
 fires the following event:
ChangePermissionManager
(
address
 
indexed
 app
,
 
bytes32
 
indexed
 role
,
 
address
 
indexed
 manager
)
API documentation
See 
ACL
.
AragonApp
AragonApp is the base class for all aragonOS applications. It exposes a light layer of functionality to supplement an application's business logic and sets up the required storage to connect to a Kernel.
Note
We have outlined a number of recommended conventions to follow in the 
aragonOS development guide
.
Security recommendations and sane defaults
While it is ultimately up to you to understand the concepts and sufficiently protect your business logic from flaws, AragonApp attempts to provide sane and secure defaults out of the box so you don't have to worry about potential security breaches from misconfiguration.
Applications inheriting from AragonApp are required to be initialized, connected to a Kernel, and used with an 
AppProxy
. By default, they are not meant to receive or hold funds and allow all tokens to be recovered through the fund recovery mechanism in case of an accidental token transfer.
To secure an application, it is critical to ensure that all externally-accessible, state-changing functionality is protected by 
authentication
. If the application is meant to receive, hold, or transfer funds, you will also have to carefully reason about the 
fund recovery and depositable capabilities
 and how they affect your application (alongside the 
standard Ethereum security recommendations
 of course!) If the app is a 
forwarder or uses EVMScripts
 you should also carefully understand the implications of allowing another application or entity to execute an action from your application's address.
Authentication
Adding roles
Declaring roles is simple and usually done as public 
bytes32
 declarations at the start of the contract file. By convention, the standard name for a role identifier is the 
keccak256
 hash of its name as other tooling in the stack expects this to be the case:
bytes32
 
public
 CUSTOM_ACTION_ROLE 
=
 
keccak256
(
"CUSTOM_ACTION_ROLE"
);
Protecting functionality
Protecting an action behind the ACL is done in the smart contract by simply adding the authentication modifiers 
auth()
 or 
authP()
 to the action. On executing the action, the 
auth()
 or 
authP()
 modifier checks with the Kernel whether the entity performing the call holds the required role or not.
auth(bytes32 role)
 is capable of defining a 
binary
 permission—either yes or no:
function
 
customAction
()
 
auth
(
CUSTOM_ACTION_ROLE
)
 
{
}
authP(bytes32 role, uint256[] params)
 allows you to pass a number of parameters that can then be used in the 
ACL's parameterization
 for each permission. This allows you to define powerful permissions with highly granular controls based on the inputs of an action:
bytes32
 
public
 TRANSFER_ROLE 
=
 
keccak256
(
"TRANSFER_ROLE"
);
function
 
transfer
(
uint256
 amount
)
 
authP
(
TRANSFER_ROLE
,
 
arr
(
amount
))
 
{
}
authP()
's second argument is a 
uint256[]
, but aragonOS exposes a number of 
arr()
 syntactical sugar helpers by default from AragonApp to help construct this array when using different argument types.
Note
Both 
auth()
 and 
authP()
 check that the application instance is initialized before allowing the action. Trying to access a protected action in an uninitialized application will result in a revert.
Finally, AragonApp also exposes a public getter for checking if an entity can perform a certain action:
function
 
canPerform
(
address
 sender
,
 
bytes32
 role
,
 
uint256
[]
 params
)
 
public
 
view
 
returns
 
(
bool
);
Note
Apps have the choice of which actions to protect behind the ACL as some actions may make sense to be completely public. Any publicly exposed state-changing function should 
most likely
 be protected, however.
Lifecycle of an AragonApp call requiring the ACL 
Application lifecycle guarantees
The 
DelegateProxy
 pattern suffers from a particular weakness of the proxy contracts depending upon the survival of the base logic contracts. It is important to understand the lifecycles of these base and proxy contracts to ensure users' safety and to avoid incidents like the unfortunate 
second Parity multisig wallet vulnerability
.
AragonApps can be in the lifecycle stages of 
uninitialized
, 
initialized
, or 
petrified
. As an application contract is deployed it begins in the 
uninitialized
 state and can go to either the 
initialized
 or 
petrified
 state. 
AragonApp base logic contracts are 
petrified
 upon their deployment. They can never be initialized and are considered frozen in an uninitialized state forever. This also means that, if properly developed, there is no way for these contracts to be 
selfdestruct
ed.
The AppProxy contracts users deploy and link to the base logic contracts are expected to be 
initialized
 by their users and only made usable once this initialization is complete.
You can check for an application instance's lifecycle state using the following:
function
 
hasInitialized
()
 
public
 
view
 
returns
 
(
bool
);
function
 
isPetrified
()
 
public
 
view
 
returns
 
(
bool
);
Application capabilities
Fund recovery
By default, all AragonApps have a fund recovery mechanism enabled for all tokens and ETH to protect against the event of an accidental transfer of funds. This is partly motivated by a flaw in the ERC20 specification that does not allow contracts to prevent themselves from receiving tokens like they can with ETH.
All AragonApps expose an externally-accessible fund recovery mechanism:
function
 
transferToVault
(
address
 token
)
 
external
;
This capability is configurable through the overloadable hook:
function
 
allowRecoverability
(
address
 token
)
 
public
 
view
 
returns
 
(
bool
);
The default implementation of 
allowRecoverability()
 is just to return true for all tokens but your overload could choose to not allow certain tokens or even ETH.
Depositable proxies
AppProxies start off not being able to receive ETH through the native, gas-limited 
.send()
 and 
.transfer()
 methods. This can be explicitly enabled through the 
setDepositable()
 function when an app wants to allow itself (as the proxy instance) to receive ETH from other contracts:
function
 
setDepositable
(
bool
 depositable
)
 
internal
;
An example use case would be a fundraising application which would only enable its proxy instances to be capable of receiving ETH for the duration of a fundraiser.
EVMScripts
AragonApp exposes the following interface for running EVMScripts:
function
 
runScript
(
bytes
 script
,
 
bytes
 input
,
 
address
[]
 blacklist
)
 
internal
 isInitialized protectState 
returns
 
(
bytes
);
And some getters for information about EVMScripts:
function
 
getEVMScriptExecutor
(
bytes
 script
)
 
public
 
view
 
returns
 
(
IEVMScriptExecutor
);
function
 
getEVMScriptRegistry
()
 
public
 
view
 
returns
 
(
IEVMScriptRegistry
);
For more information on the use cases for EVMScripts, see the following 
Forwarders and EVMScripts 
section.
Re-entrancy protection
AragonApp comes with a built-in re-entrancy guard, easily usable through the 
nonReentrant
 modifier:
function
 
nonReentrantFunction
()
 
external
 nonReentrant 
{
}
It's use is recommended as a last resort, for cases where there are no better options for protecting against re-entrancy.
Most commonly, you may want to apply this modifier to functions that fulfil these requirements:
Externally available and is state changing
Invokable by non-trusted contracts or accounts
Not already protected by a role
There exist more than one of these functions
A contrived example of this is if your app allows creating a recurring token payment to another account (protected via a role), but only the recipient account can modify certain parameters (e.g. when to withdraw payments, what token to withdraw). If the withdraw and token selection functions are separately available, they may benefit from being 
nonReentrant
API documentation
See 
AragonApp
.
​
Forwarders and EVMScripts
Forwarders are one of the most important concepts of aragonOS. Rather than hardcoding the notion of a vote into each separate app’s functionality and ACL one can instead use a generic Voting App, which implements the forwarding interface, to pass actions 
forward
 to other apps after successful votes. If the Voting App is set up to only allow a token’s holders to vote, that means any actions/calls being passed from it must have also been approved by the token’s holders.
Forwarding and transaction pathing
The forwarding interface also allows a frontend interface, like the Aragon client, to calculate "forwarding paths". If you wanted to perform an action but you don't have the required permissions, a client can think of alternative paths for execution. For example, you might be in the Vault app's interface wishing to perform a token transfer. If you only had the permission to create votes, the client would directly prompt you to create a vote rather than let you complete the transfer. The flow is illustrated in the following animation:
Vote forwarding scenario. (Please note that the governance model and characters are fictional.)
 👇
EVMScripts
We have designed our own scripting format, known as EVMScripts, to encode complex actions into a bytes representation that can be stored and later executed by another entity. EVMScripts can be installed on a per-organization basis through a 
EVMScriptRegistry
 and aragonOS comes complete with the ability to install multiple script executors in an organization.
EVMScript executors
 are contracts that take a script and an input and return an output after execution.
EVMScript executors must implement the following interface:
interface
 
IEVMScriptExecutor
 
{
 
function
 
execScript
(
bytes
 script
,
 
bytes
 input
,
 
address
[]
 blacklist
)
 
external
 
returns
 
(
bytes
);
 
function
 
executorType
()
 
external
 
pure
 
returns
 
(
bytes32
);
}
Warning
EVMScript executors are called with a 
delegatecall
 and operate in the context of the calling app. This 
must
 be taken into consideration when developing your own executor as it could cause a security breach.
aragonOS provides the 
CallsScript
 executor as a simple way to concatenate multiple calls. It cancels the operation if any of the calls fail.
Script body:
 See 
CallsScript
 source code 
for spec of the payload.
Input:
 None
Output:
 None.
Blacklist:
 Entire script reverts if a call to one of the addresses in the blacklist is performed.
Making an app a Forwarder
Apps can become Forwarders by simply implementing the following interface:
interface
 
IForwarder
 
{
 
function
 
isForwarder
()
 
external
 
pure
 
returns
 
(
bool
);
 
function
 
canForward
(
address
 sender
,
 
bytes
 evmCallScript
)
 
public
 
view
 
returns
 
(
bool
);
 
function
 
forward
(
bytes
 evmCallScript
)
 
public
;
}
Examples of forwarders can be found in the 
aragon-apps repo
. Both the 
Voting
 and 
Token Manager
 apps are forwarders.
Warning
EVMScripts are very powerful and risk causing security breaches! For example, the Token Manager, which allows any token holder to forward actions, needs to have the token address in its blacklist as otherwise any token holder would effectively have control over the token in the same way that the Token Manager does!
API documentation
See 
IForwarder
 and 
EVMScriptRunner
.
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Developing with aragonOS
Next
Migrating to aragonOS 4 from aragonOS 3
Last modified 
5mo ago
Copy link
On this page
Design philosophy
Components:
Kernel
The app mapping
Namespaces
App installation
App permissioning
Upgradeability
Permissions
Events
Interface
API documentation
ACL
Managing permissions
Basic ACL example
Permission managers
Parameter interpretation
Permissions
Events
API documentation
AragonApp
Security recommendations and sane defaults
Authentication
Application lifecycle guarantees
Application capabilities
API documentation
Forwarders and EVMScripts
Forwarding and transaction pathing
EVMScripts
Making an app a Forwarder
API documentation









---PAGE 56---












Migrating to aragonOS 4 from aragonOS 3 - Aragon Developer Documentation






















Links
Migrating to aragonOS 4 from aragonOS 3
aragonOS 4 was designed to be as familiar as possible to users of aragonOS 3. In some cases, an Aragon app might not even have to be changed when upgrading.
For a more in-depth technical explanation of the changes in aragonOS 4, please see the 
annoucement blog post
 and 
reference documentation
. An annotated list of commits between aragonOS 3 and aragonOS 4 is also 
available
.
Breaking interface changes
Solidity pragma
All contracts inheriting from 
AragonApp
 must now use at least 
pragma solidity 0.4.24
.
Initialization
All 
AragonApp
s must now be initialized before they can be used to prevent uninitialized contracts that may be maliciously initialized by someone else. Trying to access 
auth()
 or 
authP()
 protected functionality in uninitialized apps will now revert.
If your app didn't already require initialization then you'll need to include the following function in your app:
contract
 
App
 
is
 AragonApp 
{
 
/**
    * @dev Initialize can only be called once. It saves the block number in which it was initialized.
    */
 
function
 
initialize
()
 
public
 onlyInit 
{
 
initialized
();
 
}
}
And use it in a template when installing the app:
contract
 
AppInstallTemplate
 
{
 
/**
    * @dev Create a new DAO with App installed
    */
 
function
 
newDAO
()
 
external
 
{
 
// ...
​
        App app 
=
 
App
(
dao
.
newAppInstance
(
/* ... */
));
        app
.
initialize
();
​
 
// Now app can be used
 
// ...
 
}
}
Pruned public constants
To optimize the gas costs of deploying base and proxy contracts as well as simplify public interfaces on tools like etherscan, we've pruned most public constants that would be unnecessary on-chain. This is most likely to only affect any existing tests that expect some constants to be exposed publicly in your contract and can be fixed by either creating mocks or duplicating the constants in the tests.
KernelConstants
 has also been split into 
KernelAppIds
 and 
KernelNamespaceConstants
, although it is unlikely your app was directly inheriting from 
KernelConstants
.
Kernel's newAppInstance overload replaced
An argument was added to the longer overloads of 
newAppInstance()
 and 
newPinnedAppInstance()
 to include an initialization payload so the new proxy instance could be created and initialized in one atomic call. The new arguments list for the longer overloads is 
(byte32 appId, address appBase, bytes initializePayload, bool setDefault)
.
AragonApp.getExecutor(bytes) renamed
AragonApp.getExecutor(bytes)
 has been renamed 
getEVMScriptExecutor(bytes)
 and has 
getEVMScriptRegistry()
 exposed alongside it.
Proxy-less AragonApps
By default, all 
AragonApp
s are petrified on deployment and can only be used behind a proxy.
This was chosen as a sane default as it is unlikely you'd want to directly deploy, install, and use a base contract instance of an app rather than a proxy instance, but it is also possible to turn this off by inheriting from 
UnsafeAragonApp
 instead.
Stand-alone usage of AragonApps
AragonApp
s that use any functionality requiring a Kernel (e.g. 
auth()
, EVMScripts, or the recovery mechanism) now require the app instance to be connected to a Kernel. Frankly, if you're not using any of this functionality, you probably shouldn't be inheriting from 
AragonApp
.
The old behaviour used to be that functionality protected by the 
auth()
 or 
authP()
 modifiers could still be invoked if the app instance wasn't connected to a Kernel. This was unexpected and confusing behaviour, possibly leading to dangerous situations, and was removed.
EVMScripts require callers to be initialized
Using 
AragonApp.runScript(bytes, bytes, address[])
 requires an application to be initialized, and each EVMScript executor contract now also checks if its caller has been initialized to prevent malicious misuse from unintended users.
DelegateScript and DeployDelegateScript executors removed
Both 
DelegateScript
 and 
DeployDelegateScript
 were found to be insecure and have been removed. Although they were still protected by the ACL, the potential for damage was too high due to the fact that they 
delegatecall
ed into a user-submitted address.
Token contracts removed
The 
Minime token
 and 
Standard token
 implementations were removed. You should import these contracts into your own project if you would like to continue to use them.
If you'd like to see what this looks like in practice, you can visit 
aragon-apps/shared/minime
.
aragon-apps
All the apps in 
aragon-apps
 were upgraded to aragonOS 4. Most have not changed much with very few external interface differences. If you were using old versions of them such as in an organization template, however, then you may have to adjust to small differences in their APIs.
The most notable change is with the 
Vault
 which was massively simplified and made much easier to secure than the previous implementation. If you had trouble integrating with the previous Vault, this one should be much simpler to use and understand.
For more information see the 
raw list of changes
.
Shiny new things
ETH and token recoverability
All 
AragonApp
s now have built-in ETH and token recoverability in case they accidentally receive value. A 
transferToVault(address)
 interface is exposed externally to allow someone to send the tokens held by an app instance to the default vault set in the Kernel.
An 
allowRecoverability(address)
 hook is exposed to allow overloading in 
AragonApp
 subclasses to control the recoverability behaviour. For example, if an application is meant to hold tokens or ETH, it should turn off the recoverability behaviour for any accepted tokens so they can't be maliciously transferred to another app, even if it is the default vault.
Depositable proxies
By default, it is impossible to send ETH to an app proxy instance (assuming it is one of 
AppProxyUpgradeable
 or 
AppProxyPinned
) through a gas-limited 
.send()
 or 
.transfer()
. This only applies to proxy instances because you can always declare your own 
payable
 fallback in 
AragonApp
 subclasses.
If your application would like its proxies to be able to directly receive ETH through 
.send()
 or 
.transfer()
, however, you can use 
AragonApp.setDepositable(true)
 at some point to enable this functionality.
Good example use cases of this are in applications that need to hold value like a vault or fundraising contract. A vault would always want to accept direct transfers so it calls 
setDepositable(true)
 upon initialization. A fundraising application, however, would likely only want to enable it for the duration of the fundraising period, so it only calls 
setDepositable(true)
 as the period starts and calls 
setDepositable(false)
 when the period ends.
auth provides isInitialized check
The 
auth()
 and 
authP()
 modifiers now also check for 
isInitialized()
 so you don't have to use both modifiers anymore.
New utilities
It is recommended to use the new 
TimeHelpers
 and 
Uint256Helpers
 utilities to safely get values for time variables (e.g. 
now
) and convert between uint units. These also provide a standard interface that allow you to easily create mocks for changing the time returned during testing.
​
EtherTokenConstant
 is also recommended to use as the "address" for ETH when an application can handle both tokens and ETH.
Technical changes worth knowing about
Unstructured storage
App proxies (
AppProxyUpgradeable
 and 
AppProxyPinned
) are now implemented through 
unstructured storage
.
This means contracts inheriting from 
AragonApp
 now start their storage directly from 
storage slot 0
 rather than an arbitrary value (in aragonOS 3 it was slot 100), making it much easier to inspect, debug, and swap out proxy implementations. This also makes it much easier for aragonOS to add more functionality in the future without requiring data migrations.
Kernel storage of apps
The Kernel's storage of apps and their namespacing was revamped to use a mapping of a mapping approach rather than a single mapping whose key was derived from a hash of the namespace and app name.
This is not only cheaper but also makes inspection and debugging much easier as the storage location for a particular app requires less steps to derive.
Preferring mappings to arrays for storing structs
As pointed out at 
Devcon 3
, mappings of structs are much easier to upgrade at later dates than arrays of structs because the data isn't packed tightly. All aragonOS internal and official aragon apps now use this pattern of emulating arrays through mappings.
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Reference documentation
Next
Reference (aragonOS 3)
Last modified 
7mo ago
Copy link
On this page
Breaking interface changes
Shiny new things
Technical changes worth knowing about









---PAGE 57---












Reference (aragonOS 3) - Aragon Developer Documentation






















Links
Reference (aragonOS 3)
Documentation for 
aragonOS v3.1.2.
This document provides a technical overview of the 
architecture
 and can be used as a 
specification and developer guide
. For a less technical introduction to aragonOS 3 you can check the 
alpha release blog post
.
General architecture and design philosophy
Using aragonOS to build a system allows for 
decoupling
 of specific 
business logic
 of a protocol or application from its 
authentication logic
. It allows you to code your application without thinking about authentication or governance at all. By inheriting from the 
AragonApp
 base class and defining actions that require authentication with a special modifier, aragonOS can handle authentication for the protocol.
Basic concepts: Proxy and Forwarder
Before describing general ideas about the architecture, it is important to understand two concepts the entire framework builds upon:
Proxy
A Proxy is a very simple smart contract construct which consists of decoupling the instance of a particular smart contract with the location of its actual business logic. We call individual instances of contracts 
Proxy
 and the logic 
base contracts
. A Proxy delegates all its logic to a base contract. Upgradeability is achieved because this link to the base contract can be modified, effectively updating the Proxy business logic. We created 
ERC897
 to standardize Proxy interfaces for better interoperability in the ecosystem.
Forwarder
A Forwarder is a contract that, given some conditions, will pass along a certain action to other contract(s).
Thanks to the fact that proxies allow a certain instance of a contract to never have to change its address even if its underlying logic changes, it's easy to identify a certain instance of a contract and helps with the decoupling of authentication and logic. For example, just by checking that an action's 
sender address is an instance of a Voting app with a particular address
, we can know that the action must have been approved by a vote.
Architecture: Kernel and apps
An organization or protocol that is built with aragonOS is composed of two types of smart contracts:
Kernel
The kernel is at the core of every organization and there is only one instance of it per organization. It manages a very important mapping of 
base contract
 addresses of each application registered in the kernel (such as the ACL) or the kernel’s own 
base contract
.
Apps
Apps are contracts that rely on the kernel for their upgradeability and access control.
Design philosophy
The design philosophy we use when developing Aragon apps is very similar to the UNIX philosophy: we try to architect them to do one thing and one thing well, and to respect and implement the few aragonOS interfaces so that they play nicely with the rest of the ecosystem.
This results in purely technical benefits such as testability, but it is also very powerful when apps are combined and the output of one app becomes the input of an other one (forwarders resemble UNIX pipes in some way).
Lifecycle of an aragonOS call
​
Kernel
The app mapping
At the core of the kernel lives a critical mapping called the 
app
 mapping.
Modifying this mapping can have completely destructive consequences and can result in loss of funds. The permission to execute this action has to be well protected behind the ACL.
function
 
setApp
(
bytes32
 namespace
,
 
bytes
 appId
,
 
address
 app
)
 
public
;
Namespace:
 specifies what type of app record is being set.
AppId:
 used to identify what app is being set. It is the 
ENS 
namehash
 of the aragonPM repo (e.g. 
namehash('voting.aragonpm.eth')
).
App:
 Address of a contract that can have different meaning depending on the namespace.
Namespaces
Core namespace
 (
keccak256('core')
): in this namespace is where the core components of the kernel reside. The only thing in the core mapping is the reference to the kernel base contract.
Base namespace
 (
keccak256('base')
): keeps track of the base contracts for appIds.
App namespace
 (
keccak256('app')
): some apps use the app namespace as a way to reference other apps. For example this is used to store the reference to the ACL instance or the EVMScriptsRegistry.
Upgradeability
Upgradeability of apps and the kernel is done by setting a new address for a specific key in the 
apps
 mapping in the kernel.
Kernel upgradeability
Kernel instances for different organizations can share the same implementation. Every Kernel instance is a KernelProxy . The logic for upgrading to a new implementation is in the implementation itself. An upgrade to the Kernel could render it un-upgradeable.
Upgrading the kernel of an organization is done by changing the 
Kernel appId
 in the 
Core namespace
kernel
.
setApp
(
kernel
.
CORE_NAMESPACE
(),
 kernel
.
KERNEL_APP_ID
(),
 newKernelCodeAddr
)
AppProxies and upgradeability
In a similar fashion to the Kernel, apps can share implementation code to save gas on deployment. AppProxies rely on the Kernel for their upgradeability.
Upgrading an app is done by setting a new app address for the 
appId
 for the 
Base namespace
 in the kernel.
kernel
.
setApp
(
kernel
.
APP_BASES_NAMESPACE
(),
 votingAppId
,
 newVotingAppCodeAddr
)
aragonOS provides two different types of App Proxies:
UpgradeableAppProxy
: in every call to the proxy, it checks with the Kernel what the current code for that appId is and forwards the call.
PinnedAppProxy
: on contract creation it checks and saves the app code currently in the Kernel. This cannot be upgraded unless the app code has explicit logic to change that storage slot.
There is an extra function in the Kernel that allows for setting the app code and at the same time creating a new proxy. This function only sets the code the first time.
kernel
.
newAppInstance
(
votingAppId
,
 votingApp
)
kernel
.
newPinnedAppInstance
(
votingAppId
,
 votingApp
)
ACL
A 
Permission
 is defined as the ability to perform actions (grouped by roles) in a certain app instance (identified by its address).
We refer to a 
Permission Instance
 as an entity holding a certain permission.
Managing permissions
First of all, you need to define your base ACL instance for your kernel with:
acl 
=
 
ACL
(
kernel
.
acl
())
Then you can execute the following actions:
Create permission
acl
.
createPermission
(
address
 entity
,
 
address
 app
,
 
bytes32
 role
,
 
address
 manager
)
createPermission()
 will fail if that permission has pre-existing permission instances.
This action is identical to 
grantPermission()
 except it allows the creation of a new permission if it doesn’t exist yet.
A role in the ACL protects access to 
createPermission()
 as this important function could be used in malicious ways. When the Kernel is initialized, it also creates the permission that grants the initializing address the ability to create new permissions.
Note that creating permissions is made mandatory by the ACL: all actions requiring yet-to-be-created permissions are disallowed by default. Any permission checks on non-existent permissions are failed automatically.
Grant permission
acl
.
grantPermission
(
address
 entity
,
 
address
 app
,
 
bytes32
 role
)
Grants 
role
 in 
app
 for an 
entity
. Only callable by the 
manager
 of a certain permission. This 
entity
 would then be allowed to call all actions that their 
role
 can perform on that particular 
app
 until the permission manager revokes their role with 
revokePermission()
.
The 
grantPermission()
 action doesn’t require protection with the ACL because an entity can only make changes to a permission if it is the permission's 
manager
.
Revoke permission
acl
.
revokePermission
(
address
 entity
,
 
address
 app
,
 
bytes32
 role
)
Revokes 
role
 in 
app
 for an 
entity
. Only callable by the 
manager
 of a certain permission.
The 
revokePermission()
 action doesn’t need to be protected by the ACL either as an entity can only make changes if it is the 
manager
 for a given permission.
Adding permissions
Apps have the choice of which actions to protect behind the ACL as some actions may make sense to be completely public. Protecting an action behind the ACL is done in the smart contract by simply adding the authentication modifier 
auth()
 or 
authP()
(passing the role required as a parameter) to the action. On executing the action, the 
auth()
/
authP()
 modifiers check with the Kernel whether the entity performing the call holds the required role or not.
Basic ACL
As an example, the following steps show a complete flow for user "Root" to create a new DAO with the basic permissions set so that a 
Voting app
 can manage the funds stored in a 
Vault app
:
1.
Deploy the Kernel and the ACL
2.
Executing 
kernel.initialize(acl, rootAddress)
 which in turns calls 
acl.initialize(rootAddress)
 creates the "permissions creator" permission under the hood: 
createPermission(rootAddress, aclAddress, CREATE_PERMISSIONS_ROLE, rootAddress)
3.
Deploy the Voting app
4.
Grant the Voting app the ability to call 
createPermission()
: 
grantPermission(votingAppAddress, aclAddress, CREATE_PERMISSIONS_ROLE)
 (must be executed by 
rootAddress
)
5.
Deploy the Vault app, which has a action called 
transferTokens()
6.
Create a new vote via the Voting app to create the 
TRANSFER_TOKENS_ROLE
 permission 
createPermission(votingAppAddress, vaultAppAddress, TRANSFER_TOKENS_ROLE, votingAppAddress)
7.
If the vote passes, the Voting app then has access to all actions in the Vault protected by 
TRANSFER_TOKENS_ROLE
, which in this case is just 
transferTokens()
8.
Fund transfers from the Vault can now be controlled via votes from the Voting app. Each time a user wishes to transfer funds, they can create a new vote via the Voting app to propose an execution of the Vault's 
transferTokens()
 action. The 
transferTokens()
 action will be executed if and only if the vote passes.
Note that the Voting app is also able to revoke or regrant the 
TRANSFER_TOKENS_ROLE
 permission as it is that permission's manager on 
vaultAppAddress
.
Permission managers
As we have seen, when a permission is created a 
Permission Manager
 is set for that specific permission. The permission manager is able to grant or revoke permission instances for that permission.
The Permission Manager can be changed with this command:
acl
.
setPermissionManager
(
address
 newManager
,
 
address
 app
,
 
bytes32
 role
)
Changes the permission manager to 
newManager
. Only callable by the 
manager
 of a certain permission.
The new permission manager replaces the old permission manager resulting in the old manager losing any management power over that permission.
createPermission()
 executes a special case of this action to set the initial manager for the newly created permission. From that point forward, the manager can only be changed with 
setPermissionManager()
.
There's also a getter for the Permission Manager:
acl
.
getPermissionManager
(
address
 app
,
 
bytes32
 role
)
Parameter interpretation
When a permission is granted to an entity by the permission manager it can be assigned an array of parameters that will be evaluated every time the ACL is checked to see if the entity can perform the action.
Parameters allow the ACL to perform certain computations with the arguments of a permission in order to decide whether to allow the action or not. This moves the ACL from being a purely binary access list to a more sophisticated system that allows for fine-grained control.
An ACL parameter is comprised of a data structure with 3 values:
Argument Value
 (
uint240
): the value to compare against, depending on the argument. It is a regular Ethereum memory word that loses its two most significant bytes of precision. The reason for this was to allow parameters to be saved in just one storage slot, saving significant gas. Even though 
uint240
s are used, it can be used to store any integer up to 
2^30 - 1
, addresses, and bytes32. In the case of comparing hashes, losing 2 bytes of precision shouldn't be a dealbreaker if the hash algorithm is secure.
Argument ID
 (
uint8
): Determines how the comparison value is fetched. From 0 to 200 it refers to the argument index number passed to the role. After 200, there are some 
special Argument IDs
:
BLOCK_NUMBER_PARAM_ID
 (
id = 200
): Sets comparison value to the block number at the time of execution. This allows for setting up timelocks depending on blocks.
TIMESTAMP_PARAM_ID
 (
id = 201
): Sets comparison value to the timestamp of the current block at the time of execution. This allows for setting up timelocks on time.
SENDER_PARAM_ID
 (
id = 202
): Sets comparison value to the sender of the call. (Currently useless)
ORACLE_PARAM_ID
 (
id = 203
): Checks with an oracle at the address in the 
argument value
 and returns whether it returned true or false (no comparison with the 
argument value
).
LOGIC_OP_PARAM_ID
 (
id = 204
): Evaluates a logical operation and returns true or false depending on its result (no comparison with the 
argument value
).
PARAM_VALUE_PARAM_ID
 (
id = 205
): Uses value as return. Commonly used with the 
RET
 operation to just return a value. If the value in the param is greater than 0, it will evaluate to true, otherwise it will return false.
Operation type
 (
uint8
): Determines what operation is made to compare the value fetched using the argument ID or the argument value. For all comparisons, both values are compared in the following order 
args[param.id] <param.op> param.value
. Therefore for a greater than operation, with a 
param = {id: 0, op: Op.GT, value: 10}
, it will interpret whether the argument 0 is greater than 10. The implemented operation types are:
None (
Op.NONE
): Always evaluates to 
false
 regardless of parameter or arguments.
Equals (
Op.EQ
): Evaluates to true if every byte matches between 
args[param.id]
 and 
param.value
.
Not equals (
Op.NEQ
): Evaluates to true if any byte doesn't match.
Greater than (
Op.GT
): Evaluates to true if 
args[param.id] > param.value
.
Less than (
Op.LT
): Evaluates to true if 
args[param.id] < param.value
.
Greater than or equal (
Op.GTE
): Evaluates to true if 
args[param.id] >= param.value
.
Less than or equal (
Op.LTE
): Evaluates to true if 
args[param.id] <= param.value
.
Return (
Op.RET
): Evaluates to true if 
args[param.id]
 is greater than one. Used with 
PARAM_VALUE_PARAM_ID
, it makes 
args[param.id] = param.value
, so it returns the parameter associated value.
While also representing an operation, when the argument ID is 
LOGIC_OP_PARAM_ID
 only the 
Op
s below are valid. These operations use the parameter's value to point to other parameter indices in the parameter array. Any values are encoded as 
uint32
 numbers, each left-shifted 32 bits (for example, an 
Op
 that takes two inputs with a value of 
0x00....0000000200000001
 would have input 1, 1, and input 2, 2, refering to params at index 1 and 2). Here are the available logic 
Op
s:
Not (
Op.NOT
): Takes 1 parameter index and evaluates to the opposite of what the linked parameter evaluates to.
And (
Op.AND
): Takes 2 parameter indices and evaluates to true if both evaluate to true.
Or (
Op.OR
): Takes 2 parameter indices and evaluates to true if any of them evaluate to true.
Exclusive or (
Op.XOR
): Takes 2 parameter indices and evaluates to true if only one of the parameters evaluate to true.
If else (
Op.IF_ELSE
): takes 3 parameters, evaluates the first parameter and if true, evalutes as the second parameter's evaluation, or as the third parameter's evaluation if false.
Parameter execution
When evaluating a rule the ACL will always evaluate the result of the first parameter. This first parameter can be an operation that links to other parameters and its evaluation depends on those parameters' evaluation. Execution is recursive and the result evaluated is always the result of the evaluation of the first parameter.
Parameter encoding
To encode some logic operations (AND, OR, IF-ELSE) which link to other parameters, the following helpers are provided, where the function arguments always refer to parameter indexes in the 
Param
 array they belong to:
If-Else (ternary) operation
encodeIfElse
(
uint
 condition
,
 
uint
 success
,
 
uint
 failure
)
Binary operations (And, Or)
encodeOperator
(
uint
 param1
,
 
uint
 param2
)
Examples of rules
The interpreter supports encoding complex rules in what would look almost like a programming language. For example let’s look at the following 
test case
:
 
function
 
testComplexCombination
()
 
{
 
// if (oracle and block number > block number - 1) then arg 0 < 10 or oracle else false
        Param
[]
 
memory
 params 
=
 
new
 
Param
[](
7
);
        params
[
0
]
 
=
 
Param
(
LOGIC_OP_PARAM_ID
,
 
uint8
(
Op
.
IF_ELSE
),
 
encodeIfElse
(
1
,
 
4
,
 
6
));
        params
[
1
]
 
=
 
Param
(
LOGIC_OP_PARAM_ID
,
 
uint8
(
Op
.
AND
),
 
encodeOperator
(
2
,
 
3
));
        params
[
2
]
 
=
 
Param
(
ORACLE_PARAM_ID
,
 
uint8
(
Op
.
EQ
),
 
uint240
(
new
 
AcceptOracle
()));
        params
[
3
]
 
=
 
Param
(
BLOCK_NUMBER_PARAM_ID
,
 
uint8
(
Op
.
GT
),
 
uint240
(
block
.
number 
-
 
1
));
        params
[
4
]
 
=
 
Param
(
LOGIC_OP_PARAM_ID
,
 
uint8
(
Op
.
OR
),
 
encodeOperator
(
5
,
 
2
));
        params
[
5
]
 
=
 
Param
(
0
,
 
uint8
(
Op
.
LT
),
 
uint240
(
10
));
        params
[
6
]
 
=
 
Param
(
PARAM_VALUE_PARAM_ID
,
 
uint8
(
Op
.
RET
),
 
0
);
​
 
assertEval
(
params
,
 
arr
(
uint256
(
10
)),
 
true
);
​
        params
[
4
]
 
=
 
Param
(
LOGIC_OP_PARAM_ID
,
 
uint8
(
Op
.
AND
),
 
encodeOperator
(
5
,
 
2
));
 
assertEval
(
params
,
 
arr
(
uint256
(
10
)),
 
false
);
 
}
When assigned to a permission, this rule will 
evaluate to true
 (and therefore allow the action) only on the following conditions:
If an oracle accepts it, and
The block number is greater than the previous block number, and
Either the oracle allows it (again! testing redundancy too) or the first parameter of the rule is lower than 10.
The possibilities for customizing an organization or protocol's governance model are truly endless and there is no need to write any actual Solidity.
Events
createPermission()
, 
grantPermission()
, and 
revokePermission()
 all fire the same 
SetPermission
 event that Aragon clients are expected to cache and process into a locally stored version of the ACL:
SetPermission
(
address
 
indexed
 
from
,
 
address
 
indexed
 to
,
 
bytes32
 
indexed
 role
,
 
bool
 allowed
)
setPermissionManager()
 fires the following event:
ChangePermissionManager
(
address
 
indexed
 app
,
 
bytes32
 
indexed
 role
,
 
address
 
indexed
 manager
)
Forwarders and EVMScript
Forwarders are one of the most important concepts of aragonOS. Rather than hardcoding the notion of a vote into each separate app’s functionality and ACL one can instead use a generic Voting App, which implements the forwarding interface, to pass actions 
forward
 to other apps after successful votes. If the Voting App is set up to only allow a token’s holders to vote, that means any actions/calls being passed from it must have also been approved by the token’s holders.
Forwarding and transaction pathing
The forwarding interface also allows a frontend interface, like the Aragon client, to calculate "forwarding paths". If you wanted to perform an action but you don't have the required permissions, a client can think of alternative paths for execution. For example, you might be in the Vault app's interface wishing to perform a token transfer. If you only had the permission to create votes, the client would directly prompt you to create a vote rather than let you complete the transfer. The flow is illustrated in the following animation:
Vote forwarding scenario. (Please note that the governance model and characters are fictional). 
👇
EVMScripts
We have designed our own scripting format, known as EVMScripts, to encode complex actions into a bytes representation that can be stored and later executed by another entity. EVMScripts can be installed on a per-organization basis through a 
EVMScriptRegistry
 and aragonOS comes complete with the ability to install multiple script executors in an organization.
EVMScript executors
 are contracts that take a script and an input and return an output after execution.
Script executors and EVMScriptRegistry
EVMScript executors must implement the following interface:
interface
 
IEVMScriptExecutor
 
{
 
function
 
execScript
(
bytes
 script
,
 
bytes
 input
,
 
address
[]
 blacklist
)
 
external
 
returns
 
(
bytes
);
}
Because script executors get are called with a 
delegatecall
, in order to prevent self-destructs, 
IEVMScriptExecutor.execScript(...)
 MUST return at least 32 bytes so in case an executor 
selfdestruct
s it could be detected.


CallsScript
aragonOS provides the 
CallsScript
 executor as a simple way to concatenate multiple calls. It cancels the operation if any of the calls fail.
Script body:
 See 
CallsScript
 source code 
for spec of the payload.
Input:
 None
Output:
 None.
Blacklist:
 Entire script reverts if a call to one of the addresses in the blacklist is performed.
DelegateScript
 
delegatecalls
 into a given contract which basically allows for any arbitrary computation within the EVM in the caller’s context.
Script body:
 Address of the contract to make the call to.
Input:
 
calldata
 for the 
delegatecall
 that will be performed.
Output:
 raw return data of the call.
Blacklist:
 impossible to enforce. If there are any addresses in the blacklist the script will revert as it is not possible to check whether a particular address will be called.


DeployDelegateScript
Is a superset of the DelegateScript but it takes a contract’s initcode bytecode as its script body instead of just an address. On execution, it deploys the contract to the blockchain and executes it with a 
delegatecall
.
Script body:
: initcode for contract being created.
Input:
 
calldata
 for the 
delegatecall
 that will be performed after contract creation.
Output:
 raw return data of the call.
Blacklist:
 impossible to enforce. If there are any addresses in the blacklist the script will revert as it is not possible to check whether a particular address will be called.
Making an app a Forwarder
Examples of forwarders can be found in the aragon-apps repo. Both the Voting and the Token Manager are forwarders.
Warning
EVMScripts are very powerful and risk causing security breaches! For example, the Token Manager, which allows any token holder to forward actions, needs to have the token address in its blacklist as otherwise any token holder would effectively have control over the token in the same way that the Token Manager does!


​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Migrating to aragonOS 4 from aragonOS 3
Next
Smart Contract References
Last modified 
5mo ago
Copy link
On this page
General architecture and design philosophy
Basic concepts: Proxy and Forwarder
Architecture: Kernel and apps
Design philosophy
Kernel
The app mapping
Namespaces
Upgradeability
Kernel upgradeability
AppProxies and upgradeability
ACL
Managing permissions
Basic ACL
Permission managers
Parameter interpretation
Parameter execution
Parameter encoding
Examples of rules
Events
Forwarders and EVMScript
Forwarding and transaction pathing
EVMScripts
Making an app a Forwarder









---PAGE 58---












Smart Contract References - Aragon Developer Documentation




















Links
Smart Contract References
In this section you can find all Smart Contracts functions and parameters:
​
ACL
​
​
APM
​
​
APPS
​
​
COMMON
​
​
ENS
​
​
EVMSCRIPT
​
​
EVMSCRIPT/EXECUTORS
​
​
FACTORY 
​
​
KERNEL
 
​
​
Previous
Reference (aragonOS 3)
Next
ACL
Last modified 
7mo ago
Copy link









---PAGE 59---












Introduction - Aragon Developer Documentation




















Links
Introduction
Standard set of API
s and specifications 
used to interact with aragonOS-powered contracts
 by handling transaction pathing, upgradeability, and contract state without depending on a centralized service.
Reference implementations in specific languages
JavaScript
A JavaScript implementation of the aragonAPI, used to interact with aragonOS by handling transaction pathing, upgradeability, identity providers and state of the contracts.
Some of the things you can do with the JavaScript implementation are:
Connect contracts to front-end
Interact with 
aragonOS
 and aragonOS-powered applications directly through an abstraction over web3.js
Get access to application state with built in client-side caching
Create human-readable transaction descriptions for your smart contracts through 
Radspec
​
Docs
​
Quick Start for apps
​
​
App API
​
​
React API
​
​
Aragon client implementations (wrapper)
​
​
Providers
​
​
Architecture of Aragon apps and their communication channels
​
Guides
​
Background Scripts
​
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
aragonAPI
Next
Javascript
Last modified 
7mo ago
Copy link









---PAGE 60---












Javascript - Aragon Developer Documentation




















Links
Javascript
Here are the articles in this section:
Quick Start
App API
React API
Wrapper
Providers
Architecture of apps
Background Scripts
Previous
Introduction
Next
Quick Start
Last modified 
7mo ago
Copy link









---PAGE 61---












Getting started - Aragon Developer Documentation






















Links
Getting started
Getting started
aragonUI is a React library based on aragonDS, the Aragon design system
. It aims to provide the elements needed to build Aragon apps that feel native to the Aragon ecosystem.
Quick setup
This tutorial doesn’t cover the creation of your React app nor the way you bundle it, but we recommend 
using Parcel.
​
Install aragonUI alongside styled-components in your project:
npm install --save @aragon/ui styled-components
Note: while not required, we strongly recommend adding 
the styled-components Babel plugin
 in your build configuration. It provides, amongst other things, 
the css prop
 that we use widely to.
Copy the aragonUI assets into your assets directory (assuming 
./public
):
npx copy-aragon-ui-assets ./public
Note: doing this step ensures that any assets required by aragonUI, like fonts and illustrations, can be served properly in any environment. Most apps built with aragonUI will be served in a decentralized manner (generally through an IPFS gateway), so using services like Google Fonts is not an option.
The only mandatory component that you need to define is 
Main
. This component sets up the global styles and providers used by other components. We recommend wrapping your entire app with Main:
import
 React 
from
 
'react'
import
 
{
 Main 
}
 
from
 
'@aragon/ui'
​
function
 
App
()
 
{
 
return
 
(
 
<
Main
>
 
<
div
>
Your app goes here
</
div
>
 
</
Main
>
 
)
}
From that point on, you are ready to start building your app! Let’s go through a simple app to get an overview of the components that are often used in Aragon apps.
A typical Aragon app
Aragon apps can take many shapes, but most tend to follow similar patterns. aragonUI provides components that can be used to build apps that are responsive, accessible, and theme-able by default.
This section takes the 
Tokens app
 to illustrate the different elements that constitute a typical Aragon app and how they might be put together. Rather than implementing every behaviour in the Tokens app, we are going to focus on the structure of the app and its main components. To get an idea of what the final app looks like, you can visit the 
full source code
.
This is how it looks:
The Tokens app and its layout variations.
Overview
Let’s start by defining what constitutes an Aragon app.
The Aragon client 
1
 displaying the Tokens app, in the app area 2.
As you can see, the app is only a part of what a user sees when interacting with the Aragon client, in a way that the app can not interfere with the interface of the client or the other apps.
Two components that are commonly used in Aragon apps are 
Header
 and 
Split
. 
Header
 handles the main title of an app and its main action. 
Split
 creates a two column layout when the available horizontal space allows it. On smaller screens, it renders as a single column. As we continue, we will also be using the 
DataView
 and the 
SidePanel 
components.
The Tokens app, featuring the Header 1 and the Split 2 components.
Header
This is how 
Header
 can be used inside an app.
// App.js
import
 React 
from
 
'react'
import
 
{
 Main
,
 Header
,
 Button
,
 IconPlus
,
 Tag 
}
 
from
 
'@aragon/ui'
​
function
 
App
()
 
{
 
return
 
(
 
<
Main
>
 
<
Header
 
primary
=
{
 
<
>
            Tokens
 
<
Tag
 
mode
=
"
identifier
"
>
PTO
</
Tag
>
 
</
>
 
}
 
secondary
=
{
 
<
Button
 
mode
=
"
strong
"
 
label
=
"
Add tokens
"
 
icon
=
{
<
IconPlus
 
/>
}
 
/>
 
}
 
/>
 
</
Main
>
 
)
}
There are a few things to note, the first one being the way these props are named. 
primary
 and 
secondary
 are names used by aragonUI components for “slots”. Slots don’t really exist in a technical sense: this is only a name for props that are expecting a subtree to be passed, similar to the way 
children
 works in components accepting a single tree.
If you run this app, you might also notice that the 
Button
 component displays either a text label or an icon, adapting to the viewport size automatically. Some components adapt to where they are, which is the case here. 
Button
, being in 
Header,
 follows the behavior defined by aragonDS about how it should adapt to different viewport sizes. These variations make it easy to follow the patterns defined by aragonDS, and are always documented and overridable.
SidePanel
To make things a bit more interesting, we are going to add a 
SidePanel
 that opens from the “Add tokens” header button. The 
SidePanel
 component can be inserted anywhere, as long as it is inside the 
Main
 tree.
// App.js
import
 React
,
 
{
 useState 
}
 
from
 
'react'
import
 
{
 Main
,
 Header
,
 Button
,
 IconPlus
,
 Tag
,
 SidePanel 
}
 
from
 
'@aragon/ui'
​
function
 
App
()
 
{
 
const
 
[
sidePanelOpened
,
 setSidePanelOpened
]
 
=
 
useState
(
false
)
 
return
 
(
 
<
Main
>
 
<
Header
 
primary
=
{
 
<
>
            Tokens
 
<
Tag
 
mode
=
"
identifier
"
>
PTO
</
Tag
>
 
</
>
 
}
 
secondary
=
{
 
<
Button
 
mode
=
"
strong
"
 
label
=
"
Add tokens
"
 
icon
=
{
<
IconPlus
 
/>
}
 
onClick
=
{()
 
=>
 
setSidePanelOpened
(
true
)}
 
/>
 
}
 
/>
 
<
SidePanel
 
title
=
"
Add tokens
"
 
opened
=
{
sidePanelOpened
}
 
onClose
=
{()
 
=>
 
setSidePanelOpened
(
false
)}
 
>
 
{
/* SidePanel content goes here */
}
 
</
SidePanel
>
 
</
Main
>
 
)
}
That’s pretty much it! We now have a drawer that opens from the right side of the screen (with left to right languages), that can be closed by the user. We’re ready to move to the next part of the app.
Three components used in this app: DataView 1, a Box 2, and another Box with Distribution 3.
Split
Let’s define the 
Split
 layout, right after the Header, to get an idea of what the structure will look like:
// App.js
import
 React
,
 
{
 useState 
}
 
from
 
'react'
import
 
{
 Main
,
 Header
,
 Split
,
 DataView
,
 Box 
}
 
from
 
'@aragon/ui'
​
function
 
App
()
 
{
 
const
 
[
sidePanelOpened
,
 setSidePanelOpened
]
 
=
 
useState
(
false
)
 
return
 
(
 
<
Main
>
 
<
Header
 
/>
 
<
Split
 
primary
=
{
<
DataView
 
/>
}
 
secondary
=
{
 
<
>
 
<
Box
 
/>
 
<
Box
 
/>
 
</
>
 
}
 
/>
 
<
SidePanel
 
title
=
"
Add tokens
"
 
opened
=
{
sidePanelOpened
}
 
onClose
=
{()
 
=>
 
setSidePanelOpened
(
false
)}
 
/>
 
</
Main
>
 
)
}
Like 
Header
, the 
Split
 component defines two slots using the same 
primary
 and 
secondary
 names.
DataView
​
DataView 
is a powerful component that can be used to represent data in various ways, adapting itself to the available space. We are going to use it for the “holders” table.
// TokenHoldersView.js
import
 React 
from
 
'react'
import
 
{
  DataView
,
  IdentityBadge
,
  ContextMenu
,
  ContextMenuItem
,
}
 
from
 
'@aragon/ui'
​
// The token holders represented as a DataView.
function
 
TokenHoldersView
(
{
 tokenHolders 
}
)
 
{
 
/*
​
  This is how tokenHolders could look like:
​
  tokenHolders = [
    ['0xcafe…', 3],
    ['0xbeef…', 2],
    …
  ]
​
  */
 
return
 
(
 
<
DataView
 
display
=
"
table
"
 
fields
=
{[
'Holder'
,
 
'Balance'
]}
 
items
=
{
tokenHolders
}
 
renderEntry
=
{
entryParts
}
 
renderEntryActions
=
{
entryActions
}
 
/>
 
)
}
​
// Return the parts (table cells) corresponding to an entry.
function
 
entryParts
(
[
account
,
 balance
]
)
 
{
 
return
 
[
<
LocalIdentityBadge
 
entity
=
{
account
}
 
/>
,
 balance
]
}
​
// Return the contextual menu for an entry (no interaction behavior defined).
function
 
entryActions
(
[
account
,
 balance
]
)
 
{
 
return
 
(
 
<
ContextMenu
>
 
<
ContextMenuItem
>
Add tokens
</
ContextMenuItem
>
 
<
ContextMenuItem
>
Remove tokens
</
ContextMenuItem
>
 
</
ContextMenu
>
 
)
}
​
export
 
default
 TokenHoldersView
To get more details about DataView and how it works, please have a look at its 
documentation page.
​
Box and useTheme()
Box
 is a straightforward component that renders as a surface (as defined by aragonDS) which can optionally have a heading. It is commonly used in either slot of 
Split
.
To implement the “Token info” component, we are going to define some custom styles and use some specific text colors. To ensure your app is compatible with any aragonUI theme, make sure you always use colors from the 
useTheme()
 hook.
// TokenInfoBox.js
import
 React 
from
 
'react'
import
 
{
 Box
,
 TokenBadge
,
 useTheme 
}
 
from
 
'@aragon/ui'
​
// TokenInfoBox is making use of the Box with some custom content.
function
 
TokenInfoBox
(
{
 supply
,
 transferable
,
 token 
}
)
 
{
 
return
 
(
 
<
Box
 
heading
=
"
Token info
"
>
 
<
TokenInfoBoxRow
 
primary
=
"
Total supply
"
 
secondary
=
{
supply
}
 
/>
 
<
TokenInfoBoxRow
 
primary
=
"
Transferable
"
 
secondary
=
{
transferable 
?
 
'YES'
 
:
 
'NO'
}
 
/>
 
<
TokenInfoBoxRow
 
primary
=
"
Token
"
 
secondary
=
{
 
<
TokenBadge
 
address
=
{
token
.
address
}
 
name
=
{
token
.
name
}
 
symbol
=
{
token
.
symbol
}
 
/>
 
}
 
/>
 
</
Box
>
 
)
}
​
// TokenInfoBoxRow is relying on useTheme() to get a specific text color.
function
 
TokenInfoBoxRow
(
{
 primary
,
 secondary 
}
)
 
{
 
const
 theme 
=
 
useTheme
()
 
return
 
(
 
<
div
 
css
=
{
`
        display: flex;
        justify-content: space-between;
 
`
}
 
>
 
<
div
 
css
=
{
`
          color: 
${
theme
.
surfaceContentSecondary
}
;
 
`
}
 
>
 
{
primary
}
 
</
div
>
 
<
div
>
{
secondary
}
</
div
>
 
</
div
>
 
)
}
​
export
 
default
 TokenInfoBox
Distribution
Now that TokenInfoBox is done, there is one last bit remaining, which is the “ownership distribution” box. Luckily for us, the 
Distribution
 component will do most of the work.
// OwnershipDistributionBox.js
import
 React 
from
 
'react'
import
 
{
 Box
,
 Distribution 
}
 
from
 
'@aragon/ui'
​
// OwnershipDistributionBox combines Box
// and Distribution into a single component.
function
 
OwnershipDistributionBox
(
{
 supply
,
 tokenHolders 
}
)
 
{
 
const
 distributionItems 
=
 tokenHolders
.
map
((
[
account
,
 balance
]
)
 
=>
 
({
 
item
:
 account
,
 
percentage
:
 
(
balance 
/
 supply
)
 
*
 
100
,
 
}))
​
 
return
 
(
 
<
Box
 
heading
=
"
Ownership Distribution
"
>
 
<
Distribution
 
heading
=
"
Token holder stakes
"
 
items
=
{
distributionItems
}
 
/>
 
</
Box
>
 
)
}
​
export
 
default
 OwnershipDistributionBox
Wrapping up
Now that we implemented the different parts of the app, this is how the main component would look like in its final state:
// App.js
import
 React
,
 
{
 useState 
}
 
from
 
'react'
import
 
{
 Main
,
 Header
,
 Button
,
 SidePanel 
}
 
from
 
'@aragon/ui'
​
import
 TokenHoldersView 
from
 
'./TokenHoldersView'
import
 TokenInfoBox 
from
 
'./TokenInfoBox'
import
 OwnershipDistributionBox 
from
 
'./OwnershipDistributionBox'
​
// Some demo data
const
 token 
=
 
{
 
name
:
 
'My Organization Token'
,
 
symbol
:
 
'MOT'
,
 
address
:
 
'0x…'
,
 
transferable
:
 
true
,
 
supply
:
 
8
,
 
holders
:
 
[
 
[
'0xcafe…'
,
 
3
],
 
[
'0xbeef…'
,
 
2
],
 
[
'0xfeed…'
,
 
1
],
 
[
'0xface…'
,
 
1
],
 
[
'0xbead…'
,
 
1
],
 
],
}
​
function
 
App
()
 
{
 
const
 
[
sidePanelOpened
,
 setSidePanelOpened
]
 
=
 
useState
(
false
)
 
return
 
(
 
<
Main
>
 
<
Header
 
/>
 
<
Split
 
primary
=
{
<
TokenHoldersView
 
tokenHolders
=
{
token
.
holders
}
 
/>
}
 
secondary
=
{
 
<
>
 
<
TokenInfoBox
 
supply
=
{
token
.
supply
}
 
/>
 
<
OwnershipDistributionBox
 
supply
=
{
token
.
supply
}
 
tokenHolders
=
{
token
.
holders
}
 
/>
 
</
>
 
}
 
/>
 
<
SidePanel
 
title
=
"
Add tokens
"
 
opened
=
{
sidePanelOpened
}
 
onClose
=
{()
 
=>
 
setSidePanelOpened
(
false
)}
 
/>
 
</
Main
>
 
)
}
And this is it for the tutorial. Of course, many components were not covered here, the idea being to provide an overview of an Aragon app's structure when it uses aragonUI.
Previous
aragonUI
Next
How to upgrade
Last modified 
5mo ago
Copy link
On this page
Getting started
Quick setup
A typical Aragon app
Overview
Header
SidePanel
Split
DataView
Box and useTheme()
Distribution
Wrapping up









---PAGE 62---












How to upgrade - Aragon Developer Documentation




















Links
How to upgrade
All deprecations requiring a manual upgrade will log warnings to the console in non-production environments.
Outside of any listed exceptions, all deprecations in 1.0 will be removed in releases after March 2020.
Experimental components
Using experimental components have their names prefixed with an underscore, and should always require your attention whenever aragonUI gets updated.
For this release, the 
_DateRange
 component has been renamed 
DateRangePicker
.
Theming
Theming is now done with a hook rather than statically. This change was necessary to allow the theme to change at run time. The 
useTheme()
 hook should now be used to fetch the theme object.
The 
colors
, 
theme
, 
themeDark
, or 
brand
 objects are now deprecated.
For more information, please consult 
the documentation page for colors.
​
AragonApp
This component was already deprecated, and has now been removed. If you were still using it, please use the 
Main
 component instead.
AppView
AppView
 is now deprecated. The layout of an app should now be implicitly handled by 
Main
 and 
Header
 should be used for the app header.
Note: if you really must keep using the 
AppView
 component, you can set set 
layout={false}
 on 
Main
. This feature will be removed at the same time as other deprecations.
Button
The 
secondary
, 
outline
, and 
text
 modes don’t exist anymore. Setting them will display the button in normal mode (the default).
The 
text
 mode has been replaced by the 
ButtonText
 component.
The 
emphasis
 prop doesn’t exist anymore. 
positive
 and 
negative
 are now modes that can be set directly.
See the 
Button
 documentation page
 for more details.
Springs
The 
spring()
 function has been removed. If you were using it, please use the 
springs
 (with an s) object instead.
BreakPoint
​
useViewport()
 
should be used instead.
GRID and grid()
Responsiveness is now handled in a different way, and nothing replaces 
GRID
 / 
grid()
.
AppBar and NavigationBar
For the title and the main action of an app, 
Header
 should get used.
For tabs, use the 
Tabs
 component.
For 
NavigationBar
, we now recommend achieving this by using the 
BackButton
 inside a 
Bar
.
TabBar
TabBar
 has been renamed to 
Tabs
. A legacy 
TabBar
 is still available, but will be removed at the same time as other deprecations.
The 
onSelect
 prop has been removed in 
Tabs
: please use 
onChange
 instead.
Text and font()
Both the 
Text
 component and the 
font()
 utility are deprecated.
Please use 
textStyle()
 directly in your components instead.
Badge
If you were using the 
Badge
 component and/or its variants (
Badge.Info
, 
Badge.Identity
, 
Badge.App
, 
Badge.Notification
, 
BadgeNumber
), you should switch as follows:
Badge
 => 
<Tag />
.
Badge.Info
 => 
<Tag />
.
Badge.Identity
 => 
<IdentityBadge />
.
Badge.App
 => 
<Tag />
.
Badge.Notification
 => 
<Tag limitDigits />
.
BadgeNumber
 => 
<Tag limitDigits />
.
Table
If you were using the 
Table
 component, you might want to have a look at the new 
DataView
 
component. It does what 
Table
 was doing, and much more.
Table
 is not considered deprecated yet, but may be in a future version. It will not be removed following March 2020.
observe()
The 
observe()
 utility is now deprecated. If you were using it with 
@aragon/api
, using 
@aragon/api-react
 directly is now the recommended way to do this.
Previous
Getting started
Next
BASE
Last modified 
7mo ago
Copy link
On this page
Experimental components
Theming
AragonApp
AppView
Button
Springs
BreakPoint
GRID and grid()
AppBar and NavigationBar
TabBar
Text and font()
Badge
Table
observe()









---PAGE 63---












BASE - Aragon Developer Documentation




















Links
BASE
Here are the articles in this section:
Spacing
Colors
Text styles
Icons
Main
Previous
How to upgrade
Next
Spacing
Last modified 
7mo ago
Copy link









---PAGE 64---












ACTIONS - Aragon Developer Documentation




















Links
ACTIONS
Here are the articles in this section:
Button
ContextMenu
Previous
Main
Next
Button
Last modified 
7mo ago
Copy link









---PAGE 65---












NAVIGATION - Aragon Developer Documentation




















Links
NAVIGATION
Here are the articles in this section:
Tabs
Pagination
BackButton
Link
Header
Previous
ContextMenu
Next
Tabs
Last modified 
7mo ago
Copy link









---PAGE 66---












STRUCTURE - Aragon Developer Documentation




















Links
STRUCTURE
Here are the articles in this section:
Bar
Box
Card
Split
DataView
Table
EmptyStateCard
IdentityBadge
TransactionBadge
Tag
Accordion
Timer
TokenAmount
EthIdenticon
TransactionProgress
Previous
Header
Next
Bar
Last modified 
7mo ago
Copy link









---PAGE 67---












DATA ENTRY - Aragon Developer Documentation




















Links
DATA ENTRY
Here are the articles in this section:
AutoComplete
DateRangePicker
DropDown
Switch
Radio
CheckBox
Slider
TextInput
SearchInput
AddressField
RadioGroup
RadioList
TextCopy
Field
Previous
TransactionProgress
Next
AutoComplete
Last modified 
7mo ago
Copy link









---PAGE 68---












VISUALIZATION - Aragon Developer Documentation




















Links
VISUALIZATION
Here are the articles in this section:
CircleGraph
LineChart
Distribution
Previous
Field
Next
CircleGraph
Last modified 
7mo ago
Copy link









---PAGE 69---












FEEDBACK - Aragon Developer Documentation




















Links
FEEDBACK
Here are the articles in this section:
Info
ProgressBar
LoadingRing
Toast
SyncIndicator
FloatIndicator
Previous
Distribution
Next
Info
Last modified 
7mo ago
Copy link









---PAGE 70---












OVERLAYS - Aragon Developer Documentation




















Links
OVERLAYS
Here are the articles in this section:
Help
Popover
Modal
SidePanel
Previous
FloatIndicator
Next
Help
Last modified 
7mo ago
Copy link









---PAGE 71---












ADVANCES - Aragon Developer Documentation




















Links
ADVANCES
Here are the articles in this section:
ButtonBase
FocusVisible
PublicUrl
Redraw
RedrawFromDate
Root
RootPortal
Viewport
Previous
SidePanel
Next
ButtonBase
Last modified 
7mo ago
Copy link









---PAGE 72---












Background Scripts - Aragon Developer Documentation


























Links
Background Scripts
This document outlines 
how to write background scripts
 for your app and why you might want to do so.
Background scripts are parts of your app that are always run as soon as the Aragon Dapp is opened. This is hugely useful if you want to keep your app up to date every time a user opens your app since you can build out your application state in the background. Furthermore, background scripts create a nice separation of concerns - your background script handles all of the state building and your app front-end is simply presentational.
Setup
First you need to instantiate an instance of the 
AragonApp
 class from 
@aragon/api
.
import
 Aragon 
from
 
'@aragon/api'
const
 app 
=
 
new
 
Aragon
()
Next, you need to specify that your app has a background script. In your 
manifest.json
 file, simply specify the 
script
 key. The value should be the path to your built background script. For example, if our built background script was located at 
dist/script.js
, we would specify it like so:
{
 
// name etc.
 
"script"
:
 
"/dist/script.js"
}
Building State
All of the 
AragonApp
 methods are available to you. We highly recommend that you use 
AragonApp#store
 as it handles state caching and events subscriptions for you.
const
 state$ 
=
 app
.
store
((
state
,
 event
)
 
=>
 
{
 
// Initial state is always null
 
if
 
(
state 
===
 
null
)
 state 
=
 
0
​
 
switch
 
(
event
.
event
)
 
{
 
case
 
'Increment'
:
      state
++
 
return
 state
 
case
 
'Decrement'
:
      state
--
 
return
 state
 
}
​
 
// We must always return a state, even if unaltered
 
return
 state
})
Sharing State
If you use 
AragonApp#store
 then state will be automatically shared with your front-end in 
real-time
 (via 
AragonApp#state
).
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Architecture of apps
Next
aragonUI
Last modified 
7mo ago
Copy link
On this page
Setup
Building State
Sharing State









---PAGE 73---












Introduction - Aragon Developer Documentation






















Links
Introduction
The aragonCLI (Command Line Interface) is used to 
create, develop, configure
 and 
manage Aragon DAOs
 and 
Applications
.
Installation
Installation pre-requisites
The following must be installed prior to installation:
Node + npm + yarn
We recommend to install Node using Node Version Manager or NVM. You can find instructions on how to install NVM and Node 
here
.
After downloading and unpacking, you must add the /bin folder to your $PATH.
Dependencies of aragonCLI are constantly 
updated
 which result in Node version errors. Use 
NVM
 
to install and select the right Node version. For compatibility across OS use 
Node v12.7 LTS
 version.
​
Also using 
yarn
 instead of 
npm
 as package manager is advised in some cases. Find how to install 
yarn
.
For Linux:
git
Install this using the command 
sudo apt install git
python
Install this using the command 
sudo apt install python
make
Install this using the command 
sudo apt install make
g++
Install this using the command 
sudo apt install g++
For Mac:
git
Install this using the 
official installer
. We recommend using the package manager 
Homebrew
, in this case use the command 
brew install git
.
Note: Python comes pre-installed on Mac.
For Windows:
windows-build-tools
Install with 
npm i windows-build-tools
Install aragonCLI
The aragonCLI can be installed from NPM:
npm install -g @aragon/cli
Dependencies of aragonCLI are constantly 
updated
 which result in Node version errors. Use 
NVM
 
to install and select the right Node version. For compatibility across OS use 
Node v12.7 LTS
 version.
​
Also using 
yarn
 instead of 
npm
 as package manager is advised in some cases. Find how to install 
yarn
.
In case the above does not work, aragonCLI can also be built and installed from the source with the following commands:
git clone https://github.com/aragon/aragon-cli.git
cd aragon-cli
yarn
cd packages
yarn
npm run build
cd cli
npm install -g
cd ../create-aragon-app
npm install -g
cd ../toolkit
npm install -g
cd ../../..
If you're seeing errors similar to:
EACCES: permission denied
It's probably because you originally installed Node with root permissions. Because of this, writing to your npm directory (
npm -i -g
) requires root permissions too.
While it's not a good idea to have Node installed this way, one way to quickly give yourself root permissions is to run the slightly modified command:
sudo npm i -g --unsafe-perm @aragon/cli
An arguably better way to fix the problem is to follow the steps outlined in this 
stackoverflow answer.
​
After installing aragonCLI, the main 
aragon
 executable will be available for use. Also, the 
dao
 alias will be available which is a shortcut for 
aragon dao
 commands.
The ~/.aragon directory
The aragonCLI creates the 
.aragon
 directory under the user's home directory, where it saves the state of the devchain and the 
Aragon client
. At the moment, this folder is only automatically created after running 
aragon devchain
 once, but can also be created by via 
mkdir ~/.aragon
.
Set a private key
Warning
The default mnemonic for the Aragon CLI is the same for all users. If you are going to deploy contracts to public networks it is highly recommended that you use your own web3 provider and set your own private key.
You can configure a private key for the Aragon CLI in 
~/.aragon
. To do so you will need to create a file 
<network>_key.json
 (eg. 
rinkeby_key.json
) with this structure:
{
 
"rpc"
:
 
"https://<network>.infura.io"
,
 
"keys"
:
 
[
"put-your-priv-key-here"
]
}
You can easily create a new file from the terminal. Find how to do it for 
Linux and Mac
 and for 
Windows
.
Then if you use 
--env aragon:<network>
 when using the aragonCLI it will use that account.
You can also define an 
~/.aragon/mnemonic.json
 file like:
{
 
"mnemonic"
:
 
"explain tackle mirror kit ..."
}
Install IPFS
Since 
v6.0.0
 we separate the installation of 
go-ipfs
 from the aragonCLI. If you do not have it installed globally on your system we have a couple of commands to help with that:
aragon ipfs install
 and 
aragon ipfs uninstall
.
Global options
Options that change the behaviour of the 
aragon
 command:
--environment
: The environment in your 
arapp.json
 that you want to use. Defaults to 
aragon:local
. Check the other 
default environments
. You can also use it with the 
--env
 alias.
--gas-price
: Gas price in Gwei. Defaults to 
2
.
--use-frame
: Use Frame as a signing provider and web3 provider.
--ens-registry
: Address of the ENS registry. This will be overwritten if the selected environment from your arapp.json includes a 
registry
 property.
--ipfs-gateway
: An URI to the IPFS Gateway to read files from. Defaults to 
http://localhost:8080/ipfs
.
--ipfs-rpc
: An URI to the IPFS node used to publish files. Defaults to 
http://localhost:5001#default
.
--cwd
: Project working directory.
--debug
: Show more output to terminal.
--silent
: Silence output to terminal.
Example
aragon <command> --environment aragon:mainnet --gas-price 1 --use-frame --debug
create-aragon-app
This command will set up an Aragon app project so you can start building your app from a functional boilerplate.
npx create-aragon-app <app-name> [boilerplate]
app-name
: The name or ENS domain name for your app in an aragonPM Registry (e.g. 
myapp
 or 
myapp.aragonpm.eth
). If only the name is provided it will create your app on the default 
aragonpm.eth
 registry.
boilerplate
: (optional) the Github repo name or alias for a boilerplate to set up your app. The currently available boilerplates are:
react
: this boilerplate contains a very basic Counter app and a webapp for interacting with it. It showcases the end-to-end interaction with an Aragon app, from the contracts to the webapp. Also it comes with a DAO Template which will allow for using your app to interact with other Aragon apps like the Voting app. You can read more about DAO Template 
here
.
bare
: this boilerplate will just set up your app directory structure but contains no functional code.
tutorial
: this boilerplate is the one used in the 
"Your first Aragon app"
 guide.
other available boilerplates you can find 
here
.
​
Note

Npx is an independent package, it's not necessary to have 
@aragon/cli
 installed to use it. 
npx
 comes with npm 5.2+. If you use npm 5.1 or earlier, you can't use 
npx
. Instead, install 
create-aragon-app
 globally
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
aragonCLI
Next
Main commands
Last modified 
7mo ago
Copy link
On this page
Installation
Installation pre-requisites
Install aragonCLI
The ~/.aragon directory
Set a private key
Install IPFS
Global options
create-aragon-app









---PAGE 74---












Main commands - Aragon Developer Documentation




















Links
Main commands
These are 
general purpose commands
 that will help you to set up and interact with your development environment.
aragon run
Warning
aragon run
 commands are deprecated and will be removed in a future release. aragonCLI is not making use of the 
Aragon Buidler plugin
. For in case your app runs on an older version of aragonCLI, we have left this documentation.
Read 
here
 how to migrate your existing Aragon App  to the Buidler plugin.
The 
run
 command 
used to
 take care of completely setting up the environment needed for running your Aragon app.
aragon run
These are all the things that running 
aragon run
 will do for you:
1.
It checks whether 
IPFS
 and a local 
Ethereum development chain
 (devchain) are running and if not it will start them. Once aragon is terminated, any IPFS or dev chain it started will also be terminated.
2.
It will 
publish your app
 to the local aragonPM registry running in your devchain. This step executes the 
aragon apm publish
 internally. You can check the options and how the command works in depth 
here
.
3.
Once the package is published it will 
create a DAO
 with your app installed. If you are running your app without a Template it will grant permissions to the first account printed in the console to perform all the actions protected by the ACL (Access Control List) in your app.
4.
After the DAO is created it will download the 
Aragon client
, install its dependencies and start it up so you can interact with the DAO in your web browser.
Available options to customize the 
run
 command:
--reset
: If reset is present it will reset the devchain before running. The chain will then start from scratch and all published packages will need to be recreated.
--port
: The port where the devchain will be started.
--network-id
: Network id to connect with.
--hardfork
: Allows to specify which hardfork should be used. Supported hardforks are byzantium, constantinople, petersburg, and istanbul (default).
--block-time
: Specify blockTime in seconds for automatic mining.
--accounts
: Number of accounts to print. Defaults to 
2
.
--files
: The path to the files that will be published. Defaults to the current directory.
bump
: Type of bump (major, minor or patch) or version number to publish the app.
--build
: A flag to specify whether the webapp should be built while publishing, running the script specified in 
build-script
 of 
package.json
. Defaults to 
true
.
--build-script
: The name of the NPM script in your app that will be used for building the webapp.
--prepublish
: A flag to specify whether to run a prepublish script specified in 
prepublish-script
 of 
package.json
. Defaults to 
true
.
--prepublish-script
: The name of the NPM script in your app that will be run before publishing the app. Defaults to 
prepublishOnly
.
--template
: The name of the contract that will be deployed as the 
DAO template
 that will be used to create your DAO. If no Template is provided it will use a default Template that sets up the DAO with just your app (
bare-template.aragonpm.eth
).
--template-init [argument1 ... argumentN]
: The constructor arguments for the Template contract, each separated by a space. See the 
deploy command
 for more information on constructor arguments.
--template-deploy-event
: Event name that the template will fire on success. Defaults to 
DeployDao
.
--template-new-instance
: The function on the template that is called to create a new DAO. Defaults to the 
newInstance
 function for 
bare-template.aragonpm.eth
.
--template-args
: The arguments that the function to create the template is called with. Defaults to an array of arguments. To use arrays use the following format 
["'0xB24b...73a7', '0xB24b...73a7'"]
.
--client
: Whether to start the Aragon client or not. Defaults to 
true
.
--client-version
: Version of Aragon client used to run your sandboxed app.
--client-repo
: Repository of Aragon client to clone and run in your sandboxed app. Defaults to 
https://github.com/aragon/aragon
.
--client-port
: Port being used by Aragon client.
--client-path
: A path pointing to an existing Aragon client installation.
--app-init
: Name of the function that will be called to initialize an app. Defaults to 
initialize
.
--app-init-args
: Arguments for calling the app init function. To use arrays use the following format 
["'0xB24b...73a7', '0xB24b...73a7'"]
.
Running your app from a development HTTP server
aragon run
 by default will replicate Aragon's production environment and publish your app using IPFS. However, when developing the webapp part of your Aragon app, using IPFS would require you to repeat the entire publishing process every time you make a change and want to try it out.
Using the HTTP mode for running your app requires starting an HTTP server to serve your app files before executing 
aragon run
 or 
aragon apm publish
# start your app server before
aragon run --http [server-uri] --http-served-from [path]
http
: This is the flag that indicates that you wish to run your app using HTTP. The URI of the server must be provided here (e.g. 
localhost:4001
).
http-served-from
: Path to the directory that the HTTP server exposes. Some artifacts are generated and placed in this directory during the publishing process of your app. The server needs serve these new files when they are created and the server is already running.
If your HTTP server supports hot-reloading your app's frontend will be hot-reloaded inside the Aragon client.
However, when 
making changes to the background script
 of your app, a refresh of the client is required so the new script can be loaded. Also, depending on how the background script of your app is being built, you may need to manually trigger the compilation of the script.
The 
React boilerplate
 supports serving your app using HTTP.
aragon start
Warning
aragon start
 commands are deprecated and will be removed in a future release. aragonCLI is not making use of the 
Aragon Buidler plugin
. For in case your app runs on an older version of aragonCLI, we have left this documentation.
Read 
here
 how to migrate your existing Aragon App  to the Buidler plugin.
Start the Aragon GUI (graphical user interface). It uses 
aragen
 snapshot to try fetching a prebuild of the client if it was not previously fetched. Otherwise, the command downloads the client repo and build it to use it locally.
aragon start [client-repo] [client-version]
client-repo
: Repository of Aragon client to clone and run in your sandboxed app. Defaults to 
https://github.com/aragon/aragon
.
client-version
: Version of Aragon client used to run your sandboxed app (commit hash, branch name or tag name)
Options:
--client-port
: Port being used by Aragon client.
--client-path
: A path pointing to an existing Aragon client installation.
aragon devchain
The 
devchain
 command is used for starting a local development testnet with all the required components already deployed and ready to use.
aragon devchain
It uses 
aragen
 for setting up the snapshot from which the chain starts. At any point 
aragon devchain --reset
 can be run which will reset the devchain to the original snapshot.
This snapshot contains a local instance of ENS, the first-party 
Aragon apps
 published to aragonPM (e.g. 
voting.aragonpm.eth
 or 
token-manager.aragonpm.eth
) and the first-party 
DAO Templates
 (e.g. 
bare-template.aragonpm.eth
).
Devchains can be started on different ports and will keep their state independent from other chains.
Options:
--reset
: Resets the devchain to the snapshot.
--port
: The port number where the devchain will be started. Defaults to 
8545
.
--network-id
: Network id to connect with.
--hardfork
: Allows to specify which hardfork should be used. Supported hardforks are byzantium, constantinople, petersburg, and istanbul (default).
--block-time
: Specify blockTime in seconds for automatic mining.
--gas-limit
: Block gas limit. Must be specified as a hex string.
--accounts
: Number of accounts to print.
--verbose
: Enable verbose output. Similar to ganache-cli.
Note

The ENS instance is used both for the aragonPM registry 
aragonpm.eth
 and for the 
aragon-id
 
aragonid.eth
.
aragon devchain status
Used to check the status of the local devchain.
aragon devchain status
Options:
--port
: The port to check. Defaults to 
8545
.
aragon deploy
Warning
aragon deploy
 commands are deprecated and will be removed in a future release. aragonCLI is not making use of the 
Aragon Buidler plugin
. In case your app runs on an older version of aragonCLI, we have left this documentation.
Read 
here
 how to migrate your existing Aragon App  to the Buidler plugin.
The 
deploy
 command could be used for deploying an Ethereum contract to the devchain.
aragon deploy [contract-name] --init [argument1 ... argumentN]
The 
contract-name
 defaults to the contract at the path in arapp.json.
Running 
aragon deploy
 will compile your contracts using 
truffle compile
 and will deploy the contract with the constructor arguments provided.
Options:
--init
: Arguments to be passed to contract constructor on deploy. Need to be separated by a space. The 
@ARAGON_ENS
 alias can be used and it will be replaced by the address of the ENS registry in the devchain.
aragon contracts
The 
aragon contracts
 command can be used to execute commands using the same 
truffle
 version that aragonCLI uses behind the scenes to assist in compiling your app's contracts.
aragon contracts <command>
It is equivalent to executing 
npx truffle <command>
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Introduction
Next
DAO commands
Last modified 
7mo ago
Copy link
On this page
aragon run
aragon start
aragon devchain
aragon deploy
aragon contracts









---PAGE 75---












DAO commands - Aragon Developer Documentation




















Links
DAO commands
The 
aragon dao
 commands can be used for 
interacting with your DAO
 directly from the command line. These commands are also available directly using the 
dao
 alias.
Note

The default mnemonic of the Aragon CLI is the same for all users. If you are going to deploy a DAO to public networks it is highly recommended that you use your own web3 provider. Instructions on that can be found 
here
 (scroll down to 'Set a private key').
dao new
Uses a DAO Template to create a new DAO and prints its address.
dao new
Options:
--environment
: The environment in your 
arapp.json
 that you want to use. Defaults to 
aragon:local
. Check the other 
default environments
. You can also use it with the 
--env
 alias.
--use-frame
: Use Frame as a signing provider and web3 provider.
--aragon-id
: Assigns an Aragon Id to the DAO.
--template
: The aragonPM repo name of the template that is used to create the DAO. Defaults to 
bare-template.aragonpm.eth
.
--template-version [version-number|latest]
: The version of the repo that will be used to create the DAO. Defaults to 
latest
.
--fn
: The function on the template that is called to create a new DAO. Defaults to the 
newInstance
 function for 
bare-template.aragonpm.eth
.
--fn-args
: The arguments that the function to create the template is called with. Defaults to an array of arguments. To use arrays use the following format 
["'0xB24b...73a7', '0xB24b...73a7'"]
.
--deploy-event
: The name of the event that is emitted when the DAO is created. The DAO address must be a return argument in the event log named 
dao
. Defaults to 
DeployDao
.
--ipfs-check
: Whether to have start IPFS if not started. Defaults to 
true
.
dao apps
Used to inspect all the installed apps in a DAO.
dao apps <dao-addr>
dao-addr
: The main address of the DAO (Kernel).
Options:
--all
: To include apps without permissions in the report.
dao id assign
Assigns an Aragon Id to a DAO address.
dao id assign <dao> <aragon-id>
or
dao id <dao> <aragon-id>
dao
: The main address of the DAO (Kernel).
aragon-id
: The Aragon Id.
dao install
The 
dao install
 command installs an instance of an app in the DAO.
dao install <dao-addr> <app-apm-repo> [repo-version]
dao-addr
: The main address of the DAO (Kernel).
app-apm-repo
: The repo name of the app being installed (e.g. 
voting
 or 
voting.aragonpm.eth
).
repo-version
: (optional) Version of the repo that will be installed; can be a version number or 
latest
 for the newest published version. Defaults to 
latest
.
In 
aragonOS
 an app is considered to be installed in a DAO if it uses the DAO Kernel as its Kernel and there are references to the app in the ACL of the DAO.
The 
dao install
 command will create an instance of the app and assign permissions to the main account to perform all the protected actions in the app.
Options:
--app-init
: Name of the function that will be called to initialize an app. If you want to skip app initialization (which is not generally recommended), you can do it by set it to 
none
. By default it will initialize the app using 
initialize
 function.
--app-init-args
: Arguments for calling the app init function. To use arrays use the following format 
["'0xB24b...73a7', '0xB24b...73a7'"]
.
--set-permissions
: Whether to set permissions in the app. Set it to 
open
 to allow 
ANY_ENTITY
 on all roles.
Note

All app instances of the same app in a DAO must run the same version, so installing an app with a version will effectively upgrade all app instances to this version.
dao upgrade
The 
dao upgrade
 command upgrades all instances of an app to a newer version.
dao upgrade <dao-addr> <app-apm-repo> [repo-version]
dao-addr
: The main address of the DAO (Kernel).
app-apm-repo
: The repo name of the app being upgraded (e.g. 
voting
 or 
voting.aragonpm.eth
).
repo-version
: Version of the repo that the app will be upgraded to; can be a version number or 
latest
 for the newest published version (defaults to 
latest
).
aragonOS protects against having different instances of a particular app running with different versions (e.g. all the Voting app instances run the same version). Performing a 
dao upgrade
 will upgrade all instances of the app to the version specified.
dao exec
Performs transactions in your DAO directly from aragonCLI. It supports 
transaction pathing
 so if your account cannot perform the action directly it will try to find how to do it (e.g. creating a vote).
dao exec <dao-addr> <app-proxy-addr> <method> [argument1 ... argumentN]
dao-addr
: The main address of the DAO (Kernel).
app-proxy-addr
: The address of the app where the action is being performed. You can find the proxy address by checking 
dao apps
.
method
: Name of the method being executed in the app (e.g. 
withdrawTokens
).
arguments
: The arguments that the method will be executed with (each separated by a space).
dao act
Provides some syntax sugar over 
dao exec
 for executing actions using Agent app instances in a DAO.
dao act <agent-proxy> <target-addr> [method] [argument1 ... argumentN]
agent-proxy
: Address of the Agent app proxy.
target-addr
: Address where the action is being executed.
method
: The 
full signature
 of the method we wish to execute in either the external contract or the app we specified, note that by the full signature we mean the 
human readable function signature
 (e.g. 
vote(unint256,bool,bool)
).
arguments
: The arguments that the method will be executed with (each separated by a space).
Options:
--call-data
: Raw call data.
--eth-value
: Amount of ETH from the contract that is sent with the action.
dao token
Commands used to create and interact with the tokens your DAO will use.
dao token new
Create a new 
MiniMe
 token.
dao token new <token-name> <symbol> [decimal-units] [transfer-enabled] [token-factory-address]
token-name
: Full name of the new Token.
symbol
: Symbol of the new Token.
decimal-units
: Total decimal units the new token will use. Defaults to 
18
.
transfer-enabled
: Whether the new token will have transfers enabled. Defaults to 
true
.
token-factory-address
: Address of a MiniMe Token Factory deployed on the network. Defaults to an existing Minime Factory address for Rinkeby and Mainnet. Defaults to 
0xA29EF584c389c67178aE9152aC9C543f9156E2B3
 on Mainnet and 
0xad991658443c56b3dE2D7d7f5d8C68F339aEef29
 on Rinkeby.
dao token change-controller
Change the controller of a MiniMe token.
dao token change-controller <token-addr> <new-controller-addr>
token-addr
: Address of the token.
new-controller-addr
: Address of the new controller.
dao acl
Used to inspect the ACL state in a DAO to check its permissions.
dao acl <dao-addr>
dao-addr
: The main address of the DAO (Kernel).
dao acl create
Used to create a permission in the ACL. Can only be used if the permission hasn't been created before. The 
manager
 of the permission can use 
dao acl grant
 and 
dao acl revoke
 to manage the permission.
dao acl create <dao-addr> <app-proxy-addr> <role> <entity> <manager>
dao-addr
: The main address of the DAO (Kernel).
app-proxy-addr
: The address of the app whose permissions are being managed. You can find the proxy address by checking 
dao apps
.
role
: The identifier for the role. Can be the 
bytes32
 identifier of the role or its name (e.g. 
INCREMENT_ROLE
).
entity
: The address of the entity that is being granted the permission by creating it.
manager
: The address of the entity that will be able to grant that permission or revoke it.
dao acl grant
Used to grant a permission in the ACL.
dao acl grant <dao-addr> <app-proxy-addr> <role> <entity> [params...]
dao-addr
: The main address of the DAO (Kernel).
app-proxy-addr
: The address of the app whose permissions are being managed. You can find the proxy address by checking 
dao apps
.
role
: The identifier for the role. Can be the 
bytes32
 identifier of the role or its name (e.g. 
INCREMENT_ROLE
).
entity
: The address of entity that is being granted the permission.
params
: ACL parameters, with the following syntax: 
"<id>,<op>,<value>"
. Multiple parameters must be separated by spaces. See the ACL 
documentation
 for the list of available operators.

Examples:
"0,GT,2"
"2,EQ,0xC7f8dDbc7B3BFd432dEAc0CA270110467EcE01c3"
"LOGIC_OP_PARAM_ID,OR,(1,2)"
 
"0,LT,4"
 
"1,EQ,42"
"LOGIC_OP_PARAM_ID,IF_ELSE,(1,2,3)"
 
"BLOCK_NUMBER_PARAM_ID,GT,1000"
 
"0,EQ,42"
 
"0,EQ,0"
dao acl revoke
Used to revoke a permission in the ACL.
dao acl revoke <dao-addr> <app-proxy-addr> <role> <entity>
dao-addr
: The main address of the DAO (Kernel).
app-proxy-addr
: The address of the app whose permissions are being managed. You can find the proxy address by checking 
dao apps
.
role
: The identifier for the role. Can be the 
bytes32
 identifier of the role or its name (e.g. 
INCREMENT_ROLE
).
entity
: The address of entity that is being revoked the permission.
dao acl set-manager
Used to change the manager of a permission in the ACL.
dao acl set-manager <dao-addr> <app-proxy-addr> <role> <manager>
dao-addr
: The main address of the DAO (Kernel).
app-proxy-addr
: The address of the app whose permissions are being managed. You can find the proxy address by checking 
dao apps
.
role
: The identifier for the role. Can be the 
bytes32
 identifier of the role or its name (e.g. 
INCREMENT_ROLE
).
manager
: The new manager for the permission.
dao acl remove-manager
Used to remove the manager of a permission in the ACL. The permission can be created again after removing its manager.
dao acl remove-manager <dao-addr> <app-proxy-addr> <role>
dao-addr
: The main address of the DAO (Kernel).
app-proxy-addr
: The address of the app whose permissions are being managed. You can find the proxy address by checking 
dao apps
.
role
: The identifier for the role. Can be the 
bytes32
 identifier of the role or its name (e.g. 
INCREMENT_ROLE
).
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
Main commands
Next
APM commands
Last modified 
7mo ago
Copy link
On this page
dao new
dao apps
dao id assign
dao install
dao upgrade
dao exec
dao act
dao token
dao acl









---PAGE 76---












APM commands - Aragon Developer Documentation




















Links
APM commands
The 
aragon apm
 commands are the easiest way to 
manage aragonPM repositories
.
aragon apm packages
Lists all the packages in a apm registry.
aragon apm packages [apmRegistry]
apmRegistry
: The registry to inspect. Defaults to 
aragonpm.eth
.
aragon apm info
Shows information about a repository.
aragon apm info <apmRepo> [apmRepoVersion]
apmRepo
: Name of the APM repository.
apmRepoVersion
: Version of the repo. Defaults to 
latest
.
aragon apm publish
The 
aragon apm publish
 command publishes a new version to the aragonPM repo. Check the 
How to publish an Aragon App to aragonPM
 guide to learn more about the publish workflow.
aragon apm publish <bump> [contract]
bump
: Type of bump (major, minor or patch) or version number.
contract
: (optional) The address or name of the contract to publish in this version. If it isn't provided, it will default to the contract specified in the 
arapp.json
 file.
Note

Changes to the contract can only be published with a major version bump. Minor and patch versions are only for frontend changes.
If a minor or patch version is being published then the command can be run with the 
--only-content
 flag which will skip compiling the contracts.
You can target a particular directory to publish, using 
--files
. By default we only include 
artifact.json
, 
code.sol
 and 
manifest.json
.
We always publish apps with:
aragon apm publish <version> --environment <environment> --files app/build
The command has the following parameters:
--only-content
: For minor and patch upgrades; whether to skip contract compilation, deployment and contract artifact generation.
--only-artifacts
: Whether just generate artifacts file without publishing.
--init
: Arguments to be passed to contract constructor on deploy. Need to be separated by a space. The 
@ARAGON_ENS
 alias can be used and it will be replaced by the address of the ENS registry in the devchain.
--provider
: The provider where the files of the package will be published to. Defaults to 
ipfs
.
--files
: The path to the files that will be published. Defaults to the current directory.
--ignore
: A gitignore pattern of files to ignore. Specify multiple times to add multiple patterns. Defaults to just the 
node_modules
 directory.
--publish-dir
: The path to the directory where all the files and generated artifacts will be copied to before publishing. If it is not specified, it will create a temporary directory.
--build
: A flag to specify whether the webapp should be built while publishing, running the script specified in 
build-script
 of 
package.json
. Defaults to 
true
.
--build-script
: The name of the NPM script in your app that will be used for building the webapp.
--prepublish
: A flag to specify whether to run a prepublish script specified in 
prepublish-script
 of 
package.json
. Defaults to 
true
.
--prepublish-script
: The name of the NPM script in your app that will be run before publishing the app. Defaults to 
prepublishOnly
.
--http
: The URI for the HTTP server that will be serving your app files (e.g. localhost:1234). See 
instructions on running from HTTP 
for more information.
--http-served-from
: Path to the directory that the HTTP server exposes (e.g. ./dist). Some artifacts are generated and placed in this directory during the publishing process of your app.
--ipfs-check
: Whether to have start IPFS if not started. Defaults to 
true
.
--reuse
: Whether to reuse the previous version contract and skip deployment on non-major versions. Defaults to 
false
.
--propagate-content
: Whether to propagate the content once published. Defaults to 
true
.
--skip-confirmation
: Whether to skip the confirmation step. Defaults to 
false
.
aragon apm extract-functions
Extract function information from a Solidity file.
aragon apm extract-functions [contract]
contract
: Path to the Solidity file to extract functions from.
Options:
--output
: Path of the directory where the output file will be saved to.
aragon apm versions
Shows all the previously published versions of a given repository.
aragon apm versions [apmRepo]
apmRepo
: Name of the APM repository. Defaults to the current project's repo (defined in 
arapp.json
).
aragon apm grant
Grant an address or a group of addresses the permission to create new versions in your package (defined in 
arapp.json
), by interacting directly with the ACL, without performing transaction pathing.
aragon apm grant [addr1 ... addrN]
addresses
: The addresses being granted the permission to publish to the repo.
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
DAO commands
Next
IPFS commands
Last modified 
7mo ago
Copy link
On this page
aragon apm packages
aragon apm info
aragon apm publish
aragon apm extract-functions
aragon apm versions
aragon apm grant









---PAGE 77---












IPFS commands - Aragon Developer Documentation




















Links
IPFS commands
The 
aragon ipfs
 commands can be used to 
start an IPFS node
 configured to pin the core Aragon components, inspect hashes, and propagate files to other nodes.
aragon ipfs
Shortcut for 
aragon ipfs start
.
aragon ipfs
aragon ipfs start
Start the IPFS daemon and configure it to work with Aragon.
aragon ipfs start
aragon ipfs status
Status of the IPFS installation & daemon.
aragon ipfs status
Options:
--repo-path
: The location of the IPFS repository
aragon ipfs install
Download and install the go-ipfs binaries.
aragon ipfs install
Options:
--dist-version
: The version of IPFS that will be installed. Defaults to 
0.4.22
.
--dist-url
: The url from which to download IPFS. Defaults to 
https://dist.ipfs.io
.
--local
: Whether to install IPFS as a project dependency. Defaults 
false
.
--skip-confirmation
: Whether to skip the confirmation step. Defaults to 
false
.
aragon ipfs uninstall
Uninstall the go-ipfs binaries.
aragon ipfs uninstall
Options:
--local
: Whether to uninstall IPFS from the project dependencies. Defaults 
false
.
--skip-confirmation
: Whether to skip the confirmation step. Defaults to 
false
.
aragon ipfs propagate
Request the content and its links at several gateways, making the files more distributed within the network.
aragon ipfs propagate <cid>
Positionals:
cid
: A self-describing content-addressed identifier
aragon ipfs view
Display metadata about the content, such as size, links, etc.
aragon ipfs view <cid>
Positionals:
cid
: A self-describing content-addressed identifier
​
Do you have a question? Leave your comments here at our Discourse forum
 👇
Dev Support
Aragon Support Forum
Previous
APM commands
Next
Global configuration
Last modified 
7mo ago
Copy link
On this page
aragon ipfs
aragon ipfs start
aragon ipfs status
aragon ipfs install
aragon ipfs uninstall
aragon ipfs propagate
aragon ipfs view









---PAGE 78---












KernelStorage - Aragon Developer Documentation




















Links
KernelStorage
contract KernelStorage
Source: 
contracts/kernel/KernelStorage.sol


Previous
KernelProxy
Next
aragonCLI
Last modified 
7mo ago
Copy link









---PAGE 79---












Guidelines - Aragon Developer Documentation




















Links
Guidelines
In this section, we will explore the aragonDS main guidelines:
the layout
the color
the iconography
the typography
the illustrations
Previous
aragonDS
Next
Layout
Last modified 
7mo ago
Copy link









---PAGE 80---












Components - Aragon Developer Documentation




















Links
Components
In this section, we will give an overview of Components.
Previous
Illustrations
Next
Overview
Last modified 
7mo ago
Copy link









---PAGE 81---












Viewport - Aragon Developer Documentation






















Links
Viewport
The Viewport component can be used to get some information about the app window. It provides the viewport dimensions and a set of convenient functions to help building responsive apps.
Usage
import
 
{
 useViewport 
}
 
from
 
'@aragon/ui'
​
const
 
MyComponent
 
=
 
()
 
=>
 
{
 
const
 
{
 within
,
 below
,
 above 
}
 
=
 
useViewport
()
​
 
return
 
(
 
<
div
>
 
{
below
(
'medium'
)
 
&&
 
<
div
>
small
</
div
>
}
 
{
within
(
'medium'
,
 
'large'
)
 
&&
 
<
div
>
medium
</
div
>
}
 
{
above
(
'large'
)
 
&&
 
<
div
>
large
</
div
>
}
 
</
div
>
 
)
}
Demonstration
Current viewport size: 
large
Props
throttle
Type: 
Number
Default value: 
100
Change the throttle wait time.
children
Type: 
Function
A render prop that provides an object with everything needed. An object is passed to the function, with the following properties:
width
Type: 
Number
The current width of the viewport.
Example:
function
 
App
()
 
{
 
const
 
{
 width 
}
 
=
 
useViewport
()
 
return
 
<
MyComponent
 
compact
=
{
width 
<
 
400
}
 
/>
}
height
Type: 
Number
The current height of the viewport.
within(min, max)
Type: 
Function
Returns 
true
 if the viewport 
width
 is between 
min
 and 
max
, 
false
 otherwise. 
min
 is included while 
max
 is excluded. This is to prevent collisions between two breakpoints (see example).
min
 and 
max
 can be any number, or one of the available breakpoints (see 
breakpoint
 below).
If 
-1
 is passed as either 
min
 or 
max
, there will be no minimum or maximum. Note: see 
above()
 and 
below()
 for a more concise way to do this.
Example:
const
 
{
 within 
}
 
=
 
useViewport
()
return
 
(
 
<
div
>
 
<
p
>
{
within
(
400
,
 
500
)
 
?
 
'viewport width within 400 and 500'
 
:
 
'nope'
}
</
p
>
 
{
within
(
'min'
,
 
'small'
)
 
&&
 
<
div
>
A
</
div
>
}
 
{
within
(
'small'
,
 
'medium'
)
 
&&
 
<
div
>
B
</
div
>
}
 
{
within
(
'medium'
,
 
'large'
)
 
&&
 
<
div
>
C
</
div
>
}
 
{
within
(
'large'
,
 
-
1
)
 
&&
 
<
div
>
D
</
div
>
}
 
</
div
>
)
above(x)
Type: 
Function
Returns 
true
 if the viewport 
width
 is above 
x
, 
false
 otherwise.
x
 can be any number, or one of the available breakpoints (see 
breakpoint
 below).
below(x)
Returns 
true
 if the viewport 
width
 is below 
x
, 
false
 otherwise.
x
 can be any number, or one of the available breakpoints (see 
breakpoint
 below).
Example:
const
 
{
 below
,
 above 
}
 
=
 
useViewport
()
return
 
(
 
<
div
>
 
{
above
(
'medium'
)
 
&&
 
<
div
>
A
</
div
>
}
 
{
below
(
'medium'
)
 
&&
 
<
div
>
B
</
div
>
}
 
</
div
>
)
breakpoint
An object that contains the number values of the different recommended breakpoints. It can be useful to set these values in CSS, for example.
Available breakpoints: 
"min"
 (320), 
"small"
 (540), 
"medium"
 (768), 
"large"
 (1170).
Example:
const
 
{
 breakpoint 
}
 
=
 
useViewport
()
return
 
(
 
<
div
 
css
=
{
`
      min-width: 
${
breakpoint
.
min
}
;
 
`
}
 
>
 
<
MyComponent
 
compact
=
{
width 
<
 breakpoint
.
medium
}
 
/>
 
</
div
>
)
Previous
RootPortal
Next
aragonDS
Last modified 
7mo ago
Copy link
On this page
Usage
Demonstration
Props









---PAGE 82---












README - Aragon Developer Documentation




















Links
README
​
Website
 | 
Documentation
 | 
Chat
​
​
​
 
​
​
 
​
​
 
​
​
 
​
​
 
​
​
Aragon Govern
Govern is Aragon's new Smart Contract system to manage unstoppable organizations on the blockchain in an efficient and decentralized manner. It's architectured using ERC3000, the up and coming governance standard.
🚨 Security Review Status: pre-audit
The code in 
this repository
 has 
not
 been audited.
📚 Read the documentation
Read the documentation if you have any doubts about the high-level overview of Govern, or if you want to know more about how everything works under the hood.
👋 Get started contributing with a 
good first issue
​
Before explaining how you can contribute, It's worth mentioning that we use 
develop
 branch as the default one. This makes it easier for us to have all the latest, development changes without affecting the current production version. Note: we don't use 
release
 branches to make the development process a little bit easier! Other notes:
Pushing to 
develop
 branch via PR deploys changes to testing environments (currently only Rinkeby testnet).
Pushing to 
master
 branch via PR from 
develop
 deploys changes to production servers (Ethereum mainnet).
Pushing to 
master|develop
 directly will be restricted to make sure the PR's are reviewed.
Creating PRs end up in relation to 
develop
 by default.
Don't be shy to contribute even the smallest tweak! Everyone will be nice and helpful to beginners to help you get started!
Structure
This repo uses Lerna and yarn workspaces to bootstrap itself, and is divided into multiple independent sub-packages:
​
erc3k
: Aragon's reference implementation of 
ERC3000
, the up and coming governance standard.
​
Govern.js
: Govern's official JS wrapper for creating seamless DAO experiences.
​
Govern Console
: No-frills, forkable, extensible power user / developer UI tool for interacting with and visualizing low level information about Govern DAOs. Can be found on Github 
here
.
​
Govern Contract Utils
: Set of all libraries and utilities used by the core Govern contracts.
​
Govern Core
: The core set of Aragon Govern contracts.
​
Govern Create
: Set of templates used to create new Govern instances.
​
Govern Discord
: Govern-native Discord bot for DAOs.
​
Govern Server
: Server powering Govern.js and the Govern API to enable Web2-like experiences for DAOs.
​
Govern Subgraph
: Govern's official Subgraph, which tracks DAOs registered on the A1-deployed ERC3000Registry.
Deployed instances
To use Govern, feel free to deploy your own registries and factories, but using the official registries ensures that our tooling will detect your organization properly.
​
Mainnet
📜 GovernRegistry: 
0xf2b7D096cd34F228A6413e276132C21D98b19882
​
🏭 GovernBaseFactory: 
0x8bF05ce17B30f8C73B06e49f67076f944687c967
​
Rinkeby
📜 GovernRegistry: 
0xf46253ef29FaedAbf63AA8cA6c0A41CbbdC93948
​
🏭 GovernBaseFactory: 
0x46013753f3a02ab4239cA936632E6C6B39235CCE
​
Help shape Aragon Govern
Discuss in 
Aragon Forum
​
Join the 
Aragon dev-space channel
 on Discord.
Previous
Aragon Govern
Next
Introduction
Last modified 
7mo ago
Copy link
On this page
Aragon Govern
Structure
Deployed instances
Help shape Aragon Govern









---PAGE 83---












Introduction - Aragon Developer Documentation




















Links
Introduction
WARNING
Aragon Govern is 
beta software 
which is 
NOT MAINTAINED
 anymore. 
It's a really cool product though with innovative and nifty smart contracts around 
Optimistic Governance
. So although you might run into an 
error
 🐲 here and there, the documentation is definitely worth the read and the play!
And welcome to connect with us through 
Discord
 or our technical 
forum
!
Welcome to Aragon Govern's documentation!
Aragon Govern is software for creating and governing organizations such as DeFi projects, open source projects, gaming guilds, cooperatives, nonprofits, clubs, companies, and any other type of organization you can imagine. It's Aragon's implementation of ERC-3000, the standard for binding off-chain voting.
Along with off-chain voting solutions like 
Snapshot
 it allows you to 
govern
 all parts of your project, even if not completely decentralized, in an easy manner, also allowing for flexibility and extensions when needed.
The Aragon Govern product can be found here: 
https://govern.aragon.org/
​
The 
Overview
 section provides more insight over Govern and all of its tooling.
The 
Developers
 section gives an overview of all the individual pieces of Govern.
Previous
README
Next
Concepts and background
Last modified 
7mo ago
Copy link









---PAGE 84---












Deployments - Aragon Developer Documentation




















Links
Deployments
In this section, we go through two:
a Mainnet deployment,
a Rinkeby deployment.
Previous
Smart contracts breakdown
Next
Mainnet
Last modified 
7mo ago
Copy link









---PAGE 85---












Packages - Aragon Developer Documentation




















Links
Packages
In this section, we go through the main packages:
​
ERC 3k
,
​
Govern Console
,
​
Govern contract utils
,
​
Types
,
​
govern-create
,
​
Govern Server
,
​
govern-subgraph
,
​
govern-token
,
​
govern.js
.
Previous
Rinkeby
Next
ERC 3k
Last modified 
7mo ago
Copy link









---PAGE 86---












govern.js - Aragon Developer Documentation




















Links
govern.js
The 
JavaScript client API
 for the Govern server.
​
Documentation
​
Previous
govern-token
Next
Aragon Vocdoni
Last modified 
7mo ago
Copy link









