---PAGE 1---










Host perspective | Blockchain OS Documentation - Cartesi
























Skip to main content
Overview
Cartesi's reference off-chain implementation of Cartesi Machines is based on software emulation.
Command-line interface
In the simplest usage scenario, the cartesi-machine command-line utility can be used to define a Cartesi Machine and run it until it halts.
Lua interface
This entire chapter is for advanced users only, since typical users of the Cartesi platform will likely never need to programmatically control a Cartesi Machine.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 2---










Cartesi Compute | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Cartesi Compute SDK
​
Overview
How it works
Architecture
Wallets
Execution timeline
Machines off-chain
Machines on-chain
On-chain API
Instantiate
Drives
Provider drives
Logger drives
Topologies
Supported networks
Cartesi Compute Tutorials
​
Introduction
General requirements
Cartesi Compute SDK Environment
Hello World DApp
​
Creating basic DApp
Hello World machine
Instantiating computation
Retrieving result
Deploying and running
Calculator DApp
​
Calculator project
Calculator machine
Full Calculator DApp
Generic Script DApp
​
Generic Script project
Custom root file-system
Generic Script machine
Full Generic Script DApp
GPG Verify DApp
​
GPG Verify project
Using ext2 files and GPG
GPG Verify machine
Full GPG Verify DApp
Processing larger files
Dogecoin Hash DApp
​
Dogecoin Hash project
Computing scrypt using C
Dogecoin Hash machine
Full Dogecoin Hash DApp
Cartesi Compute SDK
Cartesi Compute Tutorials
Hello World DApp
Calculator DApp
Generic Script DApp
GPG Verify DApp
Dogecoin Hash DApp
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 3---










Cartesi Compute | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Cartesi Compute SDK
​
Overview
How it works
Architecture
Wallets
Execution timeline
Machines off-chain
Machines on-chain
On-chain API
Instantiate
Drives
Provider drives
Logger drives
Topologies
Supported networks
Cartesi Compute Tutorials
​
Introduction
General requirements
Cartesi Compute SDK Environment
Hello World DApp
​
Creating basic DApp
Hello World machine
Instantiating computation
Retrieving result
Deploying and running
Calculator DApp
​
Calculator project
Calculator machine
Full Calculator DApp
Generic Script DApp
​
Generic Script project
Custom root file-system
Generic Script machine
Full Generic Script DApp
GPG Verify DApp
​
GPG Verify project
Using ext2 files and GPG
GPG Verify machine
Full GPG Verify DApp
Processing larger files
Dogecoin Hash DApp
​
Dogecoin Hash project
Computing scrypt using C
Dogecoin Hash machine
Full Dogecoin Hash DApp
Cartesi Compute SDK
Cartesi Compute Tutorials
Hello World DApp
Calculator DApp
Generic Script DApp
GPG Verify DApp
Dogecoin Hash DApp
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 4---










Lua interface | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
danger
This entire chapter is for advanced users only, since typical users of the Cartesi platform will likely never need to programmatically control a Cartesi Machine.
The Lua interface to Cartesi Machines is available from the 
cartesi
 Lua module.
In a properly setup installation (such as what is available in the playground Docker image), the module can be loaded with the 
require
 function
-- Load the Cartesi module
local
 cartesi 
=
 require
"cartesi"
The most important field in the module is the 
cartesi.machine
 
“
class
”
, used to instantiate new local Cartesi Machines.
A Cartesi Machine instance is defined by its 
organization
 and the 
contents
 of its state.
The organization specifies the amount of RAM and the layout of a number of flash drives (between 0 and 8) and rollup memory ranges.
To support Cartesi Machine's transparency, flash drives are mapped into the machine's 64-bit physical memory address space.
The layout defines each flash drive's start and length in the address space.
The contents of the state include the values stored in ROM, RAM, and in all flash drives and rollup memory ranges, in addition to the values of all processor registers and device-specific state.
Cartesi Machines can be instantiated directly from a configuration structure, or loaded from a persistent state stored as a directory on disk.
Instantiation by configuration
​
machine_config 
::
=
 
{
  rom 
::
=
 rom_config
,
  ram 
::
=
 ram_config
,
  flash_drive 
::
=
 
{
    
[
1
]
 
::
=
 memory_range_config
,
 
-- flash drive 0
    
[
2
]
 
::
=
 memory_range_config
,
 
-- flash drive 1
    
...
    
[
n
]
 
::
=
 memory_range_config  
-- flash drive n <= 7
  
}
,
  processor 
::
=
 processor_config
,
  clint 
::
=
 clint_config
,
  htif 
::
=
 htif_config
,
  rollup 
::
=
 rollup_config
,
}
rom_config 
::
=
 
{
    bootargs 
::
=
 string
,
    image_filename 
::
=
 string
}
ram_config 
::
=
 
{
    length 
::
=
 number
,
    image_filename 
::
=
 string
}
htif_config 
::
=
 
{
    fromhost 
::
=
 number
,
    tohost 
::
=
 number
,
    console_putchar 
::
=
 boolean
,
    yield_manual 
::
=
 boolean
,
    yield_automatic 
::
=
 boolean
}
clint_config 
::
=
 
{
    mtimecmp 
::
=
 number
,
}
rollup_config 
::
=
 
{
  rx_buffer 
:
=
 memory_range_config
,
  tx_buffer 
:
=
 memory_range_config
,
  input_metadata 
:
=
 memory_range_config
,
  voucher_hashes 
:
=
 memory_range_config
,
  notice_hashes 
:
=
 memory_range_config
}
processor_config 
::
=
 
{
  x 
=
 
{
    
[
1
]
  
::
=
 number
,
 
-- register x1
    
[
2
]
  
::
=
 number
,
 
-- register x2
    
...
    
[
31
]
 
::
=
 number
,
 
-- register x31
  
}
,
  pc 
::
=
 number
,
  mvendorid 
::
=
 number
,
  marchid 
::
=
 number
,
  mimpid 
::
=
 number
,
  mcycle 
::
=
 number
,
  minstret 
::
=
 number
,
  mstatus 
::
=
 number
,
  mtvec 
::
=
 number
,
  mscratch 
::
=
 number
,
  mepc 
::
=
 number
,
  mcause 
::
=
 number
,
  mtval 
::
=
 number
,
  misa 
::
=
 number
,
  mie 
::
=
 number
,
  mip 
::
=
 number
,
  medeleg 
::
=
 number
,
  mideleg 
::
=
 number
,
  mcounteren 
::
=
 number
,
  stvec 
::
=
 number
,
  sscratch 
::
=
 number
,
  sepc 
::
=
 number
,
  scause 
::
=
 number
,
  stval 
::
=
 number
,
  satp 
::
=
 number
,
  scounteren 
::
=
 number
,
  ilrsc 
::
=
 number
,
  iflags 
::
=
 number
}
,
memory_range_config 
::
=
 
{
  start 
::
=
 number
,
  length 
::
=
 number
,
  image_filename 
::
=
 string
,
  shared 
::
=
 boolean
}
The 
rom
 entry in 
machine_config
 is a table with two fields.
Field 
bootargs
 gives a string of at most 2KiB that will be copied into the end (the last 2KiB) of ROM.
Field 
image_filename
 gives the file name of an image that will be loaded into the beginning of ROM.
This is where the ROM image 
rom.bin
 generated by the 
Emulator SDK
 is typically loaded.
This is also where the machine starts execution, i.e., where the processor's program counter initially points to.
This ROM image generates the 
devicetree
 that describes the hardware to Linux, passes the 
bootargs
 string as the kernel command-line parameters, then cedes control to the RAM image.
The 
ram
 entry in 
machine_config
 also has two fields.
Field 
length
 gives the amount of RAM in bytes (RAM always starts at offset 
0x80000000
).
This length should be a multiple of 4Ki, the length of a RISC-V memory page.
Field 
image_filename
 gives the filename of an image that will be loaded at the start of RAM.
This is where the RAM image 
linux.bin
 generated by the 
Emulator SDK
 (which contains the Berkeley Boot Loader linked with the Linux kernel) is typically loaded.
The 
flash_drive
 entry in 
machine_config
 is a list of 
memory_range_config
 entries, each of which contain a flash drive configuration.
Each 
memory_range_config
 contains four fields.
Fields 
start
 and 
length
 give the start and length of the flash drive in the machine's address space.
Once again, the length must be a multiple of 4Ki, the length of a memory page.
Field 
image_filename
 gives the file name of an image that will be 
mapped
 to this region.
This is different from the ROM and RAM image files, which are simply copied into the Cartesi Machine memory, which has been allocated from the host memory.
Flash drives use memory mapping because their image files can be very large.
Mapping them instead of copying them saves host memory, as well as the time it would take to load the files from disk to host memory.
Since flash drive image files are mapped, their sizes on disk must exactly match the 
length
 of the flash drive they are 
backing
.
Field 
shared
 contains a Boolean value that specifies whether changes to the flash drive that happen inside the target reflect in the image file that resides in the host file-system as well.
If set to 
true
, the image file will be modified accordingly.
This is useful when a flash drive will hold the result of a computation.
If set to 
false
 (the default), target modifications to the flash drive are 
not
 propagated to the image file that resides in the host filesystem.
I.e., even though the flash drives may be read/write from the target perspective, the image file in the host is left unmodified.
The 
htif
 entry in 
machine_config
 has four fields, two of which are used only in rare occasions.
The most commonly used field is the Boolean 
console_getchar
.
When set to 
true
 (the default is 
false
), it instructs the emulator to monitor terminal input in the host and make it available to the target via the HTIF device.
This is used in interactive sessions during prototyping, and should never be used when verifiability is needed.
The 
yield_automatic
 and 
yield_manual
 Booleans instruct the emulator to honor 
automatic
 yield and 
manual
 yield commands received by the HTIF Yield device, respectively.
Target applications use these commands to notify the host that the application has just produced output data for collection, or is ready to accept new input data for processing.
There are two differences between the two types of yield command.
First, an automatic yield sets the 
X
 flag in the 
iflags
 control and status register (CSR), whereas the manual yield sets the 
Y
 flag.
Second, the 
X
 flag is 
automatically
 reset when the machine is resumed after an automatic yield.
In contrast, 
Y
 flag must be 
manually
 reset after a manual yield, or the machine will not advance at all when resumed.
Manual and automatic yields are the mechanism that control Cartesi Rollups input and output with Rolling Cartesi Machines.
The fields 
tohost
 and 
fromhost
 in 
htif
 allow for the overriding of the default initial values of these CSRs (control and status registers).
The 
rollup
 entry in 
machine_config
 has five fields, each holding a

memory_range_config
 entry.
The Cartesi Machine support for Cartesi Rollups involves a variety of memory ranges.
The first two, 
rx_buffer
 and 
tx_buffer
 are used to send data in and out of the machine, respectively.
For example, the input payload to an advance-state request and the query payload to an inspect-state request are written to the 
rx_buffer
 memory range.
Conversely, vouchers, notices, reports, and exceptions are written to the 
tx_buffer
 memory range.
The input metadata for advance-state requests are written to the 
input_metadata
 memory range.
The 
voucher_hashes
 and 
notice_hashes
 memory ranges are arrays on which the hash of each voucher or notice emitted during processing of an advance-state are appended, respectively.
For more details on how exactly these memory ranges are used, please read the 
architecture section
 under the target perspective.
The remaining entries in the 
machine_config
 are used only in rare occasions.
The devices and processor have a variety of control and status registers (CSRs), in addition to processor's general-purpose registers.
Most of these are defined in volumes 
1 and 2
 of the  ISA specification.
The Cartesi-specific additions are described under the 
architecture section
 under the target perspective.
The 
clint
 entry has a single field, 
mtimecmp
, which allows for the overriding of the default initial value of this CSR.
Similarly, the fields in the 
processor
 entry allow for the overriding of the default initial value of all general-purpose registers and CSRs in the processor.
Configuration from command-line
​
The 
cartesi-machine
 command-line utility can be used to output machine configurations for Cartesi Machines that can be used directly by the Lua 
cartesi.machine
 constructor.
Recall from an 
earlier example
 that the 
cartesi-machine
 command
cartesi-machine 
\
    --rom-image
=
"/opt/cartesi/share/images/rom.bin"
 
\
    --ram-length
=
64Mi 
\
    --ram-image
=
"/opt/cartesi/share/images/linux.bin"
 
\
    --flash-drive
=
"label:root,filename:/opt/cartesi/share/images/rootfs.ext2"
 
\
    --max-mcycle
=
0
 
\
    --store-config 
\
    -- 
"ls /bin"
builds a Cartesi Machine that, when run, lists the contents of the 
/bin/
 directory before gracefully halting.
The image files 
rom.bin
, 
linux.bin
, and 
rootfs.ext2
 are generated by the 
Emulator SDK
, and are available in the playground Docker image in directory 
/opt/cartesi/share/images/
.
The command-line option 
--max-mcycle=0
 instructs the utility to stop execution at cycle 0 (
mcycle
 is a CSR that starts at 0 and is advanced at every instruction cycle), i.e., before the machine even starts running.
The key command-line option is 
--store-config
, which causes the emulator to print the corresponding configuration to the standard output.
To store directly to a file, use the 
--store-config=<filename>
 instead, in which case, the 
--load-config=<filename>
 command-line option can be used to load the stored config.
return
 
{
  processor 
=
 
{
    x 
=
 
{
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
      
0x0
,
 
-- default
    
}
,
    iflags 
=
 
0x18
,
 
-- default
    ilrsc 
=
 
0xffffffffffffffff
,
 
-- default
    marchid 
=
 
0xc
,
 
-- default
    mcause 
=
 
0x0
,
 
-- default
    mcounteren 
=
 
0x0
,
 
-- default
    mcycle 
=
 
0x0
,
 
-- default
    medeleg 
=
 
0x0
,
 
-- default
    mepc 
=
 
0x0
,
 
-- default
    mideleg 
=
 
0x0
,
 
-- default
    mie 
=
 
0x0
,
 
-- default
    mimpid 
=
 
0x1
,
 
-- default
    minstret 
=
 
0x0
,
 
-- default
    mip 
=
 
0x0
,
 
-- default
    misa 
=
 
0x8000000000141101
,
 
-- default
    mscratch 
=
 
0x0
,
 
-- default
    mstatus 
=
 
0xa00000000
,
 
-- default
    mtval 
=
 
0x0
,
 
-- default
    mtvec 
=
 
0x0
,
 
-- default
    mvendorid 
=
 
0x6361727465736920
,
 
-- default
    pc 
=
 
0x1000
,
 
-- default
    satp 
=
 
0x0
,
 
-- default
    scause 
=
 
0x0
,
 
-- default
    scounteren 
=
 
0x0
,
 
-- default
    sepc 
=
 
0x0
,
 
-- default
    sscratch 
=
 
0x0
,
 
-- default
    stval 
=
 
0x0
,
 
-- default
    stvec 
=
 
0x0
,
 
-- default
  
}
,
  ram 
=
 
{
    length 
=
 
0x4000000
,
    image_filename 
=
 
"/opt/cartesi/share/images/linux.bin"
,
  
}
,
  rom 
=
 
{
    image_filename 
=
 
"/opt/cartesi/share/images/rom.bin"
,
    bootargs 
=
 
"console=hvc0 rootfstype=ext2 root=/dev/mtdblock0 rw quiet swiotlb=noforce mtdparts=flash.0:-(root) -- ls /bin"
,
  
}
,
  htif 
=
 
{
    tohost 
=
 
0x0
,
 
-- default
    fromhost 
=
 
0x0
,
 
-- default
    console_getchar 
=
 
false
,
 
-- default
    yield_automatic 
=
 
false
,
 
-- default
    yield_manual 
=
 
false
,
 
-- default
  
}
,
  clint 
=
 
{
    mtimecmp 
=
 
0x0
,
 
-- default
  
}
,
  flash_drive 
=
 
{
    
{
      start 
=
 
0x8000000000000000
,
      length 
=
 
0x5000000
,
      image_filename 
=
 
"/opt/cartesi/share/images/rootfs.ext2"
,
      shared 
=
 
false
,
 
-- default
    
}
,
  
}
,
}
Cycles
:
 
0
The resulting configuration includes a number of default values, conveniently marked as such by the 
cartesi-machine
 utility.
It can be edited down to its essential, and stored into a file, for example as a Lua module:
config/ls-bin.lua
return
 
{
  processor 
=
 
{
    mvendorid 
=
 
0x6361727465736920
,
    mimpid 
=
 
0x1
,
    marchid 
=
 
0xc
,
  
}
,
  ram 
=
 
{
    length 
=
 
0x4000000
,
    image_filename 
=
 
"/opt/cartesi/share/images/linux.bin"
,
  
}
,
  rom 
=
 
{
    image_filename 
=
 
"/opt/cartesi/share/images/rom.bin"
,
    bootargs 
=
 
"console=hvc0 rootfstype=ext2 root=/dev/mtdblock0 rw quiet swiotlb=noforce mtdparts=flash.0:-(root) -- ls /bin"
,
  
}
,
  flash_drive 
=
 
{
    
{
      start 
=
 
0x8000000000000000
,
      length 
=
 
0x5000000
,
      image_filename 
=
 
"/opt/cartesi/share/images/rootfs.ext2"
,
    
}
,
  
}
,
}
The only required values in the 
processor
 configuration are the 
mvendorid
, 
mimpid
, 
marchid
 CSRs.
These are used to ensure the emulator version matches the version the configuration was generated for.
If the emulator detects a mismatch, instantiation fails.
During prototyping, these fields can be set to 
-1
 to instantiate a machine with the values it expects.
In production code, they should be hard-coded to match the release of the emulator in use.
Note how the utility automatically sets the ROM 
bootargs
 to include several kernel parameters.
The ones seen in the example have the following meaning:
console=hsvc0
 sets the device to be used as console;
rootfstype=ext2
 sets the root filesystem type;
root=/dev/mtdblock0
 sets the device where the root filesystem can be found;
rw
 instructs the kernel to mount the root filesystem read-write;
quiet
 stops the kernel from printing initialization messages;
swiotlb=noforce
 prevents the kernel from reserving memory for DMA bounce buffers.
The two remaining parameters deserve some elaboration.
The 
mtdparts=flash.0:-(root)
 section is a kernel command-line parameter that provides the kernel with partitioning information for the flash drives.
The format for the parameter is documented in the 
source-code
 for the kernel module responsible for parsing it.
Here, 
(root)
 gives the partition label, and 
flash.0
 refers to the first flash drive.
The 
/bin/ls /bin
 command appears in the ROM 
bootargs
 after the 
--
 separator.
The Linux kernel passes anything that appears after the separator, verbatim, to 
/sbin/init
.
The Cartesi-provided 
/sbin/init
 then uses this information to run the desired command.
Recall the command-line utility can also run Cartesi Machines with additional drives.
In that case, the resulting configuration automatically includes an entry for them in the 
mtdparts
 kernel command-line argument.
Repeating another 
earlier example
mkdir
 foo
echo
 Hello world 
>
 foo/bar.txt
tar
 
\
    --sort
=
name 
\
    --mtime
=
"2022-01-01"
 
\
    --owner
=
1000
 
\
    --group
=
1000
 
\
    --numeric-owner 
\
    -cf foo.tar 
\
    --directory
=
foo 
.
genext2fs 
\
    -f 
\
    -b 
1024
 
\
    -a foo.tar 
\
    foo.ext2
cartesi-machine 
\
    --flash-drive
=
label:
"foo,filename:foo.ext2"
 
\
    --max-mcycle
=
0
 
\
    --store-config 
\
    -- 
"cat /mnt/foo/bar.txt"
produces the corresponding machine configuration.
This can be edited down to its essential, and stored into a file, for example as a Lua module:
config/cat-foo-bar.lua
return
 
{
  processor 
=
 
{
    mvendorid 
=
 
0x6361727465736920
,
    mimpid 
=
 
0x1
,
    marchid 
=
 
0xc
,
  
}
,
  ram 
=
 
{
    image_filename 
=
 
"/opt/cartesi/share/images/linux.bin"
,
    length 
=
 
0x4000000
,
  
}
,
  rom 
=
 
{
    bootargs 
=
 
"console=hvc0 rootfstype=ext2 root=/dev/mtdblock0 rw quiet swiotlb=noforce mtdparts=flash.0:-(root);flash.1:-(foo) -- cat /mnt/foo/bar.txt"
,
    image_filename 
=
 
"/opt/cartesi/share/images/rom.bin"
,
  
}
,
  flash_drive 
=
 
{
    
{
      image_filename 
=
 
"/opt/cartesi/share/images/rootfs.ext2"
,
      start 
=
 
0x8000000000000000
,
      length 
=
 
0x5000000
,
    
}
,
    
{
      image_filename 
=
 
"foo.ext2"
,
      start 
=
 
0x9000000000000000
,
      length 
=
 
0x100000
,
    
}
,
  
}
,
}
Note the entry in 
mtdparts
 that causes 
flash.1
, the flash drive containing the 
foo.ext2
 file-system, to receive the label 
foo
.
When the Cartesi-provided 
/sbin/init
 detects a valid file-system in the flash drive, it automatically uses the label to mount it as 
/mnt/foo
.
It is there that the command 
cat /mnt/foo/bar.txt
 finds the file to dump to the console.
Additional sample configurations
​
Here are the (simplified) configurations for the other examples from the documentation of the 
cartesi-machine
 command-line utility.
A Cartesi Machine that has nothing to do:
cartesi-machine 
\
    --max-mcycle
=
0
 
\
    --store-config
config/nothing-to-do.lua
return
 
{
  processor 
=
 
{
    mvendorid 
=
 
0x6361727465736920
,
 
-- cartesi.machine.MVENDORID
    mimpid 
=
 
0x1
,
 
-- cartesi.machine.MIMPID
    marchid 
=
 
0xc
,
 
-- cartesi.machine.MARCHID
  
}
,
  ram 
=
 
{
    image_filename 
=
 
"/opt/cartesi/share/images/linux.bin"
,
    length 
=
 
0x4000000
,
  
}
,
  rom 
=
 
{
    image_filename 
=
 
"/opt/cartesi/share/images/rom.bin"
,
    bootargs 
=
 
"console=hvc0 rootfstype=ext2 root=/dev/mtdblock0 rw quiet swiotlb=noforce mtdparts=flash.0:-(root)"
,
  
}
,
  flash_drive 
=
 
{
    
{
      image_filename 
=
 
"/opt/cartesi/share/images/rootfs.ext2"
,
      start 
=
 
0x8000000000000000
,
      length 
=
 
0x5000000
,
    
}
,
  
}
,
}
A Cartesi Machine that periodically reports its progress using the HTIF Yield device:
cartesi-machine 
\
    --htif-yield-automatic 
\
    --max-mcycle
=
0
 
\
    --store-config 
\
    -- 
$'for i in $(seq 0 5 1000); do yield automatic progress $i; done'
config/progress.lua
return
 
{
  processor 
=
 
{
    mvendorid 
=
 
0x6361727465736920
,
    mimpid 
=
 
0x1
,
    marchid 
=
 
0xc
,
  
}
,
  ram 
=
 
{
    length 
=
 
0x4000000
,
    image_filename 
=
 
"/opt/cartesi/share/images/linux.bin"
,
  
}
,
  rom 
=
 
{
    image_filename 
=
 
"/opt/cartesi/share/images/rom.bin"
,
    bootargs 
=
 
"console=hvc0 rootfstype=ext2 root=/dev/mtdblock0 rw quiet swiotlb=noforce mtdparts=flash.0:-(root) -- for i in $(seq 0 5 1000); do yield automatic progress $i; done"
,
  
}
,
  htif 
=
 
{
    yield_automatic 
=
 
true
,
  
}
,
  flash_drive 
=
 
{
    
{
      start 
=
 
0x8000000000000000
,
      length 
=
 
0x5000000
,
      image_filename 
=
 
"/opt/cartesi/share/images/rootfs.ext2"
,
      shared 
=
 
false
,
 
-- default
    
}
,
  
}
,
}
A Cartesi Machine that computes the value of a generic mathematical expression:
cartesi-machine 
\
    --flash-drive
=
"label:input,length:1<<12,filename:input.raw"
 
\
    --flash-drive
=
"label:output,length:1<<12,filename:output.raw,shared"
 
\
    --max-mcycle
=
0
 
\
    --store-config 
\
    -- 
$'dd status=none if=$(flashdrive input) | lua -e \'print((string.unpack("z", io.read("a"))))\' | bc | dd status=none of=$(flashdrive output)'
config/calculator.lua
return
 
{
  processor 
=
 
{
    mvendorid 
=
 
0x6361727465736920
,
 
-- cartesi.machine.MVENDORID
    mimpid 
=
 
0x1
,
 
-- cartesi.machine.MIMPID
    marchid 
=
 
0xc
,
 
-- cartesi.machine.MARCHID
  
}
,
  ram 
=
 
{
    image_filename 
=
 
"/opt/cartesi/share/images/linux.bin"
,
    length 
=
 
0x4000000
,
  
}
,
  rom 
=
 
{
    image_filename 
=
 
"/opt/cartesi/share/images/rom.bin"
,
    bootargs 
=
 
"console=hvc0 rootfstype=ext2 root=/dev/mtdblock0 rw quiet swiotlb=noforce mtdparts=flash.0:-(root);flash.1:-(input);flash.2:-(output) -- dd status=none if=$(flashdrive input) | lua -e 'print((string.unpack(\"z\", io.read(\"a\"))))' | bc | dd status=none of=$(flashdrive output)"
,
  
}
,
  flash_drive 
=
 
{
    
{
      image_filename 
=
 
"/opt/cartesi/share/images/rootfs.ext2"
,
      start 
=
 
0x8000000000000000
,
      length 
=
 
0x5000000
,
    
}
,
    
{
      start 
=
 
0x9000000000000000
,
      length 
=
 
0x1000
,
    
}
,
    
{
      start 
=
 
0xa000000000000000
,
      length 
=
 
0x1000
,
    
}
,
  
}
,
}
Loading and running machines
​
The Lua interface to 
cartesi.machine
 can be used to instantiate Cartesi Machine based on any desired configuration.
In particular, the configurations produced by the 
cartesi-machine
 utility, such as the examples above.
This is, after all, the interface used internally by the 
cartesi-machine
 utility.
For example, the script
run-config.lua
-- Load the Cartesi module
local
 cartesi 
=
 require
"cartesi"
-- Instantiate machine from configuration
local
 machine 
=
 cartesi
.
machine
(
require
(
arg
[
1
]
)
)
-- Run machine until it halts or yields
while
 
not
 machine
:
read_iflags_H
(
)
 
and
 
not
 machine
:
read_iflags_Y
(
)
 
do
    machine
:
run
(
math
.
maxinteger
)
end
loads a machine configuration from the Lua module specified in the command-line (using 
require(arg[1])
).
It then creates an instance by calling the 
cartesi.machine(<machine_config>)
 constructor, which it stores in the

machine
 local variable.
The 
machine:run(<max_mcycle>)
 method of the Cartesi Machine instance runs the corresponding machine until the CSR 
mcycle
 reaches at most 
<max_mcycle>
.
The value of 
<max_mcycle>
 used in the script is a very large integer, providing the machine with enough cycles to run until it halts or yields manual.
Note that the 
machine:run()
 method can return precociously for a variety of reasons (see below), so it should always be called inside a loop.
The 
iflags
 CSR contains a bit 
H
 that is set to true whenever the machine is halted, and a bit 
Y
 that is set to true whenever the machine has yielded manual.
The 
machine:read_iflags_H()
 and 
machine:read_iflags_Y()
 methods return the value of these bits, respectively, and the loop breaks if any of them is set.
For example, to run the configuration stored in 
./config/cat-foo-bar.lua
 (assuming 
./foo.ext2
 is available) simply run
lua5.3 run-config.lua config.cat-foo-bar
(The function call 
require(argv[1])
 translates the argument 
"config.cat-foo-bar"
 to 
"config/cat-foo-bar.lua"
 and loads that file.)
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
Hello world!
The 
machine:get_initial_config()
 method returns the configuration that was used to create a Cartesi Machine instance.
Instantiation from persistent state
​
At any point in their execution, Cartesi Machines can be stored to disk.
A stored machine can later be loaded to continue its execution from where it left off.
note
If the machine initialization involved large image files or a considerable amount of RAM, this operation may consume significant disk space.
It will also take the time required by the copying of image files into the directory, and by the computation of the state hash.
To store a machine at its current state, use the 
machine:store(<directory>)
 method of the Cartesi Machine instance.
store-cat-foo-bar.lua
-- Load the Cartesi module
local
 cartesi 
=
 require
"cartesi"
-- Instantiate machine from configuration
local
 machine 
=
 cartesi
.
machine
(
require
"config.cat-foo-bar"
)
-- Store persistent state to directory
machine
:
store
(
"cat-foo-bar"
)
To prevent persistent Cartesi Machines from being inadvertently overwritten, the function call fails when the directory already exists.
After the execution of the script above, the directory 
./cat-foo-bar/
 contains all the information needed to instantiate the same machine, including copies of all necessary image files.
There are no external dependencies.
In fact, running the following script
load-cat-foo-bar.lua
-- Load the Cartesi module
local
 cartesi 
=
 require
"cartesi"
-- Instantiate machine from persistent state directory
local
 machine 
=
 cartesi
.
machine
(
"cat-foo-bar"
)
-- Run machine until it halts or yields
while
 
not
 machine
:
read_iflags_H
(
)
 
and
 
not
 machine
:
read_iflags_Y
(
)
 
do
    machine
:
run
(
math
.
maxinteger
)
end
has exactly the same effect as the example 
above
, where the machine was instantiated from the configuration and directly run until it halted.
As before, the configuration that was used to instantiate a Cartesi Machine can be obtained from the machine instance with the method 
machine:get_initial_config()
.
Note that this is 
not
 the configuration that was used to instantiate the machine for the first time, but rather the configuration used to instantiate a copy of the machine that was stored.
More specifically, any image filenames point to modified copies that reside inside the storage directory.
Likewise, the RAM image and the values of all registers will reflect the values as they were when stored.
Limiting execution
​
The 
machine:run(<max_mcycle>)
 method of a Cartesi Machine instance always returns when the machine halts.
From the outside, however, it is impossible to predict how many cycles the emulator will need until the machine finally halts.
One of the uses for the 
<max_mcycle>
 argument in production code is to ensure the call returns at a desired frequency, rather than potentially blocking the caller indefinitely.
The following script illustrates the process
run-config-in-chunks.lua
-- Load the Cartesi module
local
 cartesi 
=
 require
"cartesi"
-- Instantiate machine from configuration
local
 machine 
=
 cartesi
.
machine
(
require
(
arg
[
1
]
)
)
local
 CHUNK 
=
 
1000000
 
-- 1 million cycles
-- Loop until machine halts or yields
while
 
not
 machine
:
read_iflags_H
(
)
 
and
 
not
 machine
:
read_iflags_Y
(
)
 
do
    
-- Execute at most CHUNK cycles
    machine
:
run
(
machine
:
read_mcycle
(
)
 
+
 CHUNK
)
    
-- Potentially perform other tasks
end
-- Machine is now halted or yielded manual
The loop conditional checks if the machine has yet to halt.
If so, it runs the machine for at most an additional 
CHUNK
 cycles.
The 
machine:read_mcycle()
 method returns the current value of the 
mcycle
 CSR.
The current value of 
mcycle
 is used to set the new limit to 
mcycle+CHUNK
.
After the call to 
machine:run()
 returns, the application is free to perform other tasks.
Progress feedback
​
When the computation running inside a Cartesi Machine is intensive, it may be desirable to inform users of the progress, so they can plan accordingly.
On its own, the current value of 
mcycle
 does not give any information concerning how much of the computation still remains.
What is needed is the value of 
mcycle
 when the machine halts.
This is, unfortunately, difficult to estimate from the outside.
The target application is in a much better position to estimate its own progress.
However, it needs a mechanism to communicate its progress back to the program controlling the emulator.
The command-line utility 
/opt/cartesi/bin/yield
 can be used for this purpose.
Internally, the tool uses an 
ioctl
 system-call on the Cartesi-specific 
/dev/yield
 device.
The protocols followed by the 
/opt/cartesi/bin/yield
 utility to interact with the 
/dev/yield
 driver, and by the driver itself to communicate with the HTIF Yield device are explained in detail under the 
target perspective
.
The focus here is on its effect on the host program controlling the emulator.
A Cartesi Machine can be configured to accept HTIF yield automatic commands by means of the 
htif.yield_automatic
 Boolean field in the machine configuration.
When set to true, a yield automatic command will cause the emulator to precociously return from a call to 
machine:run(<max_mcycle>)
.
Otherwise, yield automatic commands are ignored so that execution of the 
machine:run(<max_mcycle>)
 continues unimpeded until the machine halts or 
mcycle
 hits 
<max_mcycle>
.
The following example illustrates how Lua scripts can receive progress information throughout a computation performed inside a Cartesi Machine:
run-config-in-chunks-with-progress.lua
-- Load the Cartesi module
local
 cartesi 
=
 require
"cartesi"
-- Writes formatted text to stderr
local
 
function
 
stderr
(
fmt
,
 
...
)
    io
.
stderr
:
write
(
string
.
format
(
fmt
,
 
...
)
)
end
-- Instantiate machine from configuration
local
 machine 
=
 cartesi
.
machine
(
require
(
arg
[
1
]
)
)
local
 CHUNK 
=
 
1000000
 
-- 1 million cycles
local
 max_mcycle 
=
 CHUNK
-- Loop until machine halts or yields
while
 
not
 machine
:
read_iflags_H
(
)
 
and
 
not
 machine
:
read_iflags_Y
(
)
 
do
    
-- Execute at most CHUNK cycles
    machine
:
run
(
max_mcycle
)
    
-- Check if machine yielded automatic
    
if
 machine
:
read_iflags_X
(
)
 
then
        
-- Check if yield was due to progress report
        
local
 reason 
=
 machine
:
read_htif_tohost_data
(
)
 
>>
 
32
        
if
 reason 
==
 cartesi
.
machine
.
HTIF_YIELD_REASON_PROGRESS 
then
            
local
 permil 
=
 machine
:
read_htif_tohost_data
(
)
            
-- Show progress feedback
            
stderr
(
"Progress: %6.2f\r"
,
 permil
/
10
)
        
end
    
end
    
if
 machine
:
read_mcycle
(
)
 
==
 max_mcycle 
then
        max_mcycle 
=
 max_mcycle 
+
 CHUNK
        
-- Potentially perform other tasks
    
end
end
-- Machine is now halted or yielded
stderr
(
"\nCycles: %u\n"
,
 machine
:
read_mcycle
(
)
)
The loop repeats until the machine halts or yields manual.
As before, the computation is performed in chunks.
At each iteration, the script tries to advance the computation until the end of the next chunk.
When the call to 
machine:run()
 returns, a set bit X in CSR 
iflags
 means the reason for returning was the Yield automatic command.
That command can be called for different reasons.
The command and the associated data can be found in the HTIF 
tohost
 CSR.
The 
cartesi.HTIF_YIELD_REASON_PROGRESS
 corresponds to a progress report, and the data contains the progress in parts per mil.
The loop is aborted if the bits H or Y in 
iflags
 is set, which signals the machine is halted or yielded manual.
Otherwise, the execution continues with the remaining of the current chunk, or a new chunk.
In case of a new chunk, the script could perform any desired 
“
per-chunk
”
 tasks.
For example, running the script with the command-line
lua5.3 run-config-in-chunks-with-progress.lua config.progress
produces the output (shown at 44% completion) below
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
Progress:  44.00
This is similar to the 
cartesi-machine
 command-line
cartesi-machine 
\
    --htif-yield-automatic 
\
    -- 
$'for i in $(seq 0 5 1000); do yield automatic progress $i; done'
which uses an equivalent mechanism for progress reports.
Cartesi Machine templates
​
Recall that, to instantiate a 
Cartesi Machine template
, we first replace its flash drive place-holders with their actual content.
After that, we can run the resulting machine.
To save the simple calculator template into directory 
"calculator-template"
, we ran:
cartesi-machine 
\
    --flash-drive
=
"label:input,length:1<<12"
 
\
    --flash-drive
=
"label:output,length:1<<12"
 
\
    --max-mcycle
=
0
 
\
    --final-hash 
\
    --store
=
"calculator-template"
 
\
    -- 
$'dd status=none if=$(flashdrive input) | lua -e \'print((string.unpack("z", io.read("a"))))\' | bc | dd status=none of=$(flashdrive output)'
To instantiate and run the template with the 
cartesi-machine
 command line utility, we used the command-line option 
--replace-flash-drive
:
cartesi-machine 
\
    --load
=
"calculator-template"
 
\
    --replace-flash-drive
=
"start:0x9000000000000000,length:1<<12,filename:input.raw"
 
\
    --replace-flash-drive
=
"start:0xA000000000000000,length:1<<12,filename:output.raw,shared"
Internally, the utility uses the 
machine:replace_memory_range(<memory_range_config>)
 method of the Cartesi Machine instance to replace an existing flash drive.
The 
start
 and 
length
 fields in the 
memory_range_config
 parameter must match those of an existing memory range in the Cartesi Machine instance.
The following code snippet shows how to instantiate a Cartesi Machine template using the Lua API:
run-calculator-with-new-drives.lua
-- Load the Cartesi module
local
 cartesi 
=
 require
"cartesi"
-- Instantiate machine from template
local
 machine 
=
 cartesi
.
machine
(
"calculator-template"
)
-- Get initial config from template
local
 config 
=
 machine
:
get_initial_config
(
)
-- Replace input flash drive
local
 input 
=
 config
.
flash_drive
[
2
]
input
.
image_filename 
=
 
assert
(
arg
[
1
]
,
 
"missing input image filename"
)
machine
:
replace_memory_range
(
input
)
-- Replace output flash drive
local
 output 
=
 config
.
flash_drive
[
3
]
output
.
image_filename 
=
 
assert
(
arg
[
2
]
,
 
"missing output image filename"
)
output
.
shared 
=
 
true
machine
:
replace_memory_range
(
output
)
-- Run machine until it halts or yields
while
 
not
 machine
:
read_iflags_H
(
)
 
and
 
not
 machine
:
read_iflags_Y
(
)
 
do
    machine
:
run
(
math
.
maxinteger
)
end
The code starts by loading the calculator template from directory 
"calculator-template"
.
It then queries the machine for its initial configuration.
There, it finds the 
memory_range_config
 corresponding to the input flash drive (the second drive).
After updating the 
image_filename
 field to point to the filename passed as the first argument to the script, it uses the 
machine:replace_memory_range(<memory_range_config>)
 method to update the machine with the new flash drive.
Then, it obtains the 
memory_range_config
 corresponding to the output flash drive (the third drive).
It updates the 
image_filename
 field to point to the filename passed as the second argument to the script, and sets the

shared
 field to 
true
 so results can be read from the file after the machine is executed.
The output flash drive is then updated with a second call to the 
machine:replace_memory_range(<memory_range_config>)
 method.
Finally, the script runs the machine until it halts or yields manual.
To see the example running,
rm
 -f output.raw
truncate -s 4K output.raw
echo
 
"6*2^1024 + 3*2^512"
 
>
 input.raw
truncate -s 4K input.raw
lua5.3 run-calculator-with-new-drives.lua input.raw output.raw
lua5.3 -e 
'print((string.unpack("z", io.read("a"))))'
 
<
 output.raw
The result is, as expected,
10786158809173895446375831144734148401707861873653839436405804869463\
96054833005778796250863934445216126720683279228360145952738612886499\
73495708458383684478649003115037698421037988831222501494715481595948\
96901677837132352593468675094844090688678579236903861342030923488978\
36036892526733668721977278692363075584
State hashes
​
State hashes are Merkle tree root hashes of the entire 64-bit address space of the Cartesi Machine, where the leaves are aligned 64-bit words.
Since Cartesi Machines are transparent, the contents of this address space encompass the entire machine state, including all the processor's CSRs and general-purpose registers, the contents of RAM and ROM, of all flash drives, and of all other devices or memory ranges connected to the board.
State hashes therefore work as cryptographic signatures of the machine, and implicitly of the computation they are about to execute.
The following script shows how state hashes can be obtained from a Cartesi Machine instance:
run-config-with-hashes.lua
-- Load the Cartesi module
local
 cartesi 
=
 require
"cartesi"
-- Writes formatted text to stderr
local
 
function
 
stderr
(
fmt
,
 
...
)
    io
.
stderr
:
write
(
string
.
format
(
fmt
,
 
...
)
)
end
-- Converts hash from binary to hexadecimal string
local
 
function
 
hexhash
(
hash
)
    
return
 
(
string
.
gsub
(
hash
,
 
"."
,
 
function
(
c
)
        
return
 string
.
format
(
"%02x"
,
 string
.
byte
(
c
)
)
    
end
)
)
end
-- Instantiate machine from configuration
local
 machine 
=
 cartesi
.
machine
(
require
(
arg
[
1
]
)
)
-- Print the initial hash
stderr
(
"%u: %s\n"
,
 machine
:
read_mcycle
(
)
,
 
hexhash
(
machine
:
get_root_hash
(
)
)
)
-- Run machine until it halts or yields
while
 
not
 machine
:
read_iflags_H
(
)
 
and
 
not
 machine
:
read_iflags_Y
(
)
 
do
    machine
:
run
(
math
.
maxinteger
)
end
-- Print machine status
if
 machine
:
read_iflags_H
(
)
 
then
    
stderr
(
"\nHalted\n"
)
else
    
stderr
(
"\nYielded manual\n"
)
end
-- Print cycle count
stderr
(
"Cycles: %u\n"
,
 machine
:
read_mcycle
(
)
)
-- Print the final hash
stderr
(
"%u: %s\n"
,
 machine
:
read_mcycle
(
)
,
 
hexhash
(
machine
:
get_root_hash
(
)
)
)
State hashes can be obtained with the 
machine:get_root_hash()
 method, which returns the corresponding Keccak-256 hash as a 32-byte binary string.
State hashes are produced from an internal Merkle tree data structure that is maintained in a lazy fashion.
The performance penalty imposed on the emulator, were it required to keep the Merkle tree up-to-date, would be unacceptable (by several orders of magnitude).
If no state hashes are needed, the Merkle tree is not updated and negligible cost is incurred.
However, depending on the extent to which the state was modified since the Merkle tree was last updated, the cost of implicitly updating it prior to returning the state hash can be substantial.
note
In previous releases, the 
machine:update_merkle_tree()
 method was public and had to be called explicitly.
This method is now private and is called implicitly by public methods that need an up-to-date Merkle tree
(e.g. 
machine:get_root_hash()
, 
machine:get_proof(<address>, <log2_size>)
 etc).
It goes over all changes to the state that are still unaccounted for since the tree was last updated, bringing the tree in sync with the current state.
Before running the machine, the script obtains the initial state hash, converts it to hexadecimal, and prints the result.
The script then runs the machine until it halts or yields manual.
Once the machine is halted, the script obtains and prints the final state hash.
Initial state hashes can be used to ensure the machine instantiated by the script indeed matches the machine created by the 
cartesi-machine
 utility, and final state hashes to verify that computations also agree.
The output on the left was generated by the command
lua5.3 run-config-with-hashes.lua config.nothing-to-do
The output on the right was produced by running the same Cartesi Machine via the 
cartesi-machine
 utility.
cartesi-machine 
\
    --initial-hash 
\
    --final-hash
0: 1392f3d52dcaa5b070fa1e91b377e8d31fecf242a5ab4e3a84cd191d5699e456
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
Nothing to do.
Halted
Cycles: 62388529
62388529: faa438df6e6dd027aab3710223852303964fe20f93af43c919120bc7ff3d27ba
0: 1392f3d52dcaa5b070fa1e91b377e8d31fecf242a5ab4e3a84cd191d5699e456
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
Nothing to do.
Halted
Cycles: 62388529
62388529: faa438df6e6dd027aab3710223852303964fe20f93af43c919120bc7ff3d27ba
Note that the initial state hashes and the final state hashes match, as expected.
External state access
​
The entire Cartesi Machine state is transparently exposed to the controlling program.
A variety of methods can be used to query a machine instance for any value in its state.
The method 
machine:read_memory(<start>, <length>)
 returns a string with 
<length>
 bytes from any memory range in the machine, starting at the physical-memory address 
<start>
.
Memory ranges include the ROM, the RAM, any of the flash drives, and any of the rollup memory ranges.
The selected data 
must
 reside entirely inside a single memory range (i.e., it cannot straddle a memory range boundary).
There are also methods for reading individual registers.
Most registers are part of the 
RISC-V ISA
, and its 
privileged architecture
.
Cartesi-specific registers are described under the target perspective sections that cover the 
processor
 and 
board
 of the Cartesi Machine architecture.
The method 
machine:read_x(<index>)
, where 
<index>
 is in 0
…
31 returns the value of one of the 32 general-purpose processor registers.
The value of CSRs can be obtained by name, with the 
machine:read_csr("<csr>")
 method.
Here, 
<csr>
 is any of the names

pc


mvendorid


marchid


mimpid


mcycle


minstret


mstatus


mtvec


mscratch


mepc


mcause


mtval


misa


mie


mip


medeleg


mideleg


mcounteren


stvec


sscratch


sepc


scause


stval


satp


scounteren


ilrsc


iflags


clint_mtimecmp


htif_tohost


htif_fromhost


htif_ihalt


htif_iconsole


htif_iyield
.
The value of 
<csr>
 can also be obtained directly from method 
machine:read_<csr>()
. (For example, the 
machine:read_mcycle()
 method has already been encountered several times.)
As already described, convenience methods 
machine:read_iflags_H()
 and 
machine:read_iflags_Y()
 are provided to directly read the most useful bits in the 
iflags
 CSR.
Conversely, any value in the state of a Cartesi Machine instance can be modified by the controlling program.
In contrast to reading the state, writing to the state requires extreme care.
First, for obvious reasons, external modifications to the state break the reproducibility of Cartesi Machines.
Second, careless state modifications can easily panic the Linux kernel or crash any programs running under it.
Nevertheless, there are a few scenarios where these modifications are safe and useful.
The 
machine:write_memory(<start>, <data>)
 method writes the string 
<data>
 into any memory range in the state, starting at the physical-memory address 
<start>
.
Memory ranges include the ROM, the RAM, any of the flash drives, and any of the rollup memory ranges.
Note that the bytes in the string 
<data>
 must fit entirely inside a single memory range (i.e., it cannot straddle a memory range boundary).
The typical use for 
machine:write_memory()
 is when a new input to a Rolling Cartesi Machine has become available from Cartesi
Rollups.
Another use is when an input flash drive was instantiated without an image file, and is thus filled with zeros in the initial machine state.
Before running the machine for the first time, it is safe to replace the contents of the flash drive with the desired input.
(Note, however, that if a flash drive does have an associated 
shared
 image file, the 
machine:write_memory()
 method 
will
 modify the associated image file on disk as well as its mapping in the Cartesi Machine state.)
Another use case is in low-level debugging sessions.
For example, the 
gdb
 remote serial protocol requires the ability to externally modify the state.
General purpose registers can be written to with the method 
machine:write_register(<index>, <value>)
, where 
<index>
 is in 0
…
31.
The value of any CSR can be changed with the 
machine:write_csr("<csr>", <value>)
 method.
(CSRs accept 64-bit integers as value.)
Again, 
<csr>
 is any of the names

pc


mvendorid


marchid


mimpid


mcycle


minstret


mstatus


mtvec


mscratch


mepc


mcause


mtval


misa


mie


mip


medeleg


mideleg


mcounteren


stvec


sscratch


sepc


scause


stval


satp


scounteren


ilrsc


iflags


clint_mtimecmp


htif_tohost


htif_fromhost


htif_ihalt


htif_iconsole


htif_iyield
.
The value of 
<csr>
 can also be changed directly with method 
machine:write_<csr>(<value>)
.
As an example, consider the following script, which uses the 
bc
 program running inside a Cartesi Machine to evaluate an arithmetic expression:
run-calculator.lua
-- Load the Cartesi module
local
 cartesi 
=
 require
"cartesi"
-- Instantiate machine from configuration
local
 calculator_config 
=
 require
"config.calculator"
local
 machine 
=
 cartesi
.
machine
(
calculator_config
)
-- Write expression to input drive
local
 input_drive 
=
 calculator_config
.
flash_drive
[
2
]
machine
:
write_memory
(
input_drive
.
start
,
 table
.
concat
(
arg
,
 
" "
)
 
..
 
"\n"
)
-- Run machine until it halts or yields
while
 
not
 machine
:
read_iflags_H
(
)
 
and
 
not
 machine
:
read_iflags_Y
(
)
 
do
    machine
:
run
(
math
.
maxinteger
)
end
local
 output_drive 
=
 calculator_config
.
flash_drive
[
3
]
print
(
(
string
.
unpack
(
"z"
,
 machine
:
read_memory
(
output_drive
.
start
,
 output_drive
.
length
)
)
)
)
The script loads the 
config
 template from from its Lua module 
./config/calculator.lua
 and instantiates a Cartesi Machine from it.
The pristine input and output flash drives are described in the configuration at 
config.flash_drive[2]
 and 
config.flash_drive[3]
, respectively.
(Entry 
config.flash_drive[1]
 describes the flash drive with the root file-system for the embedded Linux distribution.)
The script concatenates its command-line arguments, line-terminates them, and writes them at the start of the raw input flash drive.
The script then runs the machine until it halts or yields manual.
Finally, it reads the output drive contents and extracts the first null-terminated string from it, and prints the results.
Running the script with the command-line
lua5.3 run-calculator.lua 
6
*2^1024 + 
3
*2^512
produces the output
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
10786158809173895446375831144734148401707861873653839436405804869463\
96054833005778796250863934445216126720683279228360145952738612886499\
73495708458383684478649003115037698421037988831222501494715481595948\
96901677837132352593468675094844090688678579236903861342030923488978\
36036892526733668721977278692363075584
The number is indeed the value of the expression 6
×
2
1024
+3
×
2
512
.
Finally, external state modifications are useful in the setup of artificial, unexpected conditions in regression tests.
State value proofs
​
Value proofs concerning the state of the Cartesi Machine can be obtained from any instance using the method 
machine:get_proof(<address>, <log2_size>)
.
State value proofs
 are proofs that a given node in the Merkle tree of the Cartesi Machine state has a given hash.
Each Merkle tree node covers a contiguous range of the machine's 64-bit address space.
The size of a range is always a power of 2 (given by the 
<log2_size>
 parameter).
Since the leaves have size 8 (for 64-bits), the valid values for 
<log2_size>
 are 3
…
64.
The range corresponding to each node starts at an 
<address>
 that is a multiple of its size.
Recall that the state Merkle is maintained in a lazy fashion.
Therefore, just like with the 
machine:get_root_hash()
 method, the Merkle tree will be implicitly updated to account for state changes.
This means the time it takes to obtain a proof depends on the extent to which the state has been modified since the
Merkle tree was last updated.
The 
machine:get_proof()
 method returns a table with the following structure:
proof 
::
=
 
{
  address 
::
=
 number
,
  log2_size 
::
=
 number
,
  root_hash 
::
=
 string
,
  target_hash 
::
=
 string
,
  sibling_hashes 
::
=
 
{
    
[
1
]
 
::
=
 string
,
    
[
2
]
 
::
=
 string
,
    
...
    
[
64
-
log2_size
]
 
::
=
 string
  
}
}
Fields 
address
 and 
log2_size
 come directly from the arguments passed to the method.
Field 
root_hash
 has the same value as a call to 
machine:get_root_hash()
 would return, i.e., the value of the state hash.
The 
target_hash
 field contains the hash of the node corresponding to 
address
 and 
log2_size
.
To understand the contents of the 
sibling_hashes
 array, consider a path from the root, down the Merkle tree, all the way to the target hash.
When this path is traversed, a number of nodes are visited.
The 
sibling_hashes
 array contains the hashes of the 
siblings
 of all nodes visited (excluding the root, which has no sibling).
Using the data in a proof, it is possible to verify the claim that a Merkle tree with a given root hash contains a target node with a given hash at the position given by its address and size.
The function 
slice_assert(<root_hash>, <proof>)
 exported by the 
cartesi.proof
 module performs exactly this task.
cartesi/proof.lua (excerpt)
local
 cartesi 
=
 require
"cartesi"
local
 _M 
=
 
{
}
function
 _M
.
roll_hash_up_tree
(
proof
,
 target_hash
)
    
local
 hash 
=
 target_hash
    
for
 log2_size 
=
 proof
.
log2_size
,
 
63
 
do
        
local
 bit 
=
 
(
proof
.
address 
&
 
(
1
 
<<
 log2_size
)
)
 
~=
 
0
        
local
 first
,
 second
        
if
 bit 
then
            first
,
 second 
=
 proof
.
sibling_hashes
[
64
-
log2_size
]
,
 hash
        
else
            first
,
 second 
=
 hash
,
 proof
.
sibling_hashes
[
64
-
log2_size
]
        
end
        hash 
=
 cartesi
.
keccak
(
first
,
 second
)
    
end
    
return
 hash
end
function
 _M
.
slice_assert
(
root_hash
,
 proof
)
    
assert
(
root_hash 
==
 proof
.
root_hash
,
 
"proof root_hash mismatch"
)
    
assert
(
_M
.
roll_hash_up_tree
(
proof
,
 proof
.
target_hash
)
 
==
 root_hash
,
        
"node not in tree"
)
end
return
 _M
The bulk of work happens in the 
roll_hash_up_tree(<proof>, <target_hash>)
 function.
In the first iteration of the loop, the function uses the bit with value 2
log2_size
 in 
address
 to determine if the sibling of the target node comes before or after it in the address space of the Cartesi Machine.
It then computes the hash of the concatenation of the target node's hash  and its sibling's hash (in the correct order).
To do so, it uses the 
cartesi.keccak(<first-string>, <second-string>)
 function.
The result must be the hash of the parent node to the target and its sibling.
The loop then goes up the 
sibling_hashes
 array, and obtains the sibling of this parent node.
This is again concatenated with the just-calculated hash of the parent node (in the correct order) to obtain what must be the hash of the grandparent node.
This process is repeated until the hash of what must be the root node is found and returned.
Function 
splice_assert(<root_hash>, <proof>)
 then compares this to the hash that was expected in the root node.
If they match, the proof passes.
Otherwise, something is amiss.
The function 
“
overload
”
 
cartesi.keccak(<word>)
 can be used to obtain the hash for a 64-bit word (i.e., a tree leaf).
The following script verifies the state value proof for the output drive in the calculator example discussed above.
run-calculator-with-proof.lua
-- Load the Cartesi module
local
 cartesi 
=
 require
"cartesi"
-- Load the proof verification module
local
 proof 
=
 require
"cartesi.proof"
-- Instantiate machine from configuration
local
 config 
=
 require
"config.calculator"
local
 machine 
=
 cartesi
.
machine
(
config
)
-- Write expression to input drive
local
 input_drive 
=
 config
.
flash_drive
[
2
]
machine
:
write_memory
(
input_drive
.
start
,
 table
.
concat
(
arg
,
 
" "
)
 
..
 
"\n"
)
-- Run machine until it halts or yields
while
 
not
 machine
:
read_iflags_H
(
)
 
and
 
not
 machine
:
read_iflags_Y
(
)
 
do
    machine
:
run
(
math
.
maxinteger
)
end
-- Obtain value proof for output flash drive
local
 output_state_hash 
=
 machine
:
get_root_hash
(
)
local
 output_drive 
=
 config
.
flash_drive
[
3
]
local
 output_proof 
=
 machine
:
get_proof
(
output_drive
.
start
,
 
12
)
-- Verify proof
proof
.
slice_assert
(
output_state_hash
,
 output_proof
)
print
(
"\nOutput drive proof accepted!\n"
)
print
(
(
string
.
unpack
(
"z"
,
 machine
:
read_memory
(
output_drive
.
start
,
 output_drive
.
length
)
)
)
)
Running the script with the command-line
lua5.3 run-calculator-with-proof.lua 
6
*2^1024 + 
3
*2^512
produces the output
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
Output drive proof accepted!
10786158809173895446375831144734148401707861873653839436405804869463\
96054833005778796250863934445216126720683279228360145952738612886499\
73495708458383684478649003115037698421037988831222501494715481595948\
96901677837132352593468675094844090688678579236903861342030923488978\
36036892526733668721977278692363075584
Remote Cartesi Machines
​
The Lua API can also be used to control a Remote Cartesi Machine.
The functionality is available as a separate Lua module, the 
cartesi.grpc
 submodule.
(This is to avoid pulling in unnecessary gRPC dependencies where only local Cartesi Machines are needed.)
The 
cartesi.grpc.stub(<remote-address>, <checkin-address>)
 method opens and returns a client connection to an existing Remote Cartesi Machine server.
The 
<remote-address>
 specifies the remote server to connect to, and the 
<checkin-address>
 specifies an address the server will use to notify the client when it is ready.
The client connection returned by 
cartesi.grpc.stub(<remote-address>, <checkin-address>)
 functions as a 
remote
 version of the local 
cartesi
 module.
There are two new methods specific to remote connections.
The 
remote.shutdown()
 method causes the remote server to shutdown.
Note that this will, of course, terminate whatever Remote Cartesi Machine the server was managing.
The 
remote.get_version()
 method returns a 
semantic_version
 object that contains the server version:
semantic_version 
::
=
 
{
  major 
::
=
 number
,
  minor 
::
=
 number
,
  patch 
::
=
 number
,
  pre_release 
::
=
 string
,
  build 
::
=
 string
}
The 
remote.machine
 field behaves just like the 
cartesi.machine
 
“
class
”
.
Likewise, the Remote Cartesi Machine instance returned by the 
remote.machine(<machine_config>)
 constructor follows the same interface as the local Cartesi Machine instance returned by the 
cartesi.machine(<machine_config>)
 constructor.
Note that there can only be a single active Cartesi Machine instance per remote server.
Therefore, use the 
machine:destroy()
 on the active instance 
machine
 before instantiating a new machine with the

remote.machine(<machine_config>)
 constructor again.
The following script illustrates the use of the 
cartesi.grpc
 submodule.
run-remote-config.lua
-- No need to load the Cartesi module
local
 cartesi 
=
 
{
}
-- Load the gRPC submodule for Remote Cartesi Machines
cartesi
.
grpc 
=
 require
"cartesi.grpc"
-- Writes formatted text to stderr
local
 
function
 
stderr
(
fmt
,
 
...
)
    io
.
stderr
:
write
(
string
.
format
(
fmt
,
 
...
)
)
end
-- Create connection to Remote Cartesi Machine server
local
 remote_address 
=
 
assert
(
arg
[
1
]
,
 
"missing remote address"
)
local
 checkin_address 
=
 
assert
(
arg
[
2
]
,
 
"missing checkin address"
)
stderr
(
"Listening for checkin at '%s'\n"
,
 checkin_address
)
stderr
(
"Connecting to remote cartesi machine at '%s'\n"
,
 remote_address
)
local
 remote 
=
 cartesi
.
grpc
.
stub
(
remote_address
,
 checkin_address
)
-- Print server version (and test connection)
local
 v 
=
 
assert
(
remote
.
get_version
(
)
)
stderr
(
"Connected: remote version is %d.%d.%d\n"
,
 v
.
major
,
 v
.
minor
,
 v
.
patch
)
-- Instantiate remote machine from configuration
local
 machine 
=
 remote
.
machine
(
require
(
arg
[
3
]
)
)
-- Run machine until it halts or yields
while
 
not
 machine
:
read_iflags_H
(
)
 
and
 
not
 machine
:
read_iflags_Y
(
)
 
do
    machine
:
run
(
math
.
maxinteger
)
end
-- Print machine status
if
 machine
:
read_iflags_H
(
)
 
then
    
stderr
(
"\nHalted\n"
)
else
    
stderr
(
"\nYielded manual\n"
)
end
-- Print cycle count
stderr
(
"Cycles: %u\n"
,
 machine
:
read_mcycle
(
)
)
-- Shutdown remote server
stderr
(
"Shutting down remote cartesi machine\n"
)
remote
.
shutdown
(
)
The script starts by loading the 
cartesi.grpc
 module.
It then opens a client connection to the remote server using addresses specified as the first and second command-line arguments.
It calls the 
remote.get_version()
 method to test the connection and prints the version number returned by the server.
From then on, the code is virtually the same as it would be if everything was local.
The script creates a Remote Cartesi Machine instance using the 
remote.machine(<machine_config>)
 method, passing the configuration obtained from the third command-line argument.
Note that, if the server has an active machine instance already, the call will fail.
Furthermore, any resources referenced in the 
machine_config
 must be accessible to the server or the call will also fail.
The script runs the returned remote machine instance until it halts or yields manual.
It then prints the reason the machine stopped running and the cycle count at that point.
Finally, it shuts down the server.
Recall that, to run a server inside the playground, we opened a separate shell into the same playground container (For example, by running 
docker exec -it <container-name> /bin/bash
), and then ran the 
remote-cartesi-machine
 server in it
remote-cartesi-machine 
\
    --server-address
=
localhost:8080
Now, instead of using the 
cartesi-machine
 command-line utility to control it, run the 
run-remote-config.lua
 client script in the other shell
lua5.3 run-remote-config.lua 
\
    localhost:8080 
\
    localhost:8081 
\
    config.nothing-to-do
The client shell produces
Listening for checkin at 'localhost:8081'
Connecting to remote cartesi machine at 'localhost:8080'
Connected: remote version is 0.6.0
Halted
Cycles: 62388529
Shutting down remote cartesi machine
The server shell produces
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
Nothing to do.
Rolling Cartesi Machines
​
Target applications running inside Rolling Cartesi Machines communicate with the outside world by using Cartesi Rollups.
In production, the Server Manager is responsible for passing advance-state and inspect-state requests to the machine and collecting the responses (vouchers, notices, reports, and exceptions) that were generated while processing each request.
When prototyping, the 
cartesi-machine
 command-line utility can be used to play the same part, loading sequentially-numbered requests from files and storing sequentially-numbered responses to files.
As expected, the Lua interface can also be used to feed requests to a Rolling Cartesi Machine and obtain the responses it produces.
The target application (indirectly) raises the HTIF manual yield flag (
machine:read_iflags_Y() == true
) to notify the host it is done with the current request and ready for the next.
While processing each request, it raises the HTIF automatic yield flag (
machine:read_iflags_X() == true
) for each new response it generates.
In both cases, the 
reason
 for the yield is available from bits 47-32 in the 
tohost
 HTIF CSR (
machine:read_tohost_data() >> 32
).
When transitioning between requests, the reason can take the values 
machine.HTIF_YIELD_REASON_RX_ACCEPTED
 (previous request was accepted), 
machine.HTIF_YIELD_REASON_RX_REJECTED
 (previous request was rejected), or 
machine.HTIF_YIELD_REASON_TX_EXCEPTION
 (an unrecoverable error was encountered).
When generating a new response to a request, the reason can take the self-explanatory values 
machine.HTIF_YIELD_REASON_TX_VOUCHER
, 
machine.HTIF_YIELD_REASON_TX_NOTICE
, and 
machine.HTIF_YIELD_REASON_TX_REPORT
.
The data associated with requests is sent to the machine in the rollup memory ranges defined by 
memory_range_config
 entries stored in the 
machine_config
 as 
rollup.rx_buffer
 and 
rollup.input_metadata
.
Conversely, the data associated with responses (or exceptions) is obtained from the machine in the 
rollup.tx_buffer
 rollup memory range.
Finally, hashes for vouchers and notices produced in response to advance-state requests are written, respectively, to arrays in the 
rollup.voucher_hashes
 and 
rollup.notice_hashes
 rollup memory ranges, in the order they are produced.
Data in the input-metadata memory range consists of the following fields: a 
message sender
 (an EVM address), a 
block-number
, a 
timestamp
 (seconds since the 
Unix epoch
), the rollup 
epoch index
, and the rollup 
input index
.
All entries are 256-bit big-endian unsigned integers.
In practice, only the least-significant 20 bytes are used for the message sender address, and only the least-significant 8 bytes, or 64-bits, are used for the remaining number entries.
(See the table in the target perspective 
architecture
.)
Data for the input to an advance-state request, the query to an inspect-state request, exceptions, notices, and reports are all encoded in the same way: a 256-bit 
offset
 field (with value 32), then a 256-bit 
length
 field, directly followed by payload with 
length
 bytes.
The offset and length fields are encoded as 256-bit big-endian unsigned integers.
Data for vouchers start with an 
address
 field (an EVM address, again as the least-significant 20 bytes in a 256-bit big-endian unsigned integer) and then continue just like the others: and 
offset
 field (this time with value 64), then a 256-bit 
length
 field, directly followed by payload with 
length
 bytes.
(See the table in the target perspective 
architecture
.)
The following script illustrates how the Lua API can be used to send advance-state requests to a Rolling Cartesi Machine, and how it can be used to collect the notices produced as responses (We will use the server calculator 
example
:
run-rolling-calculator.lua
-- No need to load the Cartesi module
local
 cartesi 
=
 
{
}
cartesi
.
grpc 
=
 require
"cartesi.grpc"
-- Writes formatted text to stderr
local
 
function
 
stderr
(
fmt
,
 
...
)
    io
.
stderr
:
write
(
string
.
format
(
fmt
,
 
...
)
)
end
-- Create connection to Remote Cartesi Machine server
local
 remote_address 
=
 
assert
(
arg
[
1
]
,
 
"missing remote address"
)
local
 checkin_address 
=
 
assert
(
arg
[
2
]
,
 
"missing checkin address"
)
stderr
(
"Listening for checkin at '%s'\n"
,
 checkin_address
)
stderr
(
"Connecting to remote cartesi machine at '%s'\n"
,
 remote_address
)
local
 remote 
=
 cartesi
.
grpc
.
stub
(
remote_address
,
 checkin_address
)
-- Print server version (and test connection)
local
 v 
=
 
assert
(
remote
.
get_version
(
)
)
stderr
(
"Connected: remote version is %d.%d.%d\n"
,
 v
.
major
,
 v
.
minor
,
 v
.
patch
)
-- Instantiate machine from template
local
 machine 
=
 remote
.
machine
(
"rolling-calculator-template"
)
-- Get initial config from template
local
 config 
=
 machine
:
get_initial_config
(
)
-- Print a string splitting it into multiple lines
local
 
function
 
fold
(
str
,
 w
)
    
local
 i 
=
 
1
    
while
 i 
<=
 
#
str 
do
        
print
(
str
:
sub
(
i
,
 i
+
w
-
1
)
)
        i 
=
 i 
+
 w
    
end
end
-- Encode an unsigned integer into 256-bit big-endian
local
 
function
 
encode_be256
(
value
)
    
return
 string
.
rep
(
"\0"
,
 
32
-
8
)
..
string
.
pack
(
">I8"
,
 value
)
end
-- Write the input metadata memory range
local
 
function
 
write_input_metadata
(
machine
,
 input_metadata
,
 i
)
    machine
:
write_memory
(
input_metadata
.
start
,
        
encode_be256
(
0
)
 
..
 
-- msg_sender
        
encode_be256
(
0
)
 
..
 
-- block_number
        
encode_be256
(
os
.
time
(
)
)
 
..
 
-- time_stamp
        
encode_be256
(
0
)
 
..
 
-- epoch_index
        
encode_be256
(
i
)
 
-- input_index"
    
)
end
-- Write the input into the rx_buffer memory range
local
 
function
 
write_input
(
machine
,
 rx_buffer
,
 input
)
    machine
:
write_memory
(
rx_buffer
.
start
,
        
encode_be256
(
32
)
 
..
 
-- offset
        
encode_be256
(
#
input
)
 
..
 
-- length
        input 
-- input itself
    
)
end
-- Read a notice from the tx_buffer memory range
local
 
function
 
read_notice
(
machine
,
 tx_buffer
,
 str
)
    
-- Get length of output, skipping offset
    
local
 length 
=
 string
.
unpack
(
">I8"
,
        machine
:
read_memory
(
tx_buffer
.
start
+
32
+
24
,
 
8
)
)
    
-- Get output itself, skipping offset and length
    
return
 machine
:
read_memory
(
tx_buffer
.
start
+
64
,
 length
)
end
-- Obtain the relevant rollup memory ranges from the initial config
assert
(
config
.
rollup
,
 
"rollup not enabled in machine"
)
local
 rx_buffer 
=
 config
.
rollup
.
rx_buffer
local
 tx_buffer 
=
 config
.
rollup
.
tx_buffer
local
 input_metadata 
=
 config
.
rollup
.
input_metadata
-- Run machine until it halts
local
 i 
=
 
0
while
 
not
 machine
:
read_iflags_H
(
)
 
do
    machine
:
run
(
math
.
maxinteger
)
    
local
 reason 
=
 machine
:
read_htif_tohost_data
(
)
 
>>
 
32
    
-- Machine yielded manual
    
if
 machine
:
read_iflags_Y
(
)
 
then
        
-- Send new request if previous was accepted
        
if
 reason 
==
 remote
.
machine
.
HTIF_YIELD_REASON_RX_ACCEPTED 
then
            
-- Otherwise, obtain expression from stdin
            
stderr
(
"type expression\n"
)
 
-- prompt for expression
            
local
 expr 
=
 io
.
read
(
)
            
if
 
not
 expr 
then
                
break
            
end
            machine
:
snapshot
(
)
            i 
=
 i 
+
 
1
            
-- Write expression as the input
            
write_input
(
machine
,
 rx_buffer
,
 expr
)
            
-- Write the input metadata
            
write_input_metadata
(
machine
,
 input_metadata
,
 i
)
            
-- Tell machine this is an advance-state request
            machine
:
write_htif_fromhost_data
(
0
)
            
-- Reset the Y flag so machine can proceed
            machine
:
reset_iflags_Y
(
)
        
-- Otherwise, rollback to state before processing was attempted
        
elseif
 i 
>
 
0
 
then
            
stderr
(
"input rejected\n"
)
            machine
:
rollback
(
)
        
else
            
stderr
(
"machine initialization failed\n"
)
            
break
        
end
    
-- Machine yielded automatic
    
elseif
 machine
:
read_iflags_X
(
)
 
then
        
-- It output a notice
        
if
 reason 
==
 remote
.
machine
.
HTIF_YIELD_REASON_TX_NOTICE 
then
            
-- Read notice and print it
            
stderr
(
"result is\n"
)
            
fold
(
read_notice
(
machine
,
 tx_buffer
)
,
 
68
)
        
end
    
end
end
-- Shutdown remote server
stderr
(
"Shutting down remote cartesi machine\n"
)
remote
.
shutdown
(
)
Rolling Cartesi Machines must be rolled-back to the state they were at before they received an advance-state request they later rejected.
This requires the 
machine:snapshot()
 and 
machine:rollback()
 methods available only in Remote Cartesi Machines.
Therefore, the script uses the 
cartesi.grpc
 module to instantiate a remote machine based on the 
"rolling-calculator-template"
.
After defining a variety of helper functions, the script obtains from the machine configuration the rollup memory ranges it will later use to exchange data with the Rolling Cartesi Machine: 
rollup.rx_buffer
, 
rollup.tx_buffer
, and 
rollup.input_metadata
.
It then enters its main loop, which is executed until the machine halts.
For each iteration, the script invokes 
machine:run(math.maxinteger)
 to run the machine until it yields or halts.
When the call returns, it checks if the machine yielded manual.
If so, it checks the reason for the yield.
If the reason was 
machine.HTIF_YIELD_REASON_RX_ACCEPTED
, the application accepted the previous request and is ready for the next.
The script then attempts to obtain a mathematical expression from the console.
If the user provides one, it creates a new snapshot and then writes the expression as the input payload into

rollup.rx_buffer
 and the input metadata to 
rollup.input_metadata
, both in the appropriate encoding.
Before continuing with the next loop iteration, the script informs the server that the new request is an advance-state request by writing 
0
 to the data field of the HTIF 
tohost
 CSR (as opposed to 1, which would signify an inspect-state request).
It also clears the 
Y
 flag in the 
iflags
 CSR to release the machine for execution.
If, however, the reason was anythying else, the script rolls back the machine and continues with the next loop iteration.
If the machine yielded automatic, the script once again checks for the yield reason.
If the reason was 
machine.HTIF_YIELD_REASON_TX_NOTICE
, the script decoes the notice payload from 
rollup.tx_buffer
 and prints the formatted result to the console.
Here is what a session looks like.
First, open an separate shell into the same playground container (For example, by running 
docker exec -it <container-name> /bin/bash
) and run the 
remote-cartesi-machine
 server in it
remote-cartesi-machine 
\
    --server-address
=
localhost:8080
Then, run the 
run-rolling-calculator.lua
 client script in the other shell
lua run-rolling-calculator.lua localhost:8080 localhost:8081
The client prints the connection status to the console
Listening for checkin at 'localhost:8081'
Connecting to remote cartesi machine at 'localhost:8080'
Connected: remote version is 0.5.0
and prompts us to type an expression. Entering 
6*2^1024 + 3*2^512
 causes the expected result to be printed:
type expression
6*2^1024 + 3*2^512
result is
10786158809173895446375831144734148401707861873653839436405804869463
96054833005778796250863934445216126720683279228360145952738612886499
73495708458383684478649003115037698421037988831222501494715481595948
96901677837132352593468675094844090688678579236903861342030923488978
36036892526733668721977278692363075584
The client then asks for a new expression. Entering an invalid expression 
1+(
 causes the 
calc.sh
 script running inside the Rolling Cartesi Machine to reject the input:
type expression
1+(
input rejected
Finally, entering 
^D
 causes the client script to shutdown the server and exit.
type expression
^D
Shutting down remote cartesi machine
The remote console shows only the error generated when the invalid expression 
1+(
 was entered:
bc: bad expression at '('
[json.exception.parse_error.101] parse error at line 1, column 1: syntax error while parsing value - unexpected end of
input; expected '[', '{', or a literal
State transition proofs
​
During verification, the blockchain mediates a 
verification game
 between the disputing parties.
This process is explained in detail under 
the blockchain perspective
.
In a nutshell, both parties started from a Cartesi Machine that has a known and agreed upon initial state hash.
(E.g., an agreed upon template that was instantiated with an agreed upon input drive.)
At the end of the computation, these parties now disagree on the state hash for the halted machine.
The state hash evolves as the machine executes steps in its fetch-execute loop.
The first stage of the verification game therefore searches for the 
step of disagreement
: the particular cycle such that the parties agree on the state hash before the step, but disagree on the state hash after the step.
Once this step of disagreement is identified, one of the parties sends to the blockchain a log of state accesses that happen along the step, including cryptographic proofs for every value read from or written to the state.
This log proves to the blockchain that the execution of the step transitions the state in such a way that it finally reaches the state hash claimed by the submitting party.
To obtain the access log for the next step in the execution of a Cartesi Machine instance, use the 
machine:step(<log_type>)
 function.
Note that the function indeed performs the step, and therefore advances the state, in addition to collecting the access log.
The 
<log_type>
 argument specifies if the access log should include annotations and cryptographic proofs, or only the accesses themselves.
It is a table in the format
log_type 
::
=
 
{
  proofs 
::
=
 boolean
,
  annotations 
::
=
 boolean
}
The format of the access log returned is as follows:
access_log 
::
=
 
{
  accesses 
::
=
 
{
    
[
1
]
 
::
=
 word_access
,
    
[
2
]
 
::
=
 word_access
,
    
...
    
[
n
]
 
::
=
 word_access
  
}
,
  notes 
::
=
 
{
    
[
1
]
 
::
=
 string
,
    
[
2
]
 
::
=
 string
,
    
...
    
[
n
]
 
::
=
 string
,
  
}
,
  brackets 
::
=
 
{
    
[
1
]
 
::
=
 bracket
,
    
[
2
]
 
::
=
 bracket
,
    
...
    
[
m
]
 
::
=
 bracket
  
}
,
}
word_access 
::
=
 
{
  type 
::
=
 
"read"
 
|
 
"write"
,
  address 
::
=
 number
,
  read 
::
=
 number
,
  written 
::
=
 number
  proof 
::
=
 proof
}
bracket 
::
=
 
{
  type 
::
=
 
"begin"
 
|
 
"end"
,
  where 
::
=
 number
,
  text 
::
=
 string
}
The word 
accesses
 array records, in order, all accesses to the machine state performed during the execution of the next step in the evolution of the Cartesi Machine state.
Word accesses can be of 
type
 either 
"read"
 or 
"write"
.
The 
address
 field specifies the physical address of the corresponding (aligned) 64-bit word accessed.
Read accesses contain the value 
read
 for the word.
Write accesses contain, in the 
read
 field, the value that was in the state before it was overwritten by the value in the 
written
 field.
The 
proof
 field is used when 
verifying state transitions
.
Inspecting access logs
​
When the 
log_type
 includes the field 
annotations = true
, the access log includes annotations that help put each access into a larger context.
The 
notes
 array contains a string corresponding to each entry in the 
accesses
 array, describing the word access.
The 
brackets
 contain information that groups ranges of word accesses into 
scopes
.
Each bracket entry 
type
 field tells if the entry marks the 
"begin"
 or 
"end"
 of a scope.
The 
where
 field gives the position in the 
accesses
 array where the bracket should be 
“
inserted
”
.
The 
dump_log(<log>, <out>)
 function in the 
cartesi.util
 module uses these annotations to dump a detailed description of the access 
<log>
 into file 
<out>
:
cartesi/util.lua (excerpt)
-- Output formatted string with indentation
local
 
function
 
indentout
(
f
,
 indent
,
 fmt
,
 
...
)
    f
:
write
(
string
.
rep
(
"  "
,
 indent
)
,
 string
.
format
(
fmt
,
 
...
)
)
end
-- Convert string to hex
local
 
function
 
hexstring
(
hash
)
    
return
 
(
string
.
gsub
(
hash
,
 
"."
,
 
function
(
c
)
        
return
 string
.
format
(
"%02x"
,
 string
.
byte
(
c
)
)
    
end
)
)
end
-- Take first 8 characters in hexadecimal hash
local
 
function
 
hexhash8
(
hash
)
    
return
 string
.
sub
(
hexstring
(
hash
)
,
 
1
,
 
8
)
end
-- Convert binary data to number or to start and end as hexdecimal
local
 
function
 
accessdatastring
(
data
,
 log2_size
)
    
if
 log2_size 
==
 
3
 
then
        data 
=
 string
.
unpack
(
"<I8"
,
 data
)
        
return
 string
.
format
(
"0x%x(%u)"
,
 data
,
 data
)
    
else
        
return
 string
.
format
(
"%s...%s(2^%d bytes)"
,
            
hexstring
(
string
.
sub
(
data
,
 
1
,
 
3
)
)
,
            
hexstring
(
string
.
sub
(
data
,
 
-
3
,
 
-
1
)
)
,
 log2_size
)
    
end
end
-- Dump formatted log to file
function
 _M
.
dump_log
(
log
,
 out
)
    
local
 indent 
=
 
0
    
local
 j 
=
 
1
 
-- Bracket index
    
local
 i 
=
 
1
 
-- Access index
    
local
 brackets 
=
 log
.
brackets 
or
 
{
}
    
local
 notes 
=
 log
.
notes 
or
 
{
}
    
local
 accesses 
=
 log
.
accesses
    
-- Loop until accesses and brackets are exhausted
    
while
 
true
 
do
        
local
 bj 
=
 brackets
[
j
]
        
local
 ai 
=
 accesses
[
i
]
        
if
 
not
 bj 
and
 
not
 ai 
then
 
break
 
end
        
-- If bracket points before current access, output bracket
        
if
 bj 
and
 bj
.
where 
<=
 i 
then
            
if
 bj
.
type 
==
 
"begin"
 
then
                
indentout
(
out
,
 indent
,
 
"begin %s\n"
,
 bj
.
text
)
                indent 
=
 indent 
+
 
1
 
-- Increase indentation before bracket
            
elseif
 bj
.
type 
==
 
"end"
 
then
                indent 
=
 indent 
-
 
1
 
-- Decrease indentation after bracket
                
indentout
(
out
,
 indent
,
 
"end %s\n"
,
 bj
.
text
)
            
end
            j 
=
 j 
+
 
1
        
-- Otherwise, output access
        
elseif
 ai 
then
            
if
 ai
.
proof 
then
                
indentout
(
out
,
 indent
,
 
"hash %s\n"
,
                    
hexhash8
(
ai
.
proof
.
root_hash
)
)
            
end
            
local
 read 
=
 
accessdatastring
(
ai
.
read
,
 ai
.
log2_size
)
            
if
 ai
.
type 
==
 
"read"
 
then
                
indentout
(
out
,
 indent
,
 
"%d: read %s@0x%x(%u): %s\n"
,
 i
,
                    notes
[
i
]
 
or
 
""
,
 ai
.
address
,
 ai
.
address
,
 read
)
            
else
                
assert
(
ai
.
type 
==
 
"write"
,
 
"unknown access type"
)
                
local
 written 
=
 
accessdatastring
(
ai
.
written
,
 ai
.
log2_size
)
                
indentout
(
out
,
 indent
,
 
"%d: write %s@0x%x(%u): %s -> %s\n"
,
 i
,
                    notes
[
i
]
 
or
 
""
,
 ai
.
address
,
 ai
.
address
,
 read
,
 written
)
            
end
            i 
=
 i 
+
 
1
        
end
    
end
end
The function indents each access according to the number of enclosing scopes.
It uses the notes to print the 
meaning
 of each word being accessed: Is it a register, a CSR, memory?
Addresses and values are printed in hexadecimal and decimal.
If the log was generated with the 
proofs = true
 option, then the current state hash before each access is also printed.
Running the 
dump-step.lua
 program:
dump-step.lua
-- Load the Cartesi modules
local
 cartesi 
=
 require
"cartesi"
local
 util 
=
 require
"cartesi.util"
-- Instantiate machine from configuration
local
 machine 
=
 cartesi
.
machine
(
require
"config.nothing-to-do"
)
-- Run machine until it halts or yields
local
 max_mcycle 
=
 
46598940
while
 
not
 machine
:
read_iflags_H
(
)
 
and
 
not
 machine
:
read_iflags_Y
(
)
 
and
 machine
:
read_mcycle
(
)
 
<
 max_mcycle 
do
    machine
:
run
(
max_mcycle
)
end
assert
(
machine
:
read_mcycle
(
)
 
==
 max_mcycle
,
 
"Machine halted or yielded early!"
)
-- Obtain state hash before step
local
 step_log 
=
 machine
:
step
{
 annotations 
=
 
true
,
 proofs 
=
 
true
 
}
-- Dump access log to screen
io
.
stderr
:
write
(
string
.
format
(
"\nContents of step %u access log:\n\n"
,
 max_mcycle
)
)
util
.
dump_log
(
step_log
,
 io
.
stderr
)
with command:
lua5.3 dump-step.lua
produces the output:
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
Contents of step 46598940 access log:
begin step
  hash a00da7eb
  1: read mcycle@0x120(288): 0x2c70b1c(46598940)
  hash a00da7eb
  2: read iflags.H@0x1d0(464): 0x18(24)
  hash a00da7eb
  3: read iflags.Y@0x1d0(464): 0x18(24)
  hash a00da7eb
  4: read iflags.X (superfluous)@0x1d0(464): 0x18(24)
  hash a00da7eb
  5: write iflags.X@0x1d0(464): 0x18(24) -> 0x18(24)
  begin set_rtc_interrupt
  end set_rtc_interrupt
  begin raise_interrupt_if_any
    hash a00da7eb
    6: read mip@0x170(368): 0x0(0)
    hash a00da7eb
    7: read mie@0x168(360): 0x2aa(682)
  end raise_interrupt_if_any
  begin fetch_insn
    hash a00da7eb
    8: read pc@0x100(256): 0x80002fa0(2147495840)
    begin translate_virtual_address
      hash a00da7eb
      9: read iflags.PRV@0x1d0(464): 0x18(24)
      hash a00da7eb
      10: read mstatus@0x130(304): 0xa00000820(42949675040)
    end translate_virtual_address
    begin find_pma_entry
      hash a00da7eb
      11: read pma.istart@0x800(2048): 0x800000f9(2147483897)
      hash a00da7eb
      12: read pma.ilength@0x808(2056): 0x4000000(67108864)
    end find_pma_entry
    hash a00da7eb
    13: read memory@0x80002fa0(2147495840): 0x7378300f6b023(2031360633384995)
  end fetch_insn
  begin sd
    hash a00da7eb
    14: read x@0x68(104): 0x40008000(1073774592)
    hash a00da7eb
    15: read x@0x78(120): 0x10100000000000a(72339069014638602)
    begin translate_virtual_address
      hash a00da7eb
      16: read iflags.PRV@0x1d0(464): 0x18(24)
      hash a00da7eb
      17: read mstatus@0x130(304): 0xa00000820(42949675040)
    end translate_virtual_address
    begin find_pma_entry
      hash a00da7eb
      18: read pma.istart@0x800(2048): 0x800000f9(2147483897)
      hash a00da7eb
      19: read pma.ilength@0x808(2056): 0x4000000(67108864)
      hash a00da7eb
      20: read pma.istart@0x810(2064): 0x1069(4201)
      hash a00da7eb
      21: read pma.ilength@0x818(2072): 0xf000(61440)
      hash a00da7eb
      22: read pma.istart@0x820(2080): 0x80000000000002d9(9223372036854776537)
      hash a00da7eb
      23: read pma.ilength@0x828(2088): 0x5000000(83886080)
      hash a00da7eb
      24: read pma.istart@0x830(2096): 0x4000841a(1073775642)
      hash a00da7eb
      25: read pma.ilength@0x838(2104): 0x1000(4096)
    end find_pma_entry
    hash a00da7eb
    26: write htif.tohost@0x40008000(1073774592): 0x10100000000000d(72339069014638605) -> 0x10100000000000a(72339069014638602)
    hash 8ebc16f9
    27: read htif.iconsole@0x40008018(1073774616): 0x2(2)
    hash 8ebc16f9
    28: write htif.fromhost@0x40008008(1073774600): 0x0(0) -> 0x101000000000000(72339069014638592)
    hash 7fa4fe27
    29: write pc@0x100(256): 0x80002fa0(2147495840) -> 0x80002fa4(2147495844)
  end sd
  hash bac08fcc
  30: read minstret@0x128(296): 0x2c70aef(46598895)
  hash bac08fcc
  31: write minstret@0x128(296): 0x2c70aef(46598895) -> 0x2c70af0(46598896)
  hash 65519976
  32: read mcycle@0x120(288): 0x2c70b1c(46598940)
  hash 65519976
  33: write mcycle@0x120(288): 0x2c70b1c(46598940) -> 0x2c70b1d(46598941)
end step
Understanding these logs in detail is unnecessary for all but the most low-level internal development at Cartesi.
It requires deep knowledge of not only RISC-V architecture, but also how Cartesi's emulator implements it.
The material is beyond the scope of this document.
In this particular example, however, it was hand-picked for illustration purposes.
The RISC-V instruction being executed, 
sd
, writes the 64-bit word 
0x010100000000000a
 to address 
0x40008000
 (access
 
#26).
This is the memory-mapped address of HTIF's 
tohost
 CSR.
The value refers to the console subdevice (
DEV=0x01
) , command 
putchar
 (
CMD=0x01
), and causes the device to output a line-feed (
DATA=0x0a
).
I.e., the instruction is completing the row 
       \    / CARTESI
 in the splash screen.
Verifying state transitions
​
When the 
log_type
 includes the field 
proofs = true
, each word access comes with a 
proof
 field containing the proof for the value 
read
.
Using the known state hash before the access, it is possible to verify that the value reported 
read
 was indeed the value stored at the physical 
address
 in the machine state.
For a 
"read"
 access, the state hash does not change.
However, for a 
"write"
 access, the 
sibling_hashes
 in the 
proof
 (which have just been verified to be truthful along with the value 
read
) can be used to compute the new state hash.
The new hash is simply
new_hash 
=
 proof
.
roll_hash_up_tree
(
access
.
proof
,
 cartesi
.
keccak
(
access
.
written
)
)
In this way, the accesses can be processed one by one, until the new state hash at the end of the step has been obtained.
The process described above can only verify that, should these accesses be performed starting from the state as it was before the step, a given state hash would obtain.
To ensure that the accesses indeed correspond to the operation of a Cartesi Machine starting from that state, knowledge of the Cartesi Machine architecture as implemented by the emulator is needed.
The function 
cartesi.machine.verify_state_transition(<state_hash_before>, <access_log>, <state_hash_after>, <runtime_config>)
 uses this knowledge to verify that the 
<access_log>
 transitions from 
<state_hash_before>
 to 
<state_hash_after>
.
Note there is no need for a Cartesi Machine instance to verify a transition.
All required state information is in the access log.
(The 
<machine_runtime_config>
The following script illustrates the verification of a state transition.
verify-step.lua
-- Load the Cartesi modules
local
 cartesi 
=
 require
"cartesi"
local
 util 
=
 require
"cartesi.util"
-- Instantiate machine from configuration
local
 machine 
=
 cartesi
.
machine
(
require
"config.nothing-to-do"
)
-- Run machine until it halts or yields
local
 max_mcycle 
=
 
46598940
while
 
not
 machine
:
read_iflags_H
(
)
 
and
 
not
 machine
:
read_iflags_Y
(
)
 
and
 machine
:
read_mcycle
(
)
 
<
 max_mcycle 
do
    machine
:
run
(
max_mcycle
)
end
assert
(
machine
:
read_mcycle
(
)
 
==
 max_mcycle
,
 
"Machine halted early!"
)
-- Obtain state hash before step
local
 hash_before_step 
=
 machine
:
get_root_hash
(
)
-- Obtain access log
local
 step_log 
=
 machine
:
step
{
 annotations 
=
 
true
,
 proofs 
=
 
true
 
}
-- Obtain state hash after step
local
 hash_after_step 
=
 machine
:
get_root_hash
(
)
-- Potentially mess with state access to cause a verification failure
if
 
#
arg 
>
 
0
 
then
    
local
 env 
=
 
{
 string 
=
 string
,
 cartesi 
=
 cartesi
,
 step_log 
=
 step_log 
}
    
local
 f 
=
 
assert
(
load
(
arg
[
1
]
,
 arg
[
1
]
,
 
"t"
,
 env
)
)
    
f
(
)
end
-- Verify step access log
assert
(
cartesi
.
machine
.
verify_state_transition
(
hash_before_step
,
 step_log
,
 hash_after_step
,
 
{
}
)
)
io
.
stderr
:
write
(
"State transition accepted!\n"
)
Running the script without arguments accepts the valid state transition.
lua5.3 verify-step.lua
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
State transition accepted!
The script is much more interesting when the argument is used to 
“
mess
”
 with the access log before verification.
For example, changing the address of access #26
26: write htif.tohost@0x40008000(1073774592): 0x10100000000000d(72339069014638605) -> 0x10100000000000a(72339069014638602)
from 
0x40008000
 to 
0x100
 causes the program to reject the state transition proof:
lua5.3 verify-step.lua 
'step_log.accesses[26].address = 0x100'
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
lua5.3: verify-step.lua:31: expected access 26 to write htif.tohost at address 0x40008000(1073774592)
stack traceback:
    [C]: in function 'assert'
    verify-step.lua:31: in main chunk
    [C]: in ?
The error message states that, starting from the 
<state_hash_before>
 and given accesses 1
–
26 in the 
<access_log>
, a true Cartesi Machine would have written to address 
0x40008000
 (helpfully labeled as the CSR 
htif.tohost
), rather than address 
0x100
 claimed by our corrupt access log.
Changing the value written also causes the proof to fail, because the earlier entries completely determine the value a true Cartesi Machine would have written:
lua5.3 verify-step.lua 
'step_log.accesses[26].written = string.pack(">I8", 0x1234)'
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
lua5.3: verify-step.lua:30: word value written in access 26 does not match log
stack traceback:
    [C]: in function 'assert'
    verify-step.lua:30: in main chunk
    [C]: in ?
Changing the value read also causes the proof to be rejected because it will not match the target hash:
lua5.3 verify-step.lua 
'step_log.accesses[26].read = string.pack(">I8", 0x1234)'
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
lua5.3: verify-step.lua:30: word value before write access 26 does not match target hash
stack traceback:
    [C]: in function 'assert'
    verify-step.lua:30: in main chunk
    [C]: in ?
Changing the target hash to match the false value read causes the proof to be rejected because rolling the target hash up the tree will not result in the expected root hash:
lua5.3 verify-step.lua 
'local access = step_log.accesses[26];access.read = 0x1234; access.proof.target_hash = cartesi.keccak(access.read);'
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
lua5.3: verify-step.lua:30: word value before write access 26 fails proof
stack traceback:
    [C]: in function 'assert'
    verify-step.lua:30: in main chunk
    [C]: in ?
In a nutshell, only valid state transitions are accepted by the 
cartesi.machine.verify_state_transition()
 function.
Instantiation by configuration
Configuration from command-line
Additional sample configurations
Loading and running machines
Instantiation from persistent state
Limiting execution
Progress feedback
Cartesi Machine templates
State hashes
External state access
State value proofs
Remote Cartesi Machines
Rolling Cartesi Machines
State transition proofs
Inspecting access logs
Verifying state transitions
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 5---










3 docs tagged with "beginner" | Blockchain OS Documentation - Cartesi
























Skip to main content
Choose your Onboarding Path
Our onboarding paths answer the following questions:
Scalability
The scalability issue is one of the three parts of the Blockchain Trilemma, along with security and decentralization. Solving the scalability issue refers to any type of improvement within a blockchain system in terms of computational power, throughput, latency, bootstrap time, or cost per transaction. For example, high gas fees make it expensive for users to pay for their transactions within the Ethereum blockchain.
The Blockchain OS
Cartesi, The Blockchain OS, is a layer-2 platform for the development and deployment of scalable decentralized applications. The Blockchain OS offers a Linux operating system coupled with a blockchain infrastructure, which allows DApps to be developed in familiar programming languages like Python without the need to write Solidity code.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 6---










Overview | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
The combination of 
an Optimistic Rollups framework
 and 
the Cartesi Machine Emulator
 enables the development of smart contracts and DApps using any package or library that is available for Linux. This allows developers to break free from the scalability limitations of the Ethereum Virtual Machine (EVM), and brings the rise of a new blockchain era to handle real-life and complex use-cases.
A DApp running on Cartesi Rollups consists of the following main components:
Cartesi Rollups
, a set of on-chain and off-chain components that implement an Optimistic Rollups solution and provide the general framework for building DApps.
Cartesi Machine
, a virtual machine (VM) that runs an entire Linux OS, in which each DApp's 
back-end
 is executed.
DApp Back-end
, the application's state and verifiable logic, which corresponds to the DApp's smart contract. The back-end runs inside the Cartesi Machine as a regular Linux application.
DApp Front-end
, the application's user-facing interface, such as a web app.
The diagram below shows the overall architecture:

note
You can 
run a simple DApp
 that we already built using Python
What is a blockchain rollup?
​
A rollup is a blockchain scalability solution that pushes complex computations "off-chain", meaning that they run on a separate computing environment (layer-2) outside of the main network (layer 1, such as the Ethereum network). When employing rollups, the blockchain's role becomes solely to receive transactions and log them. On rare occasions in which parties disagree with the outcomes of a computation, the blockchain also gets involved in resolving these disputes.
Offloading the blockchain from complex computations along with aggregating and compressing data is expected to increase the number of transactions a blockchain can process by a factor of at least 40x. Additionally, transactions can now involve much more complex logic since applications running in a rollup are able to perform virtually any computation and can also take advantage of more powerful virtual machines (VMs) running on layer-2.
How does a rollup work?
​
Users interact with a rollup through transactions on the base layer (layer 1). They send messages (inputs) to the rollup on-chain smart contracts to define a computation to be processed, and as such advance the state of the computing environment on layer-2. Interested parties run an off-chain component (a layer-2 node) that watches the blockchain for inputs, understanding and executing the state updates.
Once in a while, the state of the machine is checkpointed on-chain, at which point the state is considered to be 
finalized
 and can thus be accepted by any smart contract on layer 1. It is of course vital to ensure this operation is secure, meaning that the layer-2 node needs to somehow 
prove
 the new state to the base layer.
Let’s think about this question:

"How does a blockchain system, such as Ethereum, know that the data posted by an off-chain layer-2 node is valid and was not submitted in a malicious way?"
The answer depends on the rollup implementation, which basically falls within one of two categories according to the type of proof used:
Zero-knowledge Rollups (ZK Rollups)
, which use validity proofs
Optimistic Rollups (ORs)
, which use fraud proofs
In validity proof schemes, every state update comes accompanied by a cryptographic proof, created off-chain, attesting its validity. The update is only accepted if the proof successfully passes verification on-chain. 
Zero-knowledge proofs
 are frequently used for this, which is why these types of rollups are usually referred to as ZK Rollups. Validity proofs bring the big benefit of instant finality — as soon as a state update appears on-chain, they can be fully trusted and acted upon. The choice, however, also brings less than ideal properties: generating ZK proofs for general-purpose computations is, when possible, immensely expensive and each on-chain state update must pay the extra gas fee from including and verifying a validity proof.
Fraud-proof schemes work by a different paradigm. State updates come unaccompanied by proofs, they’re proposed and, if not challenged, confirmed on-chain. Challenging a state update proposal is done by the use of fraud proofs, which can be divided into two categories: non-interactive fraud proofs and interactive fraud proofs.
Non-interactive refers to the fact that the challengers can prove that a state update is invalid in one single step. With interactive fraud proofs, the claimer and challenger have to, mediated by the blockchain, partake in something similar to a verification game. The assumption that state updates will most likely be honest often gives solutions like this the name of Optimistic Rollups. Naturally, this optimism comes paired up with financial incentives for honest behavior and guarantees that, unless the proposed false state is undisputed for a significant amount of time, it will never get accepted.
Summary of a rollup solution
Executes transaction computations off-chain. This way the computations are not carried out by the base layer. Instead, they are executed in a separate computation environment and the rollup protocol ensures transaction validity via either validity proofs or fraud proofs.
Capable of compressing data from several transactions into a bundle to decrease both transaction costs and size, increasing overall efficiency.
Allows blockchains to scale while keeping the security guarantees of its consensus mechanism.
Cartesi Rollups
​
Cartesi’s version of Optimistic Rollups
 uses interactive fraud proofs. The model was chosen because it imposes a higher ceiling to the size of computations that can be executed. In other words, with this model the blockchain base layer is never responsible for executing entire computations: either there are no disputes and no computation takes place there, or, if a dispute occurs, it only needs to compute a single instruction to distinguish between misbehavior and honesty. In either case, the results themselves are always computed off-chain, and as a consequence the computation involved can be massive.
In the next sections, we will first describe 
Cartesi Rollups' internal components
 and how they work. Then, we will explain in detail the 
architecture of DApps
 that run on our rollups framework, as well as the 
APIs that developers can use
 to communicate with it. Finally, we share our vision of a 
step-by-step process for developing applications
 on Cartesi Rollups, from the initial design stage up to its final deployment.
note
You can read the article 
Everything you need to know about Optimistic Rollup
 to get more information about optimistic rollups in general.
note
You can read the article 
Fraud proofs and virtual machines
 or go into more details 
here
See Also
​
Blockchain For Beginners #1 - Smart Contracts With Ethereum & Solidity
What is a blockchain rollup?
How does a rollup work?
Cartesi Rollups
See Also
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 7---










Staking Delegation | Blockchain OS Documentation - Cartesi
























Skip to main content
How to stake
Prerequisites
Run a private node
In this guide, you will learn how to run your own Cartesi node and participate in the staking system. By running a node and staking, you will receive CTSI rewards from Cartesi’s Mine Reserve for each block you produce.
Create a public pool
This guide provides more details for individuals or organizations who intend to provide staking services for users by creating Staking Pools and managing Noether nodes.
FAQs
* Staking
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 8---










8 docs tagged with "build" | Blockchain OS Documentation - Cartesi
























Skip to main content
Choose your Onboarding Path
Our onboarding paths answer the following questions:
Create your first DApp
Once you learned how to run a simple example, it is now time to create one of your own. In order to do this, we will make use of the DApp template available in Cartesi's rollups-examples Github repository. Once again, make sure you have installed all the necessary requirements before proceeding.
General requirements
To start developing applications using Cartesi Rollups, first make sure that the packages listed in this section are all installed and working in your system. The instructions listed below should be enough to turn a fresh copy of the latest Ubuntu LTS distribution into a fully fledged Cartesi development environment.
Overview of building DApps
Navigate to our Quick Start tutorial if you want to build DApps now!
Quick Start
This article explains how to build and interact with a minimalistic Cartesi Rollups application.
Run back-end in Host Mode
When developing an application, it is often important to easily test and debug it. For that matter, it is possible to run the Cartesi Rollups environment in host mode, so that the DApp's back-end can be executed directly on the host machine, allowing it to be debugged using regular development tools such as an IDE.
Scalability
The scalability issue is one of the three parts of the Blockchain Trilemma, along with security and decentralization. Solving the scalability issue refers to any type of improvement within a blockchain system in terms of computational power, throughput, latency, bootstrap time, or cost per transaction. For example, high gas fees make it expensive for users to pay for their transactions within the Ethereum blockchain.
The Blockchain OS
Cartesi, The Blockchain OS, is a layer-2 platform for the development and deployment of scalable decentralized applications. The Blockchain OS offers a Linux operating system coupled with a blockchain infrastructure, which allows DApps to be developed in familiar programming languages like Python without the need to write Solidity code.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 9---










Create your first DApp | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Once you learned how to 
run a simple example
, it is now time to create one of your own. In order to do this, we will make use of the 
DApp template
 available in Cartesi's 
rollups-examples
 Github repository. Once again, make sure you have 
installed all the necessary requirements
 before proceeding.
Setting up the environment
​
First of all, clone the repository as follows:
$ 
git
 clone https://github.com/cartesi/rollups-examples.git
Customizing the DApp
​
Then, use 
create-dapp.sh
 to create a customized DApp:
cd
 custom-dapps
./create-dapp.sh 
<
dapp-name
>
A new directory, 
<dapp-name>
, will be created with all the boiler plate infrastructure needed by the new DApp.
The new DApp will be provided with some basic back-end code, resembling what is available in the sample 
Echo Python DApp
, as explained in the 
previous section
.
Modifying the DApp logic
​
The back-end logic may be found at 
<dapp-name>/<dapp-name>.py
.
The script comes with some reference code, which may be helpful during development.
It may be replaced or extended according to the use case needs.
Setting up the environment
Customizing the DApp
Modifying the DApp logic
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 10---










FAQs | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Staking
Node operation
Fees and costs
Block production and rewards
Security
Terminating your staking operation
Submit other questions
Staking
​
How do I stake?
​
Currently there are 3 different options available to stake CTSI:
You can delegate your CTSI to a decentralized pool of your choice. Each pool has its own commission taken from pool rewards to cover their costs and generate profit. The tutorial to do so is 
here
You are able to stake directly by running your own node to represent your stake. This can be a good option for you if you have a relatively large amount of CTSI and the patience/ability to monitor the node and make sure it's running correctly 24/7. The tutorial for this options is 
here
You can stake indirectly using a 3rd party custodian centralized service, like Binance, CoinOne and MyCointainer. Each service has its own set of policies, rules, fees, etc so make sure to educate yourself on those and ask the 3rd party to clear any of your doubts in case you choose to follow that route.
What's the minimum amount of CTSI to stake?
​
The system doesn't impose a limit (you could even stake only 1 CTSI) but as the setup process has costs that do not depend on the amount you are staking (take a look at the costs 
here
) and running a node does require maintenance, you should evaluate if the combination of (amount of CTSI/duration of staking) is worth the effort. Relatively low stakes do tend to take a lot of time to be able to produce blocks, so having a relatively low stake will probably make sense only if you are planning to stake for a very long time. For relatively small stakes it might be a better idea to join a decentralized pool, or even stake though a 3rd party centralized custodian service, check those options on this other 
FAQ
.
How much CTSI should I put in the allowance?
​
The allowance is the maximum total amount of tokens the pool smart contract can transfer out of your wallet. You can set it to any value you want, your wallet amount, less or more.
You need to input a large enough value to match the amount you want to stake, at least. In case you might want to stake more in the future, you may consider a margin in the amount you set on allowance, otherwise you’ll need to raise the value in the future (and that issues a transaction to the Ethereum blockchain, so it has costs). The value you set in allowance is not bounded by the amount of CTSI you own (if you want to stake and own 300 000 CTSI, you may set the allowance to 1 000 000, for example, so you still can add 700 000 CTSI to your stake without having to change your allowance). Currently the Cartesi Explorer automatically sets the allowance for you with the minimum needed value to allow you to stake the desired amount. There is a checkbox that you can tick to make it set the maximum possible value for that, so you won't need to update the allowance value when increasing your stake in the future.
What browser can I use to access the Cartesi Explorer?
​
Currently we support Chrome and Firefox. Other browsers that support Metamask might work as well, but we provide no guarantees on that.
What is the minimal configuration to run Noether?
​
Current requirements are really low, just a computer or VPS running 24/7, a reliable internet connection and a stable Ethereum Gateway. Your "mining power" is proportional to your stake, not your hardware. Do check periodically for changes in the requirements as they tend to be updated with new releases of Noether.
I want to stake more CTSI, do I need to do something on my node?
​
No, just add your stake using the Cartesi Explorer as you did the first time. You might need to increase the allowance in case you set a limit lower than the final amount of CTSI you want to stake. After placing your new stake and the staking transaction goes through, your CTSI will mature for 6 hours. When the maturation period is over, the CTSI you staked will automatically count towards your block production chances. Keep in mind that if you stake more CTSI while you still have CTSI maturing, the maturation period will be reset for your previously maturing stake.
Can I transfer funds to my node directly from an exchange?
​
Yes you can, just make sure to double-check the address you are sending the funds to is the one of your node as there is no way to "get a refund" on funds transferred to the wrong address.
How much ETH should I fund my node with?
​
It is hard to predict how much you should fund your node with, since there are lots of moving parts like gas price fluctuation, stakes variation and the intrinsic variation in the block production rate. For small stakers, putting enough ETH for the node to accept the hire (~31k gas cost) and produce a couple of blocks (~120k gas per block) should be enough to run the node for some time. That would be roughly 271 x gas_price / 1 000 000 ETH.
There is also a template Google sheet you can use to help you to estimate the ETH amount you need 
here
. You may take a look at sites like 
etherscan gas price history page
 to estimate an average gas price value. Regardless of the amount you fund your node with, it is always a good idea to check on the node to make sure it is still well funded and that it is running fine.
How much ETH do I need?
​
You have to do some math in order to estimate the amount of ETH you'll need for staking.
There is basically a one-time cost to setup the staking operation and a continuous operational cost. You can take a look at the 
gas prices
 associated with each operation involved in the staking process and also at this section about 
the amount of ETH to fund your node with
.
There is also a template Google sheet you can use to help you to estimate the ETH amount you need 
here
.
Cannot authorize CTSI with my ledger, getting a “Ledger device: Invalid data received” error, what’s wrong?
​
You have to enable blind signing in the Ethereum application of your ledger. Procedure from 
Ledger documentation
.
I hired my node in the Cartesi Explorer, but I am stuck with the "Cancel Hire" button in the Explorer. What's going on?
​
It is probably a good idea to check if the hire transaction was correctly processed as it might still be pending due to 
Ethereum Network congestion or a gas price surge
. You can do so by checking your hire transaction status at 
Etherscan
 and inputting your wallet address. If the hire transaction went through, there might be a problem with your node accepting the hire. Check your node's log, copy the tx hash of the accept job transaction (available in your node's log) and take a look at it on Etherscan. If it is taking too long to process or you get an error, do contact us at the 
Cartesi Technical Community on Discord
 so we can provide you some help.
Node operation FAQs
​
How do I update my Cartesi Node?
​
Please check the 
Noether update wiki page
.
How do backup my Cartesi Node wallet?
​
There are 2 alternatives, the more secure one is making a copy of the encrypted wallet file
Backing up the encrypted wallet file
Open a terminal and input this command to make a copy of the encrypted wallet file: docker cp cartesi_noether:/root/.ethereum/key key.backup. It will create a file called key.backup on the current directory that is a copy of your node's encrypted wallet
Backing up the wallet mnemonic
Open a terminal and input this command to export the wallet mnemonic: docker run -it -v cartesi_wallet:/root/.ethereum cartesi/noether export. It will print the 12-word mnemonic that can be used to generate the node's wallet. As this is not encrypted, take extra care on how to store it since anyone in possession of this can directly derive your node wallet and manipulate its funds.
How do I change my Ethereum Network Gateway?
​
Stop your node (one way to do it is using the docker kill cartesi_noether command on a terminal, if you are using the default name for the node container)
Edit the command you used to start your node before (it should be something like this docker pull cartesi/noether; docker run -it --rm --name cartesi_noether -v cartesi_wallet:/root/.ethereum cartesi/noether --url <YOUR_OLD_ETHEREUM_GATEWAY_URL_HERE> --wallet /root/.ethereum/key --create --verbose), replacing the value in the --url parameter with the url of the new Ethereum Network Gateway you wish to use (example: old value --url 
https://myoldethgateway.com
 and new value --url 
https://mainnet.infura.io/v3/your_infura_project_id_here
)
Start your node using the command from the previous step, enter your password when prompted
If you are on a terminal, once your node resumes operations, detach from it (default key sequence is ctrl+p followed by ctrl+q, you can learn more about attaching to/detaching from a container in the official 
docker documentation
) so your node keeps running once you close the terminal
I am getting some network errors in my node's log, should I worry?
​
It depends on the type of error and frequency as having your node not working when eligible to produce will prevent it from producing a block and getting the associated reward. A common source of errors is using an unstable Ethereum Gateway, it causes errors similar to this one:
ERROR: Error: processing response error (body="{"jsonrpc":"2.0","error":{"code":-32600,"message":"Invalid Request. Requested data is older than 128 blocks."},"id":25035}", error={"code":-32600}, requestBody="{"method":"eth_call","params":
[{"from":"your_node_address","to":"0x9edeadfde65bcfd0907db3acdb3445229c764a69","data":"some_payload_data"},"latest"]
,"id":25035,"jsonrpc":"2.0"}", requestMethod="POST", url="
https://eth.cartesi.io/"
, code=SERVER_ERROR, version=web/5.0.12)
In case you are getting those, it highly advised to 
switch to a stable Ethereum Gateway
(Infura is a good option and the free tier is enough to run a single node)
If I turn off my computer/close the browser window/close the terminal, will my node keep running?
​
It depends on how you are running your node. If you are running a docker node on a VPS, make sure to detach from the container before closing your session, so the container keeps running. You can detach from a docker container using the default escape sequence of ctrl+p followed by ctrl+q. You can learn more about attaching to/detaching from a container in the 
official docker documentation
. If you are running a docker container in your local computer, and you manually started the container in a terminal, you have to detach from the container before closing the terminal, so it keeps running in the background. If you used some graphical interface to start your container, you can probably close it safely and your container will continue running in the background but do check your specific tool documentation to make sure of it. When you are running a local node, your node can only run when your computer is on, so if you shutdown your computer, you will not produce blocks when eligible during that period.
My node displays messages repeatedly containing canProduce=false/eligibleForNextBlock=false is this normal?
​
Yes, that is normal and it is expected to be shown at approximately 30 second intervals. The node periodically pools the Blockchain to check the stake of the user it represents, prints the stake status in the log and then pools the blockchain to check if it is eligible to produce a block at the moment. If it isn't (and that is the case most of the times) it prints an entry containing canProduce=false or eligibleForNextBlock=false to display the result of that check. After that it will sleep for 30 seconds and try this procedure again. In case it returns true, the node will then issue a transaction to try to produce a block.
My node experienced an error while trying to produce a block. The message it shows in the transaction is 'User couldnt produce a block successfully', what is going on?
​
That means that you were not eligible to produce a block when your transaction was processed. That can happen for a few reasons. The most common reason is losing a race to produce the block to another eligible user: the competing user had his transaction processed before and when your transaction was processed the block was no longer available. Another cause can be there was a sudden surge on gas prices after or transaction was sent, so when gas prices got back to values compatible with the price set on your transaction, your window to claim a block has already passed. A more uncommon reason is if your Ethereum network provider answers from an out-of-synch node, so your node believes it is eligible for producing a block when in reality it is not.
Why does my Infura/Alchemy/other Ethereum Gateway show so many requests if my node has not produced any blocks?
​
The Ethereum Gateway requests are used for any sorts of operations not just for producing blocks. Your node pools the Ethereum blockchain at 30s intervals to check if it is eligible for producing a block. That check requires multiple “read-only” operations on the Ethereum blockchain and they all count as requests in your Ethereum Gateway. As those operations are “read-only” they don’t require issuing transactions nor spend any gas.
My node is not displaying the periodic status message, what is wrong?
​
You probably have mistyped/cut the last parameter of the command to start your node (--verbose), the node will not print the periodic messages if that parameter is not set.
My node is displaying only “sleeping for 30 seconds” messages, is this normal?
​
It means your node was not hired yet. If you haven’t done so, copy your node address and go to the Cartesi Explorer to hire your node. If you already have, you may want to check the status of the transaction for hiring your node, it might be still pending.
My node displaying a low funds warning, what should I do?
​
Producing a block demands spending gas. When your node funds are below a certain value, the node starts to display a low funds warning to remind you to refund your node as not having enough ETH in the node's wallet when you are eligible to produce a block will prevent you from doing so, thus not earning the block production reward.
My node has a message saying waiting for confirmation for X minutes is something wrong?
​
When you issue a transaction on the Ethereum Network, the time for it to be processed depends on multiple factors like how busy the network is, the amount of pending transactions, current gas prices, etc. The Nother node uses the average gas price of recently processed transactions and a gas price multiplier when setting the transaction gas price in order to avoid having the transaction pending for long. Still, it is possible that there is a sudden gas price surge and your transaction gets stuck on the transaction pool. If that happens when trying to produce a block, it might delay the transaction enough so that another user produces the block before you and, when the transaction is processed, it reverts because you are no longer eligible to produce a block. This should not happen frequently, so if you are experiencing this a lot, let us know to check if there is something wrong with your node.
Fees and costs FAQs
​
Why are the ETH fees I am paying so high?
​
The ETH fees to process a transaction depend on the amount of gas that is required to process the transaction and also on the gas price set when the transaction was issued. Noether sets transaction gas price using the average gas price of the recently processed blocks, multiplied by a scaling factor so that it is unlikely that the transactions stay pending for a long time. Bare in mind that gas prices usually fluctuate a lot and rapidly. You may check current gas prices in sites like 
https://etherscan.io/gastracker
 and 
https://ethgasstation.info/
 .
How much ETH do the transactions involved in staking CTSI cost?
​
You have to do some math in order to estimate the final ETH cost and the effective cost depends on the current gas price at the time it is performed. Keep in mind that while you can choose when to perform most of the setup related operations in order to process them in periods of low gas prices, block production is time sensitive, so you won't have control over gas prices for that.
The costs involved in the node setup are:
Authorizing the PoS contract to access your wallet CTSI: ~44k gas (from user wallet)
Stake CTSI: ~69k gas (from user wallet)
Hire and authorize node to represent you: ~124k gas + amount of eth you fund your node with (from user wallet)
Node accept to be hired: ~31k gas (from node wallet)
The costs involved in terminating your operation are:
Retiring the node: ~ 31k gas (from user wallet)
Unstaking CTSI: ~57k gas (from user wallet)
Withdraw the CTSI after the unstaking lock period: ~33k gas (from user wallet)
Node return the eth it has to your user wallet: 21k gas (from node wallet)
The costs involved in normal operations are:
Successful block production: 120k gas (from node wallet)
Reverted block production transaction: ~65k gas (from node wallet)
Transferring more funds to node: 21k gas + amount of eth you fund your node with (from user wallet)
Why pay for blocks that failed to be produced?
​
Unfortunately it is unavoidable. In some cases, more than one user can be eligible and try to produce the same block. When that happens the first user to have the transaction processed will probably succeed and the others will no longer be eligible when their transactions are processed, so they will revert. That is expected and is part of the protocol. Since reverted transactions still spend gas on Ethereum, that means that you spend ETH when that happens. Those should not be frequent though, so if you are experiencing a high rate of reverted transactions, please let us know so we can help you check if there is something wrong with your node.
Block production and rewards FAQs
​
My node is not producing the amount of blocks I expected
​
The mining is a probabilistic process with multiple variables involved. In practice the difficulty varies constantly and considerably as nodes that are eligible to produce a block don't always do so (due to multiple factors such as an Ethereum network provider outage), globally staked values change a lot (multiple new users staking, some withdrawals, users increasing stakes, etc), plus the intricate entropy of the process itself due to security reasons. The system itself is designed in a way that if you take a group of nodes with certain stakes and leave them running for a really long time, when you take a look at the blocks produced by each node, they will have the same proportion as their stakes (a node with 10% of the stakes will have 10x more blocks than one with 1%, etc), but even in this ideal scenario, if you take a look at smaller time windows, the individual block production of each node will fluctuate due to the probabilistic nature of the process (a node that produces on average 3 blocks a day will have days producing 0 blocks, 2 blocks, 5 blocks, etc, for example, but the average block production will follow the same proportion that it's stake has to the total stake). An analogy to understand the probabilistic nature of the PoS system is thinking about a lottery. Just like if purchasing 1/4 of the tickets in a series of draws doesn't mean you will win 1 in every 4 draws, but rather will win 1 out of 4 draws on average, the same happens with your block production.
One thing to keep in mind is that comparing your block production with others in the Cartesi Explorer is not an apples to apples comparison. The explorer only shows the current stake of the users (and users often increase/decrease their stake through time), most users have been staking for different durations and probably in times with different mining difficulties.
What is the reward per block produced?
​
Currently the reward is 2900 CTSI, this value is bound to last for approximately 6 months. You may read more about this on the 
Medium post
.
How can I have a grasp on what to expect for my block production?
​
The PoS is probabilistic, so there is no way to tell exactly what is going to happen. However, making some simplifications on the PoS model, it's possible to calculate some averages that can give some insight on what to expect. Given this simplified model, you can tweak the parameters for a "best case" and a "worst case" scenario so you obtain a range of likely outcomes. The simplified model we'll describe considers constant stakes from all users, constant block rewards and nodes perfectly functional 24/7 among other differences from the real system. The logic to calculate this simplified model's output is summarized bellow:
# user_stake is an input of the model
# total_stakes is an input of the model
user_stake_percent = user_stake / total_stakes
# num_days is an input of the model
# blocks_per_day is the average number of blocks produced by the PoS, currently it's ~48 (~30min between blocks)
total_blocks = num_days * blocks_per_day
# this uses the values calculated above
blocks_by_user = user_stake_percent * total_blocks
# blocks_by_user is calculated above
# block_reward has the value of the current block reward, currently it's 2900 CTSI/block
projected_period_rewards = blocks_by_user * block_reward
# user_stake_percent is calculated above
# blocks_per_year is the average number of blocks produced by the PoS in a year, currently it's ~17520 (~30min between blocks)
# block_reward has the value of the current block reward, currently it's 2900 CTSI/block
# user_stake is an input of the model
projected_annual_earnings = (user_stake_percent * blocks_per_year * block_reward) / user_stake
Some things to bare in mind when using this model:
The PoS system is probabilistic and the output of the model is an expected average. You can understand what that means with an example: if you got a reward for flipping a coin and getting a head, and you flipped a coin twice, you could have 3 possible outcomes (disregarding the order): two heads, two tails or a head and a tail. The actual reward you could get would be nothing, one or two rewards, but the average reward if you had a large number of people doing that, would be very close to one. That average value for a very large number of users within the given situation is what the model outputs. It is very useful for having a grasp on what to expect but in practice what actually happens in your case will probably not match that exact output.
The model considers constant difficulty, stakes, reward values, etc on it's calculations. In practice, difficulty varies a lot due to multiple reasons (nodes are not online and working perfectly 24/7, users withdraw and stake CTSI all the time, etc) so when using the model it is wise to simulate a couple of extreme scenarios, one with a very high total staked value, to use as worst-case scenario, and another one with a very low total staked value, to use as a best-case scenario. Those are useful to have a better range of what to expect.
Your node only produces blocks when functioning properly, so the more it is interrupted and has problems, the more your results will probably diverge from the value provided by the model.
Is it better to run my own node, join a decentralized pool or to use a 3rd-party custodian service to stake?
​
It is a personal choice and one option might be better suited to you depending on your requirements and expectations. The three options have different advantages and disadvantages. Running your own node requires some technical proficiency, has 
higher setup costs
 and requires a certain amount of time and energy to maintain your node running correctly, but provides you with the full rewards of the blocks produced using your stake. Joining a decentralized pool through the 
Cartesi Explorer
 you'll get rewards whenever the pool produces block - proportional to the cut of your stake on the pool - so you'll get more frequent but diluted rewards comparing to staking by yourself. The pool also gets a cut of the rewards, which is the setup poll commission: it's intended to cover the costs of running a pool and also give some reward to the pool manager for doing so. When using a pool you don't have to worry about maintaining a node, that's the pool manager's job, but you should monitor the pool performance to make sure it's node is being well taken care of. Decentralized pools are safe: withdrawing your CTSI demands having control over the wallet associated to those funds. Using a 3rd party custodian service is generally simpler and faster to setup, demands lower technical proficiency and the custodian service takes care of having the node up and running, but that comes at a cost: each custodian service takes a cut of the rewards and has its own fees and reward distribution policy, so do educate yourself on those if deciding for this option. When using a custodian service, staking rewards have a similar behavior to decentralized pools in terms of rewards frequency: while directly staking relatively low values will probably take a very long time to produce a block and generate rewards, custodian services generally distribute rewards on a frequent basis (though very diluted amounts). One last important point is that, from the blockchain point of view, your CTSI is owned by the custodian service (since it's under it's wallet's control) so you have to trust it to behave correctly.
Does running more nodes/running on a more powerful hardware/etc increase block production chances?
No, it doesn't. The only factor that increases your "mining power" is having a larger share of the total stakes. If the total stakes decrease and your stake is the same, your block production chances increase. If you increase your stake, your block production chances increase. On the other hand if the total stakes increase and your stake is the same, your chances decrease and the same applies in case you lower your stake.
Security FAQs
​
If my node is compromised, can the attacker steal all my CTSI?
​
No, your node’s wallet holds only the ETH you fund it with (used by your node to accept being hired during setup, trying to produce blocks on regular operation, and to return funds to your wallet in case you retire the node) so an attacker that compromises your node can only possibly steal that. Your staked CTSI is locked in the PoS contract and can only be manipulated using your wallet, not the node wallet.
If I lose/delete my node is my CTSI/eth safe?
​
Yes, your node’s wallet holds only the ETH you fund it with (used by your node to accept being hired during setup, trying to produce blocks on regular operation, and to return funds to your wallet in case you retire the node) so if lose access to or delete your node you will only lose access to that ETH you funded your node with. Your staked CTSI is locked in the PoS contract and can only be manipulated using your wallet, not the node wallet.
Terminating your staking operation
​
I have retired my node in the Cartesi Explorer but the node funds were not returned. What is going on?
​
When you issue retiring your node, you issue a transaction in the Ethereum Blockchain that revokes the right of the node to produce blocks representing your stake. As any Ethereum Blockchain transaction it may take a while for it to be processed, especially when the network is under heavy load and gas prices surge. Once the retire transaction is processed, the node will detect it when pooling the blockchain and will issue a transaction to return the funds it holds to the user wallet. When this happens, the node prints a couple of messages in the log stating it was retired and that it is returning the funds it holds. Don't stop or destroy your node before you double-check this transaction went through and the funds were returned to your wallet. In case you stopped your node before it issued the transaction to return your funds, please start it and wait for the transaction to be issued and correctly processed.
When can I delete my node?
​
Your node holds a wallet that contains the funds you provided it with, so it is safe to delete your node once you made sure that there are no funds in the node wallet. Double-check or even triple-check before deleting your node as there is no way to move the funds from the node wallet once it is destroyed.
Submit a new question
​
Ok, so I read all the F.A.Q. and found no solution to my problem/the proposed solution failed, what should I do?
We are sorry to hear that, please head to the 
Cartesi Technical Community on Discord
 and we’ll be happy to assist you or submit your question on 
StackOverflow
.
Staking
How do I stake?
What's the minimum amount of CTSI to stake?
How much CTSI should I put in the allowance?
What browser can I use to access the Cartesi Explorer?
What is the minimal configuration to run Noether?
I want to stake more CTSI, do I need to do something on my node?
Can I transfer funds to my node directly from an exchange?
How much ETH should I fund my node with?
How much ETH do I need?
Cannot authorize CTSI with my ledger, getting a “Ledger device: Invalid data received” error, what’s wrong?
I hired my node in the Cartesi Explorer, but I am stuck with the "Cancel Hire" button in the Explorer. What's going on?
Node operation FAQs
How do I update my Cartesi Node?
How do backup my Cartesi Node wallet?
How do I change my Ethereum Network Gateway?
I am getting some network errors in my node's log, should I worry?
If I turn off my computer/close the browser window/close the terminal, will my node keep running?
My node displays messages repeatedly containing canProduce=false/eligibleForNextBlock=false is this normal?
My node experienced an error while trying to produce a block. The message it shows in the transaction is 'User couldnt produce a block successfully', what is going on?
Why does my Infura/Alchemy/other Ethereum Gateway show so many requests if my node has not produced any blocks?
My node is not displaying the periodic status message, what is wrong?
My node is displaying only “sleeping for 30 seconds” messages, is this normal?
My node displaying a low funds warning, what should I do?
My node has a message saying waiting for confirmation for X minutes is something wrong?
Fees and costs FAQs
Why are the ETH fees I am paying so high?
How much ETH do the transactions involved in staking CTSI cost?
Why pay for blocks that failed to be produced?
Block production and rewards FAQs
My node is not producing the amount of blocks I expected
What is the reward per block produced?
How can I have a grasp on what to expect for my block production?
Is it better to run my own node, join a decentralized pool or to use a 3rd-party custodian service to stake?
Security FAQs
If my node is compromised, can the attacker steal all my CTSI?
If I lose/delete my node is my CTSI/eth safe?
Terminating your staking operation
I have retired my node in the Cartesi Explorer but the node funds were not returned. What is going on?
When can I delete my node?
Submit a new question
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 11---










Target perspective | Blockchain OS Documentation - Cartesi
























Skip to main content
Overview
The goal of the target perspective is to serve both target application-developers and target system-developers.
Linux environment
The host perspective section describes in detail the cartesi-machine command-line utility and the general structure of Cartesi Machines.
System architecture
The RISC-V ISA, on which Cartesi Machines are based, consists of a minimal 32-bit integer instruction set to which several extensions can be added.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 12---










One doc tagged with "cycle" | Blockchain OS Documentation - Cartesi
























Skip to main content
DApp life cycle
Now that we have described the architecture of a Cartesi DApp and how the front-end and back-end communicate with the Cartesi Rollups framework, let’s step back a bit to discuss how a DApp can be implemented in practice.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 13---










System architecture | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
The RISC-V ISA, on which Cartesi Machines are based, consists of a minimal 32-bit integer instruction set to which several extensions can be added.
The standard defines a privileged architecture with features commonly used by modern operating systems, such as multiple privilege levels, paged-based virtual-memory, timers, interrupts, exceptions and traps, etc.
Implementations are free to select the combination of extensions that better suit their needs.
The Cartesi Machine architecture can be separated into a processor and a board.
The processor performs the computations, executing the traditional fetch-execute loop while maintaining a variety of registers.
The board defines the surrounding environment with an assortment of memories (ROM, RAM, flash drives, rollup memory ranges) and a number of devices.
To make verification possible, a Cartesi Machine maps its entire state to the physical address space in a well-defined way.
This includes the internal states of the processor, the board, and of all attached devices.
The contents of the address space therefore completely define the Cartesi Machine.
Fortunately, this modification does not limit the operating system or the applications it hosts in any significant way.
Both the processor and board are implemented in the emulator.
A full description of the RISC-V ISA is out of the scope of this documentation (See the volumes 
1 and 2
 of the ISA specification for details.)
This section describes Cartesi's RISC-V architecture, the modifications made to support verification, the devices supported by the emulator, and the process the machine follows to boot the Linux kernel.
The processor
​
Following RISC-V terminology, Cartesi Machines implement the 
RV64IMAZicsr_Zifencei
 ISA.
The letters after RV specify the extension set.
This selection corresponds to a 64-bit machine, integer arithmetic with multiplication and division, atomic operations, as well as the optional supervisor and user privilege levels.
In addition, Cartesi Machines support the Sv39 mode of address translation and memory protection.
Sv39 provides a 39-bit protected virtual address space, divided into 4KiB pages, organized by a three-level page table.
This set of features creates a balanced compromise between the simplicity demanded by a blockchain implementation and the flexibility expected from off-chain computations.
There are a total of 98 instructions, out of which 28 simply narrow or widen, respectively, their 64-bit or 32-bit counterparts.
This being a RISC ISA, most instructions are very simple and can be emulated in a few lines of high-level code.
In contrast, the x86 ISA defines at least 2000 (potentially complex) instructions.
In fact, the only complex operation in RISC-V is the virtual-to-physical address translation.
Instruction decoding is particularly simple due to the reduced number of formats (only 4, all taking 32-bits).
The entire processor state fits within 512
 
bytes, which are divided into 64 registers, each one holding 64-bits.
It consists of 32 general-purpose integer registers and 26 control and status registers (CSRs).
Most of these registers are defined by the RISC-V
 
ISA; the remaining are Cartesi-specific.
The processor makes its entire state available, externally-only and read-only, by mapping individual registers to the lowest 512 bytes in the physical address space (in the 
processor shadow
).
The adjacent
 
1.5KiB are reserved for future use.
The entire mapping is given in the following table:
Offset
 
Register
Offset
 
Register
Offset
 
Register
Offset
 
Register
0x000
 
x0 
0x120
 
mcycle
0x160
 
misa
0x1a0
 
sepc
0x008
 
x1 
0x128
 
minstret
0x168
 
mie
0x1a8
 
scause
…
 
…
0x130
 
mstatus
0x170
 
mip
0x1b0
 
stval
0x0f8
 
x31
0x138
 
mtvec
0x178
 
medeleg
0x1b8
 
satp
0x100
 
pc
0x140
 
mscratch
0x180
 
mideleg
0x1c0
 
scounteren
0x108
 
mvendorid
0x148
 
mepc
0x188
 
mcounteren
0x1c8
 
ilrsc
0x110
 
marchid
0x150
 
mcause
0x190
 
stvec
0x1d0
 
iflags 
0x118
 
mimpid
0x158
 
mtval
0x198
 
sscratch
 
The only generally relevant standard register is
 
mcycle
.
Since its value is advanced at every CPU cycle, it can be used to identify a particular step in the computation being performed by a Cartesi Machine.
This is a key component of the verification process, and can also be used to bound the amount of computation.
The registers whose names start with 
“
i
”
 are Cartesi additions, and have the following semantics:
The layout for register
 
iflags
 can be seen below:
 Bits 
63–5
4–3
2
1
0
 Field 
Reserved
PRV
X
Y
H
Bit 
PRV
 gives the current privilege level (0 for User, 1 for Supervisor, and 3 for Machine), bit 
X
 is set to 1 when the processor has yielded automatic, bit 
Y
 is set to 1 when the processor has yielded manual, bit 
H
 is set to 1 to signal the processor has been permanently halted.
Register
 
ilrsc
 holds the reservation address for the
 
LR/SC atomic memory operations;
The board
​
The interaction between board and processor happens through interrupts and the memory bus. Devices are mapped to the processor's physical address space.
The mapping can be seen in the following table:
 Physical address 
 Mapping 
 
0x00000000–0x000003ff
 
 Processor shadow 
 
0x00000800–0x00000bff
 
 Board shadow 
 
0x00001000–0x000ffff
 
 ROM (Bootstrap & Devicetree) 
 
0x02000000–0x020bffff
 
 Core Local Interruptor 
 
0x40008000–0x40008fff
 
 Host-Target Interface 
 
 0x60000000–0x600fffff
  (
configurable
) 
 Rollup RX buffer 
 
 0x60200000–0x602FFFFF
  (
configurable
) 
 Rollup TX buffer 
 
 0x60400000–0x60400FFF
  (
configurable
) 
 Rollup Input Metadata 
 
 0x60600000–0x606FFFFF
  (
configurable
) 
 Rollup Voucher Hashes 
 
 0x60800000–0x608FFFFF
  (
configurable
) 
 Rollup Notice Hashes 
 
0x80000000–
configurable
 
 RAM 
 
 configurable 
 
 Flash drive 0 
 …
 …
 
 configurable 
 
 Flash drive 7 
There are 60KiB of ROM starting at address
 
0x1000
, where execution starts by default.
The amount of RAM is user-configurable, but always starts at address
 
0x80000000
.
Finally, a number of additional physical memory ranges can be set aside for flash-memory devices.
These will typically be preloaded with file-system images, but can also hold raw data.
The board maps two non-memory devices to the physical address space: CLINT and HTIF.
CLINT
​
The Core Local Interruptor (or CLINT) controls the timer interrupt.
The active addresses are
 
0x0200bff8
 
(
mtime
) and
 
0x02004000
 
(
mtimecmp
).
The CLINT issues a hardware interrupt whenever
 
mtime
 equals
 
mtimecmp
.
Since Cartesi Machines must ensure reproducibility, the processor's clock and the timer are locked by a constant frequency divisor of
 
100
.
In other words, 
mtime
 is incremented once for every 100 increments of
 
mcycle
.
There is no notion of wall-clock time.
HTIF
​
The Host-Target Interface (HTIF) mediates communication with the external world.
It is mapped to a physical memory starting at 
0x40008000
, where registers can be accessed at the following offsets:
Offset
 
Register
0x000
 
tohost
0x008
 
fromhost
0x010
 
ihalt
0x018
 
iconsole
0x020
 
iyield
0x028
 
Reserved
…
 
…
0x218
 
Reserved
The format of CSRs 
tohost
 and 
fromhost
 are as follows: 
 Bits 
63–56
55–48
47–0
 Field 
DEV
CMD
DATA
Interactions with Cartesi's HTIF device follow the following protocol:
start by writing 0 to 
fromhost
;
write the 
request
 to 
tohost
;
read the 
response
 from 
fromhost
.
Cartesi's HTIF supports 3 subdevices: Halt, Console, and Yield.
These are identified by the following values for the field 
DEV
.
 `DEV` 
 Name 
 Value 
HTIF_DEVICE_HALT
0
HTIF_DEVICE_CONSOLE
1
HTIF_DEVICE_YIELD
2
Registers 
ihalt
, 
iconsole
, and 
iyield
 are bit masks specifying the commands that are available for the respective devices.
Unavailable commands are silently ignored by the machine.
Halt
​
 `CMD` 
 Name 
 Value 
HTIF_HALT_HALT
0
The Halt device (
DEV=HTIF_DEVICE_HALT
) is used to halt the machine.
This will permanently set bit 
H
 in 
iflags
 and return control back to the host.
Send request 
CMD=HTIF_HALT_HALT
 and 
DATA
 containing bit 0 set to
 
1.
Bits 47
–
1 can be set to an arbitrary exit code.
Console
​
 `CMD` 
 Name 
 Value 
HTIF_CONSOLE_GETCHAR
0
HTIF_CONSOLE_PUTCHAR
1
The Console device (
DEV=HTIF_DEVICE_CONSOLE
) can be used to input/output characters.
To input a  character from console (in interactive sessions), request 
CMD=HTIF_CONSOLE_GETCHAR
, 
DATA=0
, then read response 
CMD=HTIF_CONSOLE_GETCHAR
, 
DATA=<ch>+1
. (
DATA=0
 means no character was available);
To output a character 
<ch>
 to console, request 
CMD=HTIF_CONSOLE_PUTCHAR
, with 
DATA=<ch>
.
Yield
​
The Yield device can be used to return control to the host.
It uses a slight refinement to the format of CSRs 
tohost
 and 
fromhost
, by splitting out a 
REASON
 field from 
DATA
:
 Bits 
63–56
55–48
47–32
31–0
 Field 
DEV
CMD
REASON
DATA
There are two types of yield: 
automatic
 and 
manual
.
 `CMD` 
 Name 
 Value 
HTIF_YIELD_AUTOMATIC
0
HTIF_YIELD_MANUAL
1
To issue an automatic yield, request 
CMD=HTIF_YIELD_AUTOMATIC
.
An automatic yield sets the bit 
X
 in 
iflags
 and returns control back to the host.
There are currently 4 supported reasons for automatic yields:
 `REASON` 
 Name 
 Value 
HTIF_YIELD_REASON_PROGRESS
0
HTIF_YIELD_REASON_TX_VOUCHER
3
HTIF_YIELD_REASON_TX_NOTICE
4
HTIF_YIELD_REASON_TX_REPORT
5
To report 
progress
, set 
REASON=HTIF_YIELD_REASON_PROGRESS
, and 
DATA=<permil>
, where 
<permil>
 gives the progress in parts per thousand.
The other reasons for automatic yield signal the production of Cartesi Rollups responses.

REASON=HTIF_YIELD_REASON_TX_VOUCHER
, 
REASON=HTIF_YIELD_REASON_TX_NOTICE
, and 
REASON=HTIF_YIELD_REASON_TX_REPORT
 denote, respectively, transfers of a voucher, a notice, and a report from target to host.
The 
DATA
 field in 
tohost
 is ignored in these cases.
To issue a manual yield, request 
CMD=HTIF_YIELD_MANUAL
.
A manual yield sets the bit 
Y
 in 
iflags
 and returns control back to the host.
There are currently 3 supported reasons for manual yields, all used with Cartesi Rollups:
 `REASON` 
 Name 
 Value 
HTIF_YIELD_REASON_RX_ACCEPTED
1
HTIF_YIELD_REASON_RX_REJECTED
2
HTIF_YIELD_REASON_TX_EXCEPTION
6
To accept or reject the previous request, set 
REASON=HTIF_YIELD_REASON_RX_ACCEPTED
 or

REASON=HTIF_YIELD_REASON_RX_REJECTED
, respectively.
The 
DATA
 field in 
tohost
 is ignored in these cases.
Upon return, the 
DATA
 field in 
fromhost
 will contain the type of the next request:
 `DATA` in response 
 Name 
 Value 
HTIF_YIELD_ADVANCE_STATE
0
HTIF_YIELD_INSPECT_STATE
1
The signal the throwing of a rollup exception, set 
REASON=HTIF_YIELD_REASON_TX_EXCEPTION
.
The 
DATA
 field in 
tohost
 is ignored in this case.
Before resuming the emulator after a manual yield, the host must manually reset the 
Y
 bit in 
iflags
.
Otherwise, the emulator will immediately return with no changes to its state.
Rollup
​
In order to interact with Cartesi Rollups, the host application controlling the emulator and the target application running inside the emulator  must follow an agreed-upon protocol, mediated by the HTIF Yield device.
The low-level view of what happens inside the machine is as follows:
Initialize
Repeat
    `voucher_index` = 0
    `notice_index` = 0
    `reason` = HTIF_YIELD_REASON_RX_ACCEPTED
    Yield manual with `reason` as `REASON` in `tohost`
    If `DATA` in `fromhost` is `HTIF_YIELD_ADVANCE_STATE`
        Read input metadata from Rollup Input Metadata
        Read input data from Rollup RX Buffer
        Process advance-state request
        For each voucher to emit
            Write voucher data to Rollup TX Buffer
            Write voucher hash to slot `voucher_index` in Rollup Voucher Hashes
            `voucher_index` = `voucher_index` + 1
            Yield automatic with HTIF_YIELD_REASON_TX_VOUCHER as `REASON` in `tohost`
        End
        For each notice to emit
            Write notice data to Rollup TX Buffer
            Write notice hash to slot `notice_index` in Rollup Notice Hashes
            `notice_index` = `notice_index` + 1
            Yield automatic with HTIF_YIELD_REASON_TX_NOTICE as `REASON` in `tohost`
        End
        For each report to emit
            Write report data to Rollup TX Buffer
            Yield automatic with HTIF_YIELD_REASON_TX_REPORT as `REASON` in `tohost`
        End
        If exception to emit
            Write exception data to Rollup TX Buffer
            Yield automatic with HTIF_YIELD_REASON_TX_EXCEPTION as `REASON` in `tohost`
        ElseIf input rejected
            `reason` = HTIF_YIELD_REASON_RX_REJECTED
        End
    End
    If `DATA` in `fromhost` is `HTIF_YIELD_INSPECT_STATE`
        Read query data from Rollup RX Buffer
        Process inspect-state request
        For each report
            Write report data to Rollup TX Buffer
            Yield automatic with HTIF_YIELD_REASON_TX_REPORT as `REASON` in `tohost`
        End
        If exception
            Write exception data to Rollup TX Buffer
            Yield automatic with HTIF_YIELD_REASON_TX_EXCEPTION as `REASON` in `tohost`
        ElseIf input rejected
            `reason` = HTIF_YIELD_REASON_RX_REJECTED
        End
    End
End
At a higher level, the target application running inside the emulator is supported by the 
/dev/rollup
 Linux device driver via its 
ioctl
 interface, or by even higher-level interfaces based on it, such as 
/opt/cartesi/bin/rollup
 command-line utility or the HTTP API exposed by the 
/opt/cartesi/bin/rollup-http-server
 command-line utility.
It is the 
/dev/rollup
 device that copies data to and from all rollup memory ranges, and that uses the 
/dev/yield
 device to perform the required yields.
There are two types of request: advance-state requests and inspect-state requests.
The loop processes one request per iteration.
To transition between requests, the application accepts or rejects the previous request by issuing a command to the HTIF yield device, or throws an exception.
The return from the yield defines the type of the next request.
When the application identifies an advance-state request, it obtains input medatada from the Rollup Input Metadata memory range, and input from the Rollup RX Buffer memory range.
While processing advance-state requests, the application can emit vouchers, notices, reports, or exceptions.
It writes the data for all these to the Rollup TX buffer memory range.
Moreover, when emitting the ith voucher (respectively, notice) in response to a given input, it writes its hash to the ith 32-byte slot in the Rollup Voucher Hashes (respectively, Rollup Notice Hashes) memory range.
It then issues the appropriate command to the HTIF yield device.
When an application identifies an inspect-state request, it obtains the query from the Rollup RX buffer memory range.
While processing inspect-state requests, the application can emit vouchers, or exceptions.
It writes data for all these to the Rollup TX buffer memory range and sends the appropriate command to the HTIF yield device.
The format for all these request and response data are as follows: 
Format for input metadata
Offset (bytes) 
 
Field
0–31
 
message sender (address hash)
32–63
 
block number (number)
64–95
 
time stamp (number)
96–127
 
epoch index (number)
128–159
 
input index (number)
Format for voucher
Offset (bytes) 
 
Field
0–31
 
address (address hash)
32–63
 
offset (number, always 64)
64–95
 
length (number)
96–96+length-1
 
payload (raw data)
Format for input, notice, report, and exception 
Offset (bytes) 
 
Field
0–31
 
offset (number, always 32)
32–63
 
length (number)
64–64+length-1
 
payload (raw data)
All numbers are encoded as 256-bit big-endian integers. Address hashes are encoded in the least significant 160-bits of a zero-padded 256-bit big-endian integer.
In the host, the loop is as follows:
While bit `H` in `iflags` is not set (machine has not halted)
    Snapshot machine state
    Resume machine
    If bit `Y` in `iflags` is set (i.e. manual yield)
        If `REASON` in `tohost` is HTIF_YIELD_REASON_RX_REJECTED
            Discard vouchers and notices emitted from previous request, if any
            Rollback machine state
        End
        If `REASON` in `tohost` is HTIF_YIELD_REASON_TX_EXCEPTION
            Read exception data from Rollup TX Buffer
            Discard vouchers and notices emitted from previous request, if any
            Rollback machine state
        End
        If `REASON` in `tohost` is HTIF_YIELD_REASON_RX_ACCEPTED
            If previous request was advance-state
                Read Rollup Voucher Hashes for previous request
                Read Rollup Notice Hashes for previous request
            End
            Obtain the next request from an external source
            If advance-state request
                Clear Rollup Voucher Hashes
                Clear Rollup Notice Hashes
                Write input data to Rollup RX Buffer
                Write input metadata to Rollup Input Metadata
                Write HTIF_YIELD_ADVANCE_STATE to `DATA` in `fromhost`
            End
            If inspect-state request
                Write query data to Rollup RX Buffer
                Write HTIF_YIELD_INSPECT_STATE to `DATA` in `fromhost`
            End
            Clear `Y` bit in `iflags`
        End
    End
    If bit `X` in `iflags` is set (i.e. automatic yield)
        If `REASON` in `tohost` is HTIF_YIELD_REASON_TX_VOUCHER
            Read voucher data from rollup memory ranges
        End
        If `REASON` in `tohost` is HTIF_YIELD_REASON_TX_NOTICE
            Read notice data from rollup memory ranges
        End
        If `REASON` in `tohost` is HTIF_YIELD_REASON_TX_REPORT
            Read report data from Rollup TX Buffer
        End
    End
End
In production, the host application controlling the emulator is the Server Manager
While prototyping, it can be the 
cartesi-machine
 command-line utility, or even a custom script using the Lua API.
PMAs
​
The physical memory mapping is described by Physical Memory Attribute records (PMAs) that start at address 
0x00000800
 (the 
board shadow
) .
Each PMA consists of 2 64-bit words.
The first word gives the start of a range and the second word its length.
These words are readable both internally and externally.
Since the ranges must be aligned to 4KiB page boundaries, the lowest 12-bits of each word are available for attributes.
The meaning of each attribute field is as follows:
 Bits 
63–12
11–8
7
6
5
4
3
2
1
0
 Field 
start
DID
IW
IR
X
W
R
E
IO
M
 
 
 
 Bits 
63–12
11–0
 Field 
length
Reserved (=0)
The 
M
, 
IO
, and 
E
 bits are mutually exclusive, and respectively mark the range as memory, I/O mapped, or excluded.
Bits 
R
, 
W
, and
 
X
 mark read, write, and execute permissions, respectively.
The 
IR
 and
 
IW
 bits mark the range as idempotent for reads and writes, respectively.
Finally, the 
DID
 gives the device id, which can have the following values:
 Name 
 Value 
PMA_MEMORY_DID
0
PMA_SHADOW_DID
1
PMA_FLASH_DRIVE_DID
2
PMA_CLINT_DID
3
PMA_HTIF_DID
4
PMA_DHD_DID
5
PMA_ROLLUP_RX_BUFFER_DID
6
PMA_ROLLUP_TX_BUFFER_DID
7
PMA_ROLLUP_INPUT_METADATA_DID
8
PMA_ROLLUP_VOUCHER_HASHES_DID
9
PMA_ROLLUP_NOTICE_HASHES_DID
10
The list of PMA records ends with an invalid PMA entry for which 
length=0
.
Linux setup
​
By default, 
pc
 starts at 
0x1000
, pointing to the start of the ROM region.
Before control reaches the RAM image (and ultimately the Linux kernel), a small program residing in ROM builds a 
devicetree
 describing the hardware.
Cartesi's ROM image 
rom.bin
 containing this program can be generated from the 
rom/
 directory of the 
Cartesi Machine SDK
.
To do so, it goes over the PMA entries identifying the devices and their locations in the physical address space.
It also looks for a null-terminated string, starting at the last 4k of the ROM region, that will be used as the command-line for the Linux kernel.
Once the devicetree is ready, the ROM program sets register
 
x10
 to 0 (the value of
 
mhartid
), 
x11
 to point to the devicetree (which it places at the end of the RAM region), and then jumps to RAM-base at
 
 address 
0x80000000
.
This is where the entry point of the RAM image is expected to reside.
The 
dtc
 command-line utility can be used to inspect the devicetree:
cartesi-machine 
\
    --append-rom-bootargs
=
"single=yes"
 
\
    --rollup 
\
    -- 
"dtc -I dtb -O dts /sys/firmware/fdt"
The result is
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
<stdout>: Warning (interrupt_provider): /cpus/cpu@0/interrupt-controller: Missing #address-cells in interrupt provider
/dts-v1/;
/ {
    #address-cells = <0x02>;
    #size-cells = <0x02>;
    compatible = "ucbbar,riscvemu-bar_dev";
    model = "ucbbar,riscvemu-bare";
    cpus {
        #address-cells = <0x01>;
        #size-cells = <0x00>;
        timebase-frequency = <0xf4240>;
        cpu@0 {
            device_type = "cpu";
            reg = <0x00>;
            status = "okay";
            compatible = "riscv";
            riscv,isa = "rv64aimsu";
            mmu-type = "riscv,sv39";
            clock-frequency = <0x5f5e100>;
            interrupt-controller {
                #interrupt-cells = <0x01>;
                interrupt-controller;
                compatible = "riscv,cpu-intc";
                phandle = <0x01>;
            };
        };
    };
    memory@80000000 {
        device_type = "memory";
        reg = <0x00 0x80000000 0x00 0x3ff0000>;
    };
    flash@8000000000000000 {
        #address-cells = <0x02>;
        #size-cells = <0x02>;
        compatible = "mtd-ram";
        bank-width = <0x04>;
        reg = <0x80000000 0x00 0x00 0x5000000>;
        linux,mtd-name = "flash.0";
    };
    rollup {
        #address-cells = <0x02>;
        #size-cells = <0x02>;
        compatible = "ctsi-rollup";
        rx_buffer@60000000 {
            reg = <0x00 0x60000000 0x00 0x200000>;
        };
        tx_buffer@60200000 {
            reg = <0x00 0x60200000 0x00 0x200000>;
        };
        input_metadata@60400000 {
            reg = <0x00 0x60400000 0x00 0x1000>;
        };
        voucher_hashes@60600000 {
            reg = <0x00 0x60600000 0x00 0x200000>;
        };
        notice_hashes@60800000 {
            reg = <0x00 0x60800000 0x00 0x200000>;
        };
    };
    yield {
        compatible = "ctsi-yield";
        automatic;
        manual;
    };
    soc {
        #address-cells = <0x02>;
        #size-cells = <0x02>;
        compatible = "ucbbar,riscvemu-bar-soc\0simple-bus";
        ranges;
        htif@40008000 {
            compatible = "ucb,htif0";
            reg = <0x00 0x40008000 0x00 0x1000>;
            interrupts-extended = <0x01 0x0d>;
        };
    };
    chosen {
        bootargs = "console=hvc0 rootfstype=ext2 root=/dev/mtdblock0 rw quiet swiotlb=noforce mtdparts=flash.0:-(root) single=yes -- dtc -I dtb -O dts /sys/firmware/fdt";
    };
};
Halted
Cycles: 71150848
The 
memory@80000000
 section describes 64MiB of RAM starting at address 
0x80000000
.
The 
flash@8000000000000000
 describes flash drive 0: a memory region of 60MiB, starting at address 
0x8000000000000000
, under the control of the 
mtd-ram
 driver, with name 
flash.0
.
This will eventually become available as block device 
/dev/mtdblock0
.
The 
rollup
 section specifies the starts and lengths of all rollup memory ranges.
The 
yield
 section specifies that the machine will process automatic and manual yields.
Finally, section 
chosen
 includes the 
bootargs
 string that will be used as the kernel command-line parameters.
Notice the specification of the root file-system pointing to 
/dev/mtdblock0
, i.e., 
flash.0
, and the 
mtdparts
 giving it the label 
root
.
Also notice the command 
dtc -I dtb -O dts /sys/firmware/fdt
 coming directly from the 
cartesi-machine
 command line.
Linux support for RISC-V is upstream in the 
Linux kernel archives
.
The kernel runs in supervisor mode, on top of a Supervisor Binary Interface (SBI) provided by a machine-mode shim: the Berkeley Boot Loader (BBL).
The BBL is linked against the Linux kernel and this resulting RAM image is preloaded into RAM.
Cartesi's RAM image 
linux.bin
 can be generated from the 
kernel/
 directory of the 
Cartesi Machine SDK
.
The SBI provides a simple interface through which the kernel interacts with CLINT and HTIF.
Besides implementing the SBI, the BBL also installs a trap that catches invalid instruction exceptions.
This mechanism can be used, for example, to emulate floating-point instructions, although it is more efficient to setup the target toolchain to replace floating point instructions with calls to a soft-float implementation instead.
After installing the trap, BBL switches to supervisor mode and cedes control to the kernel entry point.
After completing its own initialization, the kernel mounts the root file-system and eventually cedes control to
 
/sbin/init
.
Cartesi's root file-system 
rootfs.ext2
 can be generated from the 
fs/
 directory in the 
Cartesi Machine SDK
.
The Cartesi-provided 
/sbin/init
 script scans all flash devices 
/dev/mtdblock1
–
/dev/mtdblock7
 for valid file-systems.
When a file-system is found, the script obtains the corresponding 
<label>
 (set in the 
mtdparts
 kernel command-line parameter) by inspecting 
/sys/block/mtdblock*/device/name
 and mounts the filesystem at 
/mnt/<label>
.
The kernel passes to 
/sbin/init
 as command-line parameters all arguments after the separator
 
--
 
in the 
bootargs
 string it found in the devicetree.
The Cartesi-provided 
/sbin/init
 script concatenates all arguments into a string and executes the command in this string in a shell.
When the shell returns, 
/sbin/init
 unmount all file-systems and gracefully halts the machine.
The processor
The board
CLINT
HTIF
Rollup
PMAs
Linux setup
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 14---










Run back-end in Host Mode | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
When developing an application, it is often important to easily test and debug it. For that matter, it is possible to run the Cartesi Rollups environment in 
host mode
, so that the DApp's back-end can be executed directly on the host machine, allowing it to be debugged using regular development tools such as an IDE.
note
When running in host mode, localhost port 
5004
 will be used by default to allow the DApp's back-end to communicate with the Cartesi Rollups framework.
Step 1: Run the environment
​
The first step is to run the environment in host mode using the following command:
docker
 compose -f 
..
/docker-compose.yml -f ./docker-compose.override.yml -f 
..
/docker-compose-host.yml up
Step 2: Run the application back-end
​
The next step is to run the application back-end in your machine. For example, if the code is written in Python, you will need to have 
python3
 installed.
In order to start the back-end, run the following commands in a dedicated terminal:
cd
 echo-python/
python3 -m venv .env
.
 .env/bin/activate
pip 
install
 -r requirements.txt
ROLLUP_HTTP_SERVER_URL
=
"http://127.0.0.1:5004"
 python3 echo.py
Step 3: Check output
​
After the back-end successfully starts, it should print an output like the following:
INFO:__main__:HTTP rollup_server url is http://127.0.0.1:5004
INFO:__main__:Sending finish
Step 4: Interact with the application
​
After that, you can interact with the application normally 
as explained in the quick start article
.
Options
​
How to automatically restart the back-end
​
The final command will effectively run the back-end and send corresponding outputs to port 
5004
.
It can optionally be configured in an IDE to allow interactive debugging using features like breakpoints.
You can also use a tool like 
entr
 to restart the back-end automatically when the code changes. For example:
ls
 *.py 
|
 
ROLLUP_HTTP_SERVER_URL
=
"http://127.0.0.1:5004"
 entr -r python3 echo.py
How to stop containers
​
To stop the containers and remove any associated volumes, run the following command:
docker
 compose -f 
..
/docker-compose.yml -f ./docker-compose.override.yml -f 
..
/docker-compose-host.yml down -v
Step 1: Run the environment
Step 2: Run the application back-end
Step 3: Check output
Step 4: Interact with the application
Options
How to automatically restart the back-end
How to stop containers
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 15---










5 docs tagged with "rollups" | Blockchain OS Documentation - Cartesi
























Skip to main content
Components
As explained in the previous section, the Cartesi Rollups framework achieves scalability by moving the bulk of the computation outside the blockchain, using the ledger as a data source but not as an execution environment. As such, the solution contains both on-chain (layer-1) and off-chain (layer-2) components.
DApp architecture
Borrowing from familiar mainstream terminology, from a developer’s point of view a Cartesi DApp is developed by implementing two main components: a front-end and a back-end.
DApp life cycle
Now that we have described the architecture of a Cartesi DApp and how the front-end and back-end communicate with the Cartesi Rollups framework, let’s step back a bit to discuss how a DApp can be implemented in practice.
Overview
The combination of an Optimistic Rollups framework and the Cartesi Machine Emulator enables the development of smart contracts and DApps using any package or library that is available for Linux. This allows developers to break free from the scalability limitations of the Ethereum Virtual Machine (EVM), and brings the rise of a new blockchain era to handle real-life and complex use-cases.
Rollups HTTP APIs
In a Cartesi DApp, the front-end and back-end parts of the application communicate with each other through the Rollups framework via a set of HTTP APIs.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 16---










Components | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
As explained in the 
previous section
, the Cartesi Rollups framework achieves scalability by moving the bulk of the computation outside the blockchain, using the ledger as a data source but not as an execution environment. As such, the solution contains both on-chain (layer-1) and off-chain (layer-2) components.
note
In this section, we describe the internal components of the Cartesi Rollups framework in more detail, to clarify how the system works inside. DApp developers may chose to skip directly to the 
DApp architecture
 section to understand how to build applications.
Main concepts
​
Cartesi Nodes
​
As explained before, 
Cartesi Machines
 provide DApp developers with an environment in which large scale verifiable computations can be executed. These machines are integrated with the on-chain smart contracts by a 
middleware
 that manages and controls the communication between them. As such, this middleware is responsible for first reading data from the layer-1 smart contracts, then sending them to the machine to be processed, and finally publishing their results back to the blockchain.
The 
Cartesi Node
 is the layer-2 component that consists of the combination of the Cartesi Machine and this middleware, and can be used by anyone interested in the rollups state of affairs. Put simply, Cartesi Nodes play a role that is similar to what Geth does on the Ethereum ecosystem: execution and retrieval of information.
In practice, there are two distinct kinds of agents that run Cartesi Nodes: 
users
 and 
validators
. Each of them interacts with the on-chain rollups in different ways, and thus run different types of Cartesi Nodes:
User or Reader Nodes
, which are only involved in advancing the state of the off-chain machine, and making that state publicly available. They consume information from the blockchain but do not bother to enforce state updates, trusting that validators will ensure the validity of all on-chain state updates.
Validator Nodes
, which have more responsibility: they not only watch the blockchain but also fight possible dishonest validators to ensure the prevalence of honest claims for state updates. On the other hand, if Reader Nodes are available, validators do not need to expose endpoints for retrieving application state. Therefore, they can run in more secure environments and remain inaccessible to external clients and users.
Epochs
​
In order to avoid over interacting with the blockchain, validators don't checkpoint every new state update on the off-chain machine. They do it at the end of an 
epoch
, which are batched inputs that follow the same cycle.
We can imagine epochs in three different states:
Accumulating
, when the epoch is open and waiting for inputs.
Sealed
, when the inputs for that epoch are well defined and the validators are preparing to send their claims. Sealed epochs can also be under dispute.
Finalized
, when consensus was reached and the outputs can be safely executed.
The on-chain state, depending on what phase it is, can contain one or two epochs, as illustrated by the diagram below.
Input Accumulation
: there is a single accumulating epoch, active and waiting for the inputs it is going to batch.
Awaiting Consensus
: there are two epochs. A sealed one, for which validators are preparing to or sending their claims, and an accumulating one, which is active and receiving inputs.
Awaiting Dispute
: there are also two epochs. A sealed one and an accumulating one. The sealed epoch is under dispute. At least two conflicting claims were received and the validators are enrolling in a verification game to decide which claim stands. Since the sealed epoch's inputs are well defined, honest validators will always reach the same claim. A dispute necessarily means that a claim is provably false.
To better understand the whole process on a timeline, let's describe how the system schedules different rollups phases.
On a given epoch N, the involved validator nodes batch all the input messages that were enqueued on-chain from the beginning of the previous 
epoch’s processing
 slot until the beginning of the current epoch’s 
processing slot
.
The nodes then process every message of the batch through the Cartesi Machine, producing an output hash that summarizes the state transition of the entire epoch. Then, one of the validators, henceforth called 
claimer
, places on-chain the hash representing the layer-2 contract state at the end of epoch N, 
S(N)
.
After a challenge period is over, if there was no dispute, 
S(N)
 is assumed final by the system. Otherwise, disputes will follow until the correct state claim represented by its output hash is enforced. The 
settlement period
 displayed on the diagram above accounts for a 
challenge period
, with or without disputes.
To guarantee a minimum duration for each epoch, the rollups protocol also requires an 
accumulation slot
. This is a minimal latency imposed on on-chain finalization to prevent frequent claims being sent to layer-1, for the sake of Ethereum fee cost-effectiveness. The rollup developer can configure a specific accumulation slot period for their application to accommodate eventual specific requirements for balancing latency to finality and security.
Vouchers
​
A 
voucher
 is a combination of a target address and a payload in bytes. It is used by the off-chain machine to respond and interact with layer-1 smart contracts. Upon execution, a voucher sends a message to the target address with the payload as a parameter. Vouchers can be used for anything, ranging from providing liquidity in a DeFi protocol to withdrawing funds from the 
Portal
. Vouchers can only be executed when the epoch in which they are contained is 
finalized
, at which point a 
validity proof
 will be available to ensure layer-1 smart contracts can trust its content.
Notices
​
A 
notice
 is an arbitrary payload in bytes that is submitted by the off-chain machine for informational purposes. Similarly to vouchers, when the epoch containing a notice is finalized a proof will be produced so that the validity of the notice's content can be verified on-chain by any interested party.
Reports
​
A 
report
 is an application log or a piece of diagnostic information. Like a notice, it is represented by an arbitrary payload in bytes. However, a report is never associated with a proof and is thus not suitable for trustless interactions such as on-chain processing or convincing independent third parties of DApp outcomes. Reports are commonly used to indicate processing errors or to retrieve application information for display.
On-chain components
​
These consist of the Cartesi Rollups smart contracts that were designed to mediate the relationship of the off-chain components with other smart contracts and externally owned accounts. They include several modules, each with clear responsibilities and well-defined interfaces.
Cartesi Rollups Manager
​
The 
Cartesi Rollups Manager
 is responsible for synchronicity between the modules. It defines the duration of the different phases and notifies the other modules of any phase change. Among others, the responsibilities of this module are:
Define to which epoch an input is destined, depending on the current state and deadlines.
Receive and forward claims to the Validator Manager.
Forward disputes to the Dispute Resolution module.
Forward the result of disputes to the Validator Manager.
Forward the summary of finalized outputs (vouchers and notices) to the Output module.
Notify other modules of phase changes.
Input contract
​
As discussed above, the on-chain contracts often have two concurrent epochs: a sealed but unfinalized epoch, and an accumulating one. The 
Input contract
 keeps one inbox for each of those epochs, switching between them depending on the Cartesi Rollups Manager's notifications.
For anyone to be able to synchronize the machine from its beginning without needing to trust a data provider, the full content of inputs is always present in calldata on the blockchain. In on-chain storage, which needs to be used in a more parsimonious way, we keep a single hash for each input of an active epoch.
This input hash summarizes both the input itself and its metadata, which corresponds to the sender's address and the time of reception. Notice that this input implementation is permissionless: the permission layer is delegated to the off-chain machine which will, for example, judge if a sender is allowed to do what their input wants to do.
Output contract
​
Each input can generate a number of notices and vouchers that will have an accompanying 
validity proof
 available once the epoch containing them is finalized. These proofs can be used with the 
Output contract
 to execute vouchers or verify the validity of a notice's content.
For vouchers, while the Output contract is indifferent to their content, it does enforce some sanity checks before allowing their execution, since vouchers are unique and can only be successfully executed once. Vouchers are executed asynchronously and don't require an access check, and the order of execution is not enforced. As long as vouchers are contained in a finalized epoch and were not executed before, the contract will allow their execution by anyone.
Portal
​
The Portal, as the name suggests, is used to teleport assets from the Ethereum blockchain to DApps running on Cartesi Rollups. Once deposited, those layer-1 assets gain a representation in layer-2 and are owned, there, by whomever the depositor assigned them to. After being teleported, layer-2 assets can be moved around in a significantly cheaper way, using simple inputs that are understood by the Linux logic.
When an asset is deposited, the Portal contract sends an input to the DApp’s inbox, describing the type of asset, amount, receivers, and some data the depositor might want the DApp to read. This allows deposits and instructions to be sent as a single layer-1 interaction. One could think of the Portal as a bank account, owned by the off-chain machine.
Anyone can deposit assets there but only the DApp — through its Output contract — can decide on withdrawals. The withdrawal process is quite simple from a user perspective. They send an input requesting a withdrawal, which gets processed and interpreted off-chain. If everything is correct, the machine creates a voucher destined to the Portal contract, ordering and finalizing that withdrawal request. Currently, we support the following types of assets:
Ether (ETH)
ERC-20
ERC-721 (NFTs)
Validator Manager
​
The 
Validator Manager
 module was created to help DApps manage their claims, claim permissions, and punishments for bad behavior. Initially, our suggested implementation for this module includes the following characteristics: the set of payable validators is defined in construction time, validators send a claim for every epoch and those that lose a dispute are kicked off the validators set.
The 
Cartesi Rollups Manager
 receives claims and redirects them to the Validator Manager. When receiving a claim, the Validator Manager checks which other claims have arrived at that epoch and returns the information that Cartesi Rollups Manager needs to continue. The module can respond to received claims in one of the following ways:
If the sender is not a validator or the claim is invalid, the transaction reverts.
If the claim is valid, doesn’t disagree with any of the other claims in the epoch, and does not generate consensus, it returns a "No Conflict" response.
If the claim is valid but disagrees with another claim for that epoch, it warns the Cartesi Rollups Manager that a conflict is happening and what are the conflicting claims and claimants involved. When that dispute is resolved the Validator Manager module gets notified so it can deal however it likes with the validators involved. In our initially suggested implementation, the loser of a dispute is removed from the validator set.
If the claim is valid, agrees with all other claims in that epoch, and is the last claim to be received, it lets Cartesi Rollups know that consensus was reached. This allows the rollups DApp to finalize the epoch and allow for the execution of its vouchers. Regardless of what the name might suggest, validators do not interact with this module at all.
Fee Manager and Bank
​
The 
Fee Manager facet
 and 
Bank contract
 aim to create an economical incentive for validators to run a given DApp. When you develop an application, you will need to define two parameters:
A fee to be paid to the validators each time they submit a claim. This fee will be debited from the funds stored in the DApp's Bank contract.
An owner for the Fee Manager facet, who has the option to change the fee value, if needed.
Entities running validator nodes should configure them to either be 
altruistic
 or require a minimum retainer (i.e., a minimum fee to process inputs for the DApp). If they are altruistic, they will work regardless of any financial compensation. On the other hand, non-altruistic validators must ensure that the following two conditions are met before processing inputs and submitting claims:
The fee paid by the DApp must be bigger than their required retainer
The DApp's Bank must have enough funds to pay the validator
The fee value is given in CTSI and is reserved for a validator every time a claim is made. The validator is free to withdraw received CTSI fees at any time of its convenience. While the Fee Manager controls the fee value and the amount of claims made by each validator, the Bank stores - on a separate contract - the CTSI tokens that will be distributed to them.
The code does not enforce a way for the Bank to be funded. Therefore, DApps and communities are free to choose their preferred procedures, such as direct transfer, charging per input, creating a tax system on top of the Portal, or other methods. For convenience, a 
FundBank
 hardhat task is provided which transfers money from the signer to a DApp's Bank.
Dispute Resolution
​
Disputes occur when two validators claim different state updates to the same epoch. Because of the deterministic nature of our virtual machine and the fact that the inputs that constitute an epoch are agreed upon beforehand, conflicting claims imply dishonest behavior. When a conflict occurs, the module that mediates the interactions between both validators is the Dispute Resolution contract.
The code for rollups dispute resolution is not being published yet - but a big part of it is available on the Cartesi Rollups SDK, using the 
Arbitration dlib
.
Off-chain components
​
These consist of the internal modules of the 
Cartesi Node
. As explained before, Cartesi Nodes form the network that sustains the Cartesi Rollups solution, being responsible for executing the computations that arrive and presenting their results to the interested parties.
State Server
​
This service is responsible for ensuring that the remaining modules have access to a consistent view of the state of the blockchain. The service is an instance of  Cartesi's 
State Fold tool
 and monitors all relevant activity from the Cartesi Rollups smart contracts, consolidating the information that gets emitted by the blockchain.
Rollups Dispatcher
​
Responsible for interpreting the current state of the Cartesi Rollups smart contracts, this module informs the 
Server Manager
 about any incoming inputs and, in the case of Validator Nodes, also submits transactions to layer-1 corresponding to state update claims. It will also handle any disputes should they arise.
Server Manager
​
This module manages the Cartesi Machine, sending inputs to it and reading the produced outputs. It is responsible for starting and stopping the machine as appropriate, as well as providing an API for the other modules to query the machine's state.
The 
Host Server Manager
 is an alternative implementation of the Server Manager for development purposes. It implements the same API and mimics the behavior of an actual Server Manager, but does not in fact instantiate a Cartesi Machine. Instead, it makes HTTP requests directly to a DApp running in the host computer. The Host Server Manager is intended to be used in the 
implementation stage of the DApp life cycle
.
Rollups Indexer
​
This service is responsible for consolidating the state of the Cartesi Node. It queries blockchain information from the 
State Server
 as well as data produced by the DApp back-end through the 
Server Manager
, consolidating everything in a local database.
Query Server
​
Module that provides an externally accessible 
GraphQL API
 for querying the consolidated state of the Cartesi Node, as maintained by the 
Rollups Indexer
. This allows users and client applications to retrieve vouchers, notices and reports produced by the DApp back-end.
Main concepts
Cartesi Nodes
Epochs
Vouchers
Notices
Reports
On-chain components
Cartesi Rollups Manager
Input contract
Output contract
Portal
Validator Manager
Fee Manager and Bank
Dispute Resolution
Off-chain components
State Server
Rollups Dispatcher
Server Manager
Rollups Indexer
Query Server
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 17---










6 docs tagged with "blockchain os" | Blockchain OS Documentation - Cartesi
























Skip to main content
Choose your Onboarding Path
Our onboarding paths answer the following questions:
Introduction
This section describes Cartesi Machines from the perspective of the blockchain.
Introduction
The Cartesi Machine is Cartesi's solution for verifiable computation.
Overview
Cartesi's reference off-chain implementation of Cartesi Machines is based on software emulation.
Scalability
The scalability issue is one of the three parts of the Blockchain Trilemma, along with security and decentralization. Solving the scalability issue refers to any type of improvement within a blockchain system in terms of computational power, throughput, latency, bootstrap time, or cost per transaction. For example, high gas fees make it expensive for users to pay for their transactions within the Ethereum blockchain.
The Blockchain OS
Cartesi, The Blockchain OS, is a layer-2 platform for the development and deployment of scalable decentralized applications. The Blockchain OS offers a Linux operating system coupled with a blockchain infrastructure, which allows DApps to be developed in familiar programming languages like Python without the need to write Solidity code.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 18---










22 docs tagged with "maintain" | Blockchain OS Documentation - Cartesi
























Skip to main content
Architecture
What follows is a summary of the architecture and the components that are involved in running a Cartesi Compute Application, meaning some DApp that makes use of our SDK. It is convenient to start with the description of the typical ingredients involved in a decentralized application. Namely, the blockchain node and the client software.
Drives
This section describes in detail the Drive[] _inputDrives parameter of the instantiate call.
Execution timeline
At this point, an overview has been given of what constitutes a Cartesi computation, who are the parties involved, and what the software components of Cartesi Compute are. It is important to understand better what events happen during the execution of a Cartesi Machine.
How it works
Cartesi Compute SDK allows Cartesi DApps to specify and request verifiable computations to Cartesi Machines. Additionally, the SDK provides tools to facilitate and reduce the cost of inputting data into Cartesi Machines.
Instantiate
This section describes the main ingredient of the on-chain Cartesi Compute infrastructure.
Introduction
This section describes Cartesi Machines from the perspective of the blockchain.
Introduction
The Cartesi Machine is Cartesi's solution for verifiable computation.
Logger drives
A relevant limitation of the Cartesi Machines as they have been described until now is the size of their input drives.
Machines off-chain
Although an extensive documentation of Cartesi Machines can be found here, one may choose to skip this reading and jump right away to their usage inside the blockchain through Cartesi Compute. For that, it is enough to regard a Cartesi Machine as a black box that executes computations.
Machines on-chain
Having discussed the concept of Cartesi Machines off-chain, capable of booting a Linux operating system and loading heavy-weight libraries, one naturally wonders how this will ever be stored or executed on the limited environment of a blockchain. The simple answer is that it won’t be.
On-chain API
Having informally discussed how Cartesi Compute represents Cartesi Machines on-chain, one can now describe in more details the API for requesting and retrieving computations in Cartesi Compute.
Overview
The Cartesi Compute documentation is a work in progress so please navigate to Quick Start for building DApps
Overview
Cartesi's reference off-chain implementation of Cartesi Machines is based on software emulation.
Platform services
Platform Services is a new product developed and maintained by the Cartesi team that hosts Cartesi Node infrastructure for DApps. The service is elastic, making resources available to DApps upon demand. Developers deploy their Cartesi DApps on Platform Services and it automatically allocates resources according to user activity.
Provider drives
After going through the last section, the reader is already able to specify drives if the data was available to the caller at the time of instantiation.
Putting Things Together
To better understand how Cartesi Compute can be used, imagine the following simple Cartesi DApp with one claimer and one challenger. The DApp can be a skill-based game where players place their bets and challenge each other for the highest score over the blockchain. The winner takes the pot.
Scalability
The scalability issue is one of the three parts of the Blockchain Trilemma, along with security and decentralization. Solving the scalability issue refers to any type of improvement within a blockchain system in terms of computational power, throughput, latency, bootstrap time, or cost per transaction. For example, high gas fees make it expensive for users to pay for their transactions within the Ethereum blockchain.
Supported networks
Broadly speaking, the Cartesi layer-2 platform architecture should be perceived as blockchain-agnostic, given that in principle any network could use Cartesi Machines to move complex computations off-chain without compromising on decentralization.
The Blockchain OS
Cartesi, The Blockchain OS, is a layer-2 platform for the development and deployment of scalable decentralized applications. The Blockchain OS offers a Linux operating system coupled with a blockchain infrastructure, which allows DApps to be developed in familiar programming languages like Python without the need to write Solidity code.
The off-chain API
After the call for instantiate, the blockchain may already have all information that is necessary to execute the machine. But in many cases it also needs to get input from other users. In a game for example, the user may need to insert their decisions on input drives for later processing.
Topologies
When users interact with their blockchain DApps, they are free to manage and run their own blockchain nodes if so they wish. In a common scenario of the usage of the Ethereum network, DApps are accessed via browser and blockchain transaction requests are carried out by Metamask. The user signs the transaction which is typically sent to a remotely hosted node, such as Infura.
Wallets
Cartesi is a second layer solution.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 19---










Quick Start | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
This article explains how to build and interact with a minimalistic 
Cartesi Rollups
 application.
By the end of this tutorial, you will learn how to run a simple existing DApp written in 
Python
, called 
Echo-Python
.
note
You can inspect the 
full code of the Echo Python DApp
 in Cartesi's public Github repository.
Overview
​
The Echo-Python DApp simply copies (or "echoes") each input received as a corresponding output 
notice
. The DApp's back-end is written in 
Python
, and its front-end is a 
simple console application
 written in 
Typescript
 that can be executed from a terminal.
The 
Quick Start
 guide consists of 5 main steps:
Installing
Building
Running
Interacting
Deploying
Installing
​
note
You can use online development environments such as 
Gitpod
 and 
CodeSandbox
 to open the 
rollups-exmaples
 directly in your browser with all 
required dependencies
 already installed. These services allow you to start experimenting immediately, but keep in mind that they are provided by third-parties and are subject to unavailability and policy changes. They may also require access to your GitHub account in order to work properly.
There are two different options to setup the prerequisites, you can choose one of the following:
Using Gitpod
 as a fast option
Using manual setup
 to install all the necessary requirements locally
Using Gitpod
​
This is an easy and fast setup, you need to follow the steps:
Navigate to Gitpod rollups-examples
 to automate your development setup
When you click on the link above, it will forward you to login options.
Login with your preferable option via GitLab, GitHub, or Bitbucket.
Provide authorization to GitLab, GitHub, or Bitbucket.
Congratulations, you have successfully setup your development environment
Start Building our Echo DApp
Using manual setup
​
Follow the 
manual setup
 to  make sure you have installed all the necessary requirements locally.
Building
​
To build the 
echo-python
 example:
tip
If you are running your environment using the 
Gitpod option explained above
, then please start from 
step number 2
 as you will not need to clone the Github repository.
Clone the 
cartesi/rollups-examples
 Github repository by running the following command:
git
 clone https://github.com/cartesi/rollups-examples.git
Navigate to the DApp example directory by running the following command:
cd
 rollups-examples/echo-python
Build the Echo DApp by running the following command:
docker
 buildx bake --load
Running
​
To run the application, you can start an environment that includes a local blockchain with the Cartesi smart contracts deployed, as well as a Cartesi layer-2 node executing the DApp's back-end logic.
This can be done by running the following command:
docker
 compose -f 
..
/docker-compose.yml -f ./docker-compose.override.yml up
After you see the expected logs below, you can go to the 
Interacting Step
.
Expected logs
​
Allow some time for the infrastructure to be ready.
How much will depend on your system, but after some time showing the error 
"concurrent call in session"
, eventually the container logs will repeatedly show the following:
server_manager_1      
|
 Received GetVersion
server_manager_1      
|
 Received GetStatus
server_manager_1      
|
   default_rollups_id
server_manager_1      
|
 Received GetSessionStatus 
for
 session default_rollups_id
server_manager_1      
|
   
0
server_manager_1      
|
 Received GetEpochStatus 
for
 session default_rollups_id epoch 
0
Advancing time
​
When executing an example, it is possible to advance time to simulate the passing of epochs. To do that, run:
curl
 --data 
'{"id":1337,"jsonrpc":"2.0","method":"evm_increaseTime","params":[864010]}'
 http://localhost:8545
How to shutdown the environment
​
You can shutdown the environment by running the following command:
docker-compose
 -f 
..
/docker-compose.yml -f ./docker-compose.override.yml down -v
Interacting with the DApp
​
There are two ways to interact with the DApp:
Locally
Remotely
Interacting locally with the DApp
​
With the infrastructure in place, you can use our 
frontend-console application
 to interact with the Echo DApp by following the steps:
Open a separate terminal window
From the rollups-examples base directory, navigate to the 
frontend-console
 one:
cd
 frontend-console
Build the frontend console application:
yarn
yarn
 build
Send an input to the current locally deployed DApp:
yarn
 start input send --payload 
"Hello Blockchain OS!"
Verify the outputs (notices) generated by your input, to display your DApp notices run the following command:
yarn
 start notice list
After completing all the steps above, you should get a response similar to the following:
[ { epoch: '0', input: '1', notice: '0', payload: 'Hello Blockchain OS!' } ]
tip
You can run the Cartesi Rollups environment locally in 
host mode
. Please follow the guide on 
how to run DApp back-ends in Host Mode
, but before that make sure to 
shutdown the current running environment
.
note
For more information about the 
frontend-console
 application and its options, please check the 
frontend-console documentation
.
Interacting with remotely deployed DApps
​
The 
Echo DApp
 example is already deployed on a public blockchain test network called 
Goerli
, which is an Ethereum testnet.
You can use the same 
frontend-console application
 to interact with it, as described below.
note
Please refer to the 
frontend-console documentation
 for details on how to use it to 
send inputs
, 
list notices
 and 
deposit ERC-20 tokens
.
The following steps describe how to send an input to the Echo DApp instance that is already deployed on Goerli:
Open a separate terminal window
Navigate to the 
frontend-console
 directory:
cd
 frontend-console
Build the project:
yarn
yarn
 build
You can 
follow this tutorial to create an Ethereum account using Metamask
. Make sure to save the Secret Backup Phrase (MNEMONIC user sequence of twelve words)
Get testnet funds/tokens on Goerli to be able to submit transactions on that network. There are several faucets available, you may try 
https://goerlifaucet.com/
 or 
https://goerli-faucet.slock.it/
Create an 
Alchemy account
 to obtain an API key for reliable access to the Goerli network. Alternatively, you can use other options such as 
Infura
 or 
Moralis
Configure your account on Goerli by running the commands below, which specify the network and MNEMONIC (Secret Backup Phrase) to use:
export
 
NETWORK
=
goerli
export
 
MNEMONIC
=
<
paste here your user sequence of twelve words
>
Configure your 
Alchemy
 RPC gateway URL for Goerli by running the following command:
export
 
RPC_URL
=
https://eth-goerli.alchemyapi.io/v2/
<
Replace_This_With_Your_Alchemy_API_key
>
Send an input by running the command:
yarn
 start input send --payload 
"my new message"
 --dapp echo-python
Query the layer-2 Cartesi Node for notices produced by the DApp:
yarn
 start notice list --url https://echo-python.goerli.rollups.staging.cartesi.io/graphql
tip
As shown in the last step (number 10), to query the layer-2 Cartesi Node for DApp outputs, you will need to specify the URL of its GraphQL endpoint. You can find other existing examples endpoints in the 
DApp table below
.
Explore our DApps
​
You can find several Cartesi DApp 
examples on GitHub
, such as the following:
DApp Name
DApp Deployment Status on Goerli Testnet
GraphQL endpoint URL
Echo Python
Yes
https://echo-python.goerli.rollups.staging.cartesi.io/graphql
Echo C++
Yes
https://echo-cpp.goerli.rollups.staging.cartesi.io/graphql
Echo Rust
No
-
Echo Lua
Yes
https://echo-lua.goerli.rollups.staging.cartesi.io/graphql
Echo JS DApp
Yes
https://echo-js.goerli.rollups.staging.cartesi.io/graphql
Echo Low-Level
Yes
https://echo-low-level.goerli.rollups.staging.cartesi.io/graphql
Converter
No
-
Calculator
No
_
SQLite
Yes
https://sqlite.goerli.rollups.staging.cartesi.io/graphql
k-NN
Yes
https://knn.goerli.rollups.staging.cartesi.io/graphql
m2cgen
No
-
ERC-20
No
-
Auction
No
-
Overview
Installing
Using Gitpod
Using manual setup
Building
Running
Expected logs
Advancing time
How to shutdown the environment
Interacting with the DApp
Interacting locally with the DApp
Interacting with remotely deployed DApps
Explore our DApps
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 20---










Deploying DApps | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
tip
Please check the 
full documentation for deploying Rollups DApps to Cartesi's cloud-based execution infrastructure
.
Cartesi Rollups DApps are intended to be deployed to public blockchains, so that they can be accessed by users. This can be done by taking advantage of a cloud-based infrastructure provided by Cartesi.
As happens with any blockchain application, the act of "deploying a DApp" involves publishing its smart contract so that it is publicly available and usable by clients or 
front-end applications
. In the context of a Cartesi DApp, the smart contract is represented by an arbitrary 
back-end program
 that runs on Linux inside a 
Cartesi Node
. This means that deploying Cartesi DApps basically corresponds to instantiating Cartesi Nodes that run the intended back-end logic of the application.
In order to facilitate the instantiation of such nodes, Cartesi provides an infrastructure for easily getting them running in the cloud. Developers are thus invited to take advantage of this convenience service in order to jump-start bringing their applications to public blockchains.
Supported networks
​
Deploying a new Cartesi DApp to a blockchain requires creating a smart contract on that network that makes use of the Cartesi Rollups smart contracts. For convenience, Cartesi has already deployed the Rollups smart contracts to a number of networks, in order to make it easier for developers to create DApps on them.
The table below shows the list of all 
networks that are currently supported
 in the latest Cartesi Rollups release:
Network Name
Chain ID
Arbitrum Goerli
421613
Goerli
5
Gnosis Chiado
10200
Optimism Goerli
420
Polygon Mumbai
80001
Supported networks
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 21---










2 docs tagged with "architecture" | Blockchain OS Documentation - Cartesi
























Skip to main content
Architecture
What follows is a summary of the architecture and the components that are involved in running a Cartesi Compute Application, meaning some DApp that makes use of our SDK. It is convenient to start with the description of the typical ingredients involved in a decentralized application. Namely, the blockchain node and the client software.
DApp architecture
Borrowing from familiar mainstream terminology, from a developer’s point of view a Cartesi DApp is developed by implementing two main components: a front-end and a back-end.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 22---










New to Cartesi | Blockchain OS Documentation - Cartesi
























Skip to main content
The Blockchain OS
Cartesi, The Blockchain OS, is a layer-2 platform for the development and deployment of scalable decentralized applications. The Blockchain OS offers a Linux operating system coupled with a blockchain infrastructure, which allows DApps to be developed in familiar programming languages like Python without the need to write Solidity code.
Choose your Onboarding Path
Our onboarding paths answer the following questions:
Scalability
The scalability issue is one of the three parts of the Blockchain Trilemma, along with security and decentralization. Solving the scalability issue refers to any type of improvement within a blockchain system in terms of computational power, throughput, latency, bootstrap time, or cost per transaction. For example, high gas fees make it expensive for users to pay for their transactions within the Ethereum blockchain.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 23---










The Blockchain OS | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Cartesi
, The Blockchain OS, is a layer-2 platform for the development and deployment of scalable decentralized applications. The 
Blockchain OS
 offers a Linux operating system coupled with a blockchain infrastructure, which allows DApps to be developed in familiar programming languages like Python without the need to write Solidity code.
Limitations, develop with The Blockchain OS!
​
Other blockchain platforms do not allow you to develop a DApp that uses a file-system, an SQL database or a machine learning model. Generally there are also harsh limitations related to gas limits and high fees when performing computations such as looping over arrays and manipulating strings, which are commonplace in regular mainstream applications.
Today there is a large number of developers and companies who want to enter the blockchain world but face a steep learning curve and a confusing landscape. Cartesi solves this with The Blockchain OS, so that you can develop a DApp using any traditional software stack.
Here comes the mission of Cartesi:
To offer a full operating system for blockchain applications.
To solve the 
scalability problem
 using Optimistic Rollups along with the Cartesi Machine to support complex computations.
To develop DApps of arbitrary complexity using mainstream development tools and software stacks, and have all of it sit on top of established blockchain networks such as Ethereum, Polygon, Avalanche and BNB Smart Chain.
Cartesi, The Blockchain OS provides lower gas and crypto costs. Additionally, if you are a web developer and you want to build a simple application as your first step in blockchain development, with Cartesi you will not be forced to use a specific language, such as Solidity for Ethereum, nor be forced to reinvent the wheel because a given functionality or math library is not available.
How are Cartesi Rollups different?
​
Most current general-purpose rollups layer 2 solutions, such as 
those based on Optimistic Rollups
, strive to be EVM-compatible because they are focusing on providing lower transaction costs and higher throughputs for the smart contracts that already run on Ethereum. However, Cartesi focuses on providing a true operating system for blockchain developers, allowing them for the first time to leverage decades of software development from the mainstream industry. With that goal in mind, 
Cartesi Rollups
 not only solves the scalability problem by using an Optimistic Rollups framework, but also takes advantage of the 
Cartesi Machine Emulator
 to boost productivity and application complexity by allowing developers to code their smart contracts using any software stack that is already available for Linux.
You can think of Cartesi Rollups as a special operating system that makes your life easier, allowing you to create computationally heavy DApps while providing you with the freedom to choose the programming languages, libraries and tools of your preference. At Cartesi, we believe that this freedom will help start a new era for blockchain application development.
See Also
​
Why Cartesi Rollups is Unique
Rollups On-Chain
Cartesi Node
Testnet
Transaction Manager
State Fold
Limitations, develop with The Blockchain OS!
How are Cartesi Rollups different?
See Also
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 24---










Quick Start | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
This article explains how to build and interact with a minimalistic 
Cartesi Rollups
 application.
By the end of this tutorial, you will learn how to run a simple existing DApp written in 
Python
, called 
Echo-Python
.
note
You can inspect the 
full code of the Echo Python DApp
 in Cartesi's public Github repository.
Overview
​
The Echo-Python DApp simply copies (or "echoes") each input received as a corresponding output 
notice
. The DApp's back-end is written in 
Python
, and its front-end is a 
simple console application
 written in 
Typescript
 that can be executed from a terminal.
The 
Quick Start
 guide consists of 5 main steps:
Installing
Building
Running
Interacting
Deploying
Installing
​
note
You can use online development environments such as 
Gitpod
 and 
CodeSandbox
 to open the 
rollups-exmaples
 directly in your browser with all 
required dependencies
 already installed. These services allow you to start experimenting immediately, but keep in mind that they are provided by third-parties and are subject to unavailability and policy changes. They may also require access to your GitHub account in order to work properly.
There are two different options to setup the prerequisites, you can choose one of the following:
Using Gitpod
 as a fast option
Using manual setup
 to install all the necessary requirements locally
Using Gitpod
​
This is an easy and fast setup, you need to follow the steps:
Navigate to Gitpod rollups-examples
 to automate your development setup
When you click on the link above, it will forward you to login options.
Login with your preferable option via GitLab, GitHub, or Bitbucket.
Provide authorization to GitLab, GitHub, or Bitbucket.
Congratulations, you have successfully setup your development environment
Start Building our Echo DApp
Using manual setup
​
Follow the 
manual setup
 to  make sure you have installed all the necessary requirements locally.
Building
​
To build the 
echo-python
 example:
tip
If you are running your environment using the 
Gitpod option explained above
, then please start from 
step number 2
 as you will not need to clone the Github repository.
Clone the 
cartesi/rollups-examples
 Github repository by running the following command:
git
 clone https://github.com/cartesi/rollups-examples.git
Navigate to the DApp example directory by running the following command:
cd
 rollups-examples/echo-python
Build the Echo DApp by running the following command:
docker
 buildx bake --load
Running
​
To run the application, you can start an environment that includes a local blockchain with the Cartesi smart contracts deployed, as well as a Cartesi layer-2 node executing the DApp's back-end logic.
This can be done by running the following command:
docker
 compose -f 
..
/docker-compose.yml -f ./docker-compose.override.yml up
After you see the expected logs below, you can go to the 
Interacting Step
.
Expected logs
​
Allow some time for the infrastructure to be ready.
How much will depend on your system, but after some time showing the error 
"concurrent call in session"
, eventually the container logs will repeatedly show the following:
server_manager_1      
|
 Received GetVersion
server_manager_1      
|
 Received GetStatus
server_manager_1      
|
   default_rollups_id
server_manager_1      
|
 Received GetSessionStatus 
for
 session default_rollups_id
server_manager_1      
|
   
0
server_manager_1      
|
 Received GetEpochStatus 
for
 session default_rollups_id epoch 
0
Advancing time
​
When executing an example, it is possible to advance time to simulate the passing of epochs. To do that, run:
curl
 --data 
'{"id":1337,"jsonrpc":"2.0","method":"evm_increaseTime","params":[864010]}'
 http://localhost:8545
How to shutdown the environment
​
You can shutdown the environment by running the following command:
docker-compose
 -f 
..
/docker-compose.yml -f ./docker-compose.override.yml down -v
Interacting with the DApp
​
There are two ways to interact with the DApp:
Locally
Remotely
Interacting locally with the DApp
​
With the infrastructure in place, you can use our 
frontend-console application
 to interact with the Echo DApp by following the steps:
Open a separate terminal window
From the rollups-examples base directory, navigate to the 
frontend-console
 one:
cd
 frontend-console
Build the frontend console application:
yarn
yarn
 build
Send an input to the current locally deployed DApp:
yarn
 start input send --payload 
"Hello Blockchain OS!"
Verify the outputs (notices) generated by your input, to display your DApp notices run the following command:
yarn
 start notice list
After completing all the steps above, you should get a response similar to the following:
[ { epoch: '0', input: '1', notice: '0', payload: 'Hello Blockchain OS!' } ]
tip
You can run the Cartesi Rollups environment locally in 
host mode
. Please follow the guide on 
how to run DApp back-ends in Host Mode
, but before that make sure to 
shutdown the current running environment
.
note
For more information about the 
frontend-console
 application and its options, please check the 
frontend-console documentation
.
Interacting with remotely deployed DApps
​
The 
Echo DApp
 example is already deployed on a public blockchain test network called 
Goerli
, which is an Ethereum testnet.
You can use the same 
frontend-console application
 to interact with it, as described below.
note
Please refer to the 
frontend-console documentation
 for details on how to use it to 
send inputs
, 
list notices
 and 
deposit ERC-20 tokens
.
The following steps describe how to send an input to the Echo DApp instance that is already deployed on Goerli:
Open a separate terminal window
Navigate to the 
frontend-console
 directory:
cd
 frontend-console
Build the project:
yarn
yarn
 build
You can 
follow this tutorial to create an Ethereum account using Metamask
. Make sure to save the Secret Backup Phrase (MNEMONIC user sequence of twelve words)
Get testnet funds/tokens on Goerli to be able to submit transactions on that network. There are several faucets available, you may try 
https://goerlifaucet.com/
 or 
https://goerli-faucet.slock.it/
Create an 
Alchemy account
 to obtain an API key for reliable access to the Goerli network. Alternatively, you can use other options such as 
Infura
 or 
Moralis
Configure your account on Goerli by running the commands below, which specify the network and MNEMONIC (Secret Backup Phrase) to use:
export
 
NETWORK
=
goerli
export
 
MNEMONIC
=
<
paste here your user sequence of twelve words
>
Configure your 
Alchemy
 RPC gateway URL for Goerli by running the following command:
export
 
RPC_URL
=
https://eth-goerli.alchemyapi.io/v2/
<
Replace_This_With_Your_Alchemy_API_key
>
Send an input by running the command:
yarn
 start input send --payload 
"my new message"
 --dapp echo-python
Query the layer-2 Cartesi Node for notices produced by the DApp:
yarn
 start notice list --url https://echo-python.goerli.rollups.staging.cartesi.io/graphql
tip
As shown in the last step (number 10), to query the layer-2 Cartesi Node for DApp outputs, you will need to specify the URL of its GraphQL endpoint. You can find other existing examples endpoints in the 
DApp table below
.
Explore our DApps
​
You can find several Cartesi DApp 
examples on GitHub
, such as the following:
DApp Name
DApp Deployment Status on Goerli Testnet
GraphQL endpoint URL
Echo Python
Yes
https://echo-python.goerli.rollups.staging.cartesi.io/graphql
Echo C++
Yes
https://echo-cpp.goerli.rollups.staging.cartesi.io/graphql
Echo Rust
No
-
Echo Lua
Yes
https://echo-lua.goerli.rollups.staging.cartesi.io/graphql
Echo JS DApp
Yes
https://echo-js.goerli.rollups.staging.cartesi.io/graphql
Echo Low-Level
Yes
https://echo-low-level.goerli.rollups.staging.cartesi.io/graphql
Converter
No
-
Calculator
No
_
SQLite
Yes
https://sqlite.goerli.rollups.staging.cartesi.io/graphql
k-NN
Yes
https://knn.goerli.rollups.staging.cartesi.io/graphql
m2cgen
No
-
ERC-20
No
-
Auction
No
-
Overview
Installing
Using Gitpod
Using manual setup
Building
Running
Expected logs
Advancing time
How to shutdown the environment
Interacting with the DApp
Interacting locally with the DApp
Interacting with remotely deployed DApps
Explore our DApps
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 25---










Overview of building DApps | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
tip
Navigate to our 
Quick Start
 tutorial if you want to build DApps now!
Cartesi's vision is that creating a DApp should not be too different from the general development of desktop, web, and mobile applications. To that end, Cartesi provides a Blockchain OS for building decentralized logic, giving developers full flexibility to use the tools and libraries of their preference.
From a developer's point of view, a Cartesi DApp is composed of two main parts:
Front-end
: the user facing interface, which will often provide a UI (e.g., a web application) but may also be a command line interface (e.g., a hardhat task using ethers, or a command line using python).
Back-end
: the verifiable logic that will run inside the Cartesi Rollups infrastructure; this will store and update the application state given user input, and will produce outputs in the form of 
vouchers
 (transactions that can be carried out on layer-1) and 
notices
 (information that can be validated on layer-1).
The suggested development process for Cartesi DApps involves a 
series of stages
, from the design of the application up to its final deployment. Although some of those stages involve blockchain or Cartesi-specific procedures, the intention is that developers should be able to code normally using their usual mainstream development environment for 90+% of the work, and to make that possible Cartesi provides some tools and infrastructure.
In particular, during development the Cartesi Rollups infrastructure can be executed locally in two modes, as described below.
Production Mode
​
In 
Production Mode
, the DApp's back-end logic is packaged to run inside a 
Cartesi Machine emulator
, as will be the case when the application is deployed. This means that any code written in compiled languages such as C++ or Rust must be 
cross-compiled
 to the Cartesi Machine's RISC-V architecture. In this mode, the computation performed by the back-end is reproducible and hence verifiable, enabling a truly trustless and decentralized execution.
Host Mode
​
In 
Host Mode
, the back-end logic is executed natively on localhost, just as any regular application. This is made possible because the Cartesi Rollups Host Environment provides the very same APIs as the regular mode, mimicking the behavior of the actual layer-1 and layer-2 components. This allows the developer to test and debug the back-end logic using familiar tools, such as an IDE or a debugger.
Learn more
​
Cartesi Rollups overview
DApp life cycle explained
DApp architecture
Rollups HTTP APIs
Production Mode
Host Mode
Learn more
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 26---










Hash view of state | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
One of the key goals of moving computations off-chain is to allow them to manipulate vast amounts of data: so much data that it becomes economically prohibitive to explicitly store them in the blockchain.
Nevertheless, for smart contracts to delegate computations off-chain, they must be able to specify the computations, their inputs, and then reason over their outputs.
The key to solving these seemingly contradictory goals is the clever use of cryptographic hashes.
Cartesi Machines are transparent in the sense that their entire state is exposed for external inspection.
This includes the ROM, the RAM, all flash drives, general purpose registers, control and status registers, and even the internal state of all devices.
In fact, the entire machine state is mapped into the 64-bit physical memory address space of the Cartesi Machine.
(The exact mapping is given in the 
system architecture
 section of the target perspective.)
This means that, right before a machine is executed, a cryptographic hash of its entire state can be generated.
A cryptographic hash of the state of a Cartesi Machine 
“
completely
”
 specifies the computation it is about to perform.
This is because a given state always evolve in exactly the same way (because Cartesi Machines are self-contained and reproducible) and it is infeasible to find a different machine state that produces the same cryptographic state hash.
By the same token, once the machine is done, the state hash 
“
completely
”
 specifies the result of the computation, wherever it may reside within the address space.
info
The scare quotes around 
“
completely
”
 are pedantic.
It is true that there are a multitude of machine states that produce the same state hash.
After all, the Keccak-256 state hashes fit in 256-bits, whereas machine states can take gigabytes.
There are therefore many more possible machine states than possible state hashes.
By the pigeonhole principle, there must be multiple machines with the same hash (i.e., hash collisions).
However, given only the state hash, finding a Cartesi Machine with that state hash should be virtually impossible.
Given a Cartesi Machine and its state hash, finding a 
second
 (distinct) Cartesi Machine with the same state hash should also be virtually impossible.
Even finding two different Cartesi Machines that have the same state hash (any hash) should be virtually impossible.
Cryptographic hash functions, such as Keccak-256, were designed 
specifically
 to have these properties.
The state hash of a Cartesi Machine is the root hash of a Merkle tree.
Merkle trees are binary trees where a leaf node is labeled with the hash of a data block (In the case of Cartesi Machines, a block is simply one of the 2
61
 64-bit words in the machine's physical memory address space.) and an inner node is labeled with the hash of the concatenated labels of its two child nodes.
The root hash can be obtained from the 
machine:get_root_hash()
 method.
In the command-line, the options 
--initial-hash
 and 
--final-hash
 of the 
cartesi-machine
 utility cause it to output the root hash of the Merkle tree as it is before the emulator starts running and after it is done running, respectively.
The 
cartesi.keccak(<word>)
 function of the 
cartesi
 Lua module returns the hash of a 64-bit 
<word>
.
The 
cartesi.keccak(<hash1>, <hash2>)
 overload returns the hash of the concatenation of 
<hash1>
 and 
<hash2>
.
In theory, the Merkle tree of the entire machine state could be built from these primitives and 
external state access
 to the machine instance.
In practice, most of the state is unused and implicitly filled with zeros, and this allows the Merkle tree computation to skip large swaths of the state by using precomputed pristine hashes of all power-of-2 sizes.
The computation is also smart enough to only update the parts of the tree that changed between invocations.
Tree hashes are used instead of a linear hashes because they support a variety of operations that are unavailable from linear hashes.
Merkle tree operations
​
In the Merkle tree of a Cartesi Machine state, the labels of each the 2
D
 nodes at a depth 
D
 can be seen as the root hashes for Merkle 
subtrees
 corresponding to adjacent intervals of 
2
L
 bytes in the address space, where 
L=64-D
.
Each of these nodes can be identified by an address 
A
 and the log 
L
 of the length of the interval it spans, where 
A
 is aligned to a 
2
L
 boundary.
Consider a scenario in which a smart contract knows 
only
 the state hash 
M
 for a certain Cartesi Machine.
Using Merkle trees makes the following key operations possible:
Slicing
 
—
 A user with access to the Merkle tree of 
M
 can provide data the blockchain can use to prove that the word at a given address has a given value. More generally, the user can provide data the blockchain can use to prove that a node with a given address and length in the tree has a given label;
Splicing
 
—
 A user with access to the Merkle tree of 
M
 can provide data the blockchain can use to prove that writing a given word at a given address results in a Cartesi Machine with a given state hash 
M'
.  More generally, the user can provide data the blockchain can use to prove that replacing a node of given length at a given address with another node of equal length and a given label results in a Cartesi Machine with a given state hash 
M'
.
To understand how the slicing proof works, notice that the path from the Merkle tree node at depth 
D>0
 (i.e., with log length 
L=64-D
) and address 
A
 goes through 
D
 nodes: 
n
D
, 
n
D-1
, 
…
, 
n
1
 until it reaches the root 
n
0
.
The labels associated to all these nodes can be produced as follows.
If 
n
D
 is a leaf node, the word value must be provided and the label is the hash of the word value.
Otherwise, if it is a general node, its label must be provided.
The label of 
n
D-1
 can then be obtained by hashing together the label of node 
n
D
 and the label of its sibling.
The order between these two siblings is available from the 
D
th most significant bit in address 
A
.
If it is clear, 
n
D
's label comes first, otherwise, its sibling's label comes first.
It should be obvious that, when labels for 
all siblings
 in the path from the target node to the root are provided, this process can be repeated until the label of 
n
0
 itself is obtained.
This must match the value 
M
 known to the smart contract.
In fact, due to the properties of cryptographic hashes, it is infeasible for the label so obtained to match 
M
 
unless all the data provided is true
.
The data needed for the proofs can be produced by the 
machine:get_proof(<address>, <log2-size>)
 method of a Cartesi Machine instance.
The contents of the proof returned are described in the 
host perspective
.
The same section gives the source-code for a simple function, 
roll_hash_up(<proof>, <target-hash>)
,  that implements the process described above.
Here, 
<proof>
 is the structure returned by the 
machine:get_proof()
 method.
The source-code is repeated below for convenience.
cartesi/proof.lua (excerpt)
local
 cartesi 
=
 require
"cartesi"
local
 _M 
=
 
{
}
function
 _M
.
roll_hash_up_tree
(
proof
,
 target_hash
)
    
local
 hash 
=
 target_hash
    
for
 log2_size 
=
 proof
.
log2_target_size
,
 proof
.
log2_root_size
-
1
 
do
        
local
 bit 
=
 
(
proof
.
target_address 
&
 
(
1
 
<<
 log2_size
)
)
 
~=
 
0
        
local
 first
,
 second
        
local
 i 
=
 proof
.
log2_root_size
-
log2_size
        
if
 bit 
then
            first
,
 second 
=
 proof
.
sibling_hashes
[
i
]
,
 hash
        
else
            first
,
 second 
=
 hash
,
 proof
.
sibling_hashes
[
i
]
        
end
        hash 
=
 cartesi
.
keccak
(
first
,
 second
)
    
end
    
return
 hash
end
function
 _M
.
slice_assert
(
root_hash
,
 proof
)
    
assert
(
root_hash 
==
 proof
.
root_hash
,
 
"proof root_hash mismatch"
)
    
assert
(
_M
.
roll_hash_up_tree
(
proof
,
 proof
.
target_hash
)
 
==
 root_hash
,
        
"node not in tree"
)
end
function
 _M
.
word_slice_assert
(
root_hash
,
 proof
,
 word
)
    
assert
(
proof
.
log2_target_size 
==
 
3
,
 
"not a word proof"
)
    
assert
(
root_hash 
==
 proof
.
root_hash
,
 
"proof root_hash mismatch"
)
    
assert
(
cartesi
.
keccak
(
word
)
 
==
 proof
.
target_hash
,
 
"proof target_hash mismatch"
)
    
assert
(
_M
.
roll_hash_up_tree
(
proof
,
 proof
.
target_hash
)
 
==
 root_hash
,
        
"node not in tree"
)
end
function
 _M
.
splice_assert
(
root_hash
,
 proof
,
 new_target_hash
,
 new_root_hash
)
    _M
.
slice_assert
(
root_hash
,
 proof
)
    
assert
(
_M
.
roll_hash_up_tree
(
proof
,
 new_target_hash
)
 
==
 new_root_hash
,
        
"new root hash mismatch"
)
end
function
 _M
.
word_splice_assert
(
root_hash
,
 proof
,
 old_word
,
 new_word
,
 new_root_hash
)
    _M
.
word_slice_assert
(
root_hash
,
 proof
,
 old_word
)
    
assert
(
_M
.
roll_hash_up_tree
(
proof
,
 cartesi
.
keccak
(
new_word
)
)
 
==
 new_root_hash
,
        
"new root hash mismatch"
)
end
return
 _M
To verify a slicing operation, the code first checks the root hash 
M 
 against the one found in the proof.
Then, it uses 
roll_hash_up_tree
 to recompute the root hash from the path between the target node and root.
Any mismatch triggers an assertion.
Verifying a splicing operation is just as easy.
First, the code verifies that the slicing operation is valid
This ensures that the sibling hashes are correct.
Then, it uses 
roll_hash_up_tree
 to compute the root hash from the path between the target node and root.
Only this time it starts from the new target node hash.
The resulting root hash is the hash of a tree with the old node replaced by the new.
Template instantiation
​
The most important use for the splicing operation is template instantiation.
From the blockchain perspective, a 
Cartesi Machine template
 is simply a state hash 
M
.
Instantiating the Cartesi Machine with a given input is simply the process of obtaining the state hash 
M'
 that results from replacing one or more of its input flash drives.
Each replacement is the result of a splicing operation as described above.
The splicing operation is particularly convenient if the flash drive length is a power of 2, and its start is aligned according to its length.
This is why, by default, the 
cartesi-machine
 command-line utility positions flash drives a multiples of very large powers of 2.
Result extraction
​
The most important use for the slicing operation is retrieving computation results.
In a typical scenario, a user posts the final state hash of an instantiated Cartesi Machine that has been run until it halted.
When the other users agree with this final state hash, slicing operations can be used to convince the blockchain of the contents of the halted Cartesi Machine's state.
This can be the value of a single word in a raw output flash drive, or it can be the hash for an entire flash drive.
Merkle tree operations
Template instantiation
Result extraction
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 27---










7 docs tagged with "developer" | Blockchain OS Documentation - Cartesi
























Skip to main content
Choose your Onboarding Path
Our onboarding paths answer the following questions:
Create your first DApp
Once you learned how to run a simple example, it is now time to create one of your own. In order to do this, we will make use of the DApp template available in Cartesi's rollups-examples Github repository. Once again, make sure you have installed all the necessary requirements before proceeding.
Deploying DApps
Please check the full documentation for deploying Rollups DApps to Cartesi's cloud-based execution infrastructure.
General requirements
To start developing applications using Cartesi Rollups, first make sure that the packages listed in this section are all installed and working in your system. The instructions listed below should be enough to turn a fresh copy of the latest Ubuntu LTS distribution into a fully fledged Cartesi development environment.
Overview of building DApps
Navigate to our Quick Start tutorial if you want to build DApps now!
Quick Start
This article explains how to build and interact with a minimalistic Cartesi Rollups application.
Run back-end in Host Mode
When developing an application, it is often important to easily test and debug it. For that matter, it is possible to run the Cartesi Rollups environment in host mode, so that the DApp's back-end can be executed directly on the host machine, allowing it to be debugged using regular development tools such as an IDE.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 28---










Cartesi Rollups | Blockchain OS Documentation - Cartesi
























Skip to main content
Overview
The combination of an Optimistic Rollups framework and the Cartesi Machine Emulator enables the development of smart contracts and DApps using any package or library that is available for Linux. This allows developers to break free from the scalability limitations of the Ethereum Virtual Machine (EVM), and brings the rise of a new blockchain era to handle real-life and complex use-cases.
Components
As explained in the previous section, the Cartesi Rollups framework achieves scalability by moving the bulk of the computation outside the blockchain, using the ledger as a data source but not as an execution environment. As such, the solution contains both on-chain (layer-1) and off-chain (layer-2) components.
DApp architecture
Borrowing from familiar mainstream terminology, from a developer’s point of view a Cartesi DApp is developed by implementing two main components: a front-end and a back-end.
Rollups HTTP APIs
In a Cartesi DApp, the front-end and back-end parts of the application communicate with each other through the Rollups framework via a set of HTTP APIs.
DApp life cycle
Now that we have described the architecture of a Cartesi DApp and how the front-end and back-end communicate with the Cartesi Rollups framework, let’s step back a bit to discuss how a DApp can be implemented in practice.
Rollups HTTP APIs reference
2 items
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 29---










Cartesi Machine | Blockchain OS Documentation - Cartesi
























Skip to main content
Introduction
The Cartesi Machine is Cartesi's solution for verifiable computation.
Host perspective
3 items
Target perspective
3 items
Blockchain perspective
3 items
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 30---










Command-line interface | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
In the simplest usage scenario, the 
cartesi-machine
 command-line utility can be used to define a Cartesi Machine and run it until it halts.
The command-line utility, however, is very versatile.
It was designed to simplify the most common prototyping tasks.
Initialization
​
The following command instructs 
cartesi-machine
 to build a Cartesi Machine.
The machine uses 
rom.bin
 as the ROM image, has 64MiB of RAM, uses 
linux.bin
 as the RAM image, and uses 
rootfs.ext2
 as the root file-system.
(The 
rom.bin
, 
linux.bin
, and 
rootfs.ext2
 files are generated by the 
Emulator SDK
, and sample files are available in the playground.)
Once initialization is complete, the machine executes the command 
ls /bin
 and exits.
cartesi-machine 
\
    --rom-image
=
"/opt/cartesi/share/images/rom.bin"
 
\
    --ram-length
=
64Mi 
\
    --ram-image
=
"/opt/cartesi/share/images/linux.bin"
 
\
    --flash-drive
=
"label:root,filename:/opt/cartesi/share/images/rootfs.ext2"
 
\
    -- 
"ls /bin"
The 
--rom-image
, 
--ram-image
, 
--ram-length
, and 
--flash-drive
 command-line options have the values in the example as default, so these options can be omitted.
To remove these default settings, use the command-line options 
--no-ram-image
 and 
--no-root-flash-drive
, respectively.
(The machine needs a ROM image, and, if needed, you can simply specify a different one.)
The simplified command-line is
cartesi-machine -- 
"ls /bin"
The output is
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
arch           dmesg          linux64        nuke           stty
ash            dnsdomainname  ln             pidof          su
base32         dumpkmap       login          ping           sync
base64         echo           ls             pipe_progress  tar
busybox        egrep          lsattr         printenv       touch
cat            false          lsblk          ps             true
chattr         fdflush        mk_cmds        pwd            umount
chgrp          fgrep          mkdir          resume         uname
chmod          findmnt        mknod          rm             usleep
chown          getopt         mktemp         rmdir          vi
compile_et     grep           more           run-parts      watch
cp             gunzip         mount          sed            wdctl
cpio           gzip           mountpoint     setarch        zcat
cttyhack       hostname       mt             setpriv
date           kill           mv             setserial
dd             link           netstat        sh
df             linux32        nice           sleep
Halted
Cycles: 67557971
It shows the Cartesi Machine splash screen, followed by the listing of directory 
/bin/
.
The listing was produced by the command that follows the 
--
 separator in the command line.
The Linux kernel passes this unmodified to 
/sbin/init
, and the Cartesi-provided 
/sbin/init
 script executes the command before gracefully halting the machine.
note
In many of the documentation examples, the utilities invoked from the command-line executed by a Cartesi Machine are in the default search path for executables. (This is setup by the Cartesi-provided 
/sbin/init
 script itself.)
When in doubt, or when using your own executables installed in custom locations, make sure to invoke them by using their full paths (e.g., 
/bin/ls
 or 
/bin/sh
 instead of simply 
ls
 and 
sh
.)
Interactive sessions
​
By default, the 
cartesi-machine
 utility executes the Cartesi Machine in non-interactive mode.
Verifiable computations must always be run in non-interactive sessions.
User interaction with a Cartesi Machine via the console is, after all, not reproducible.
Nevertheless, during development, it is often convenient to directly interact with the emulator, as if using a computer console.
The command-line option 
-i
 (short for 
--htif-console-getchar
) instructs the emulator to monitor the console for input, and to make this input available to the Linux kernel.
Typically, this option will be used in conjunction with the 
--
 separator and the command 
sh
, causing the Cartesi-provided 
/sbin/init
 script to drop into an interactive shell.
Interaction with the shell enables the exploration of the embedded Linux distribution from the inside.
Exiting the shell returns control back to 
/sbin/init
, which then gracefully halts the machine.
For example, if an interactive session is started with the following command
cartesi-machine -i -- 
sh
it drops into the shell.
Running the command 
ls /bin
 causes the listing of directory 
/bin
 to appear.
The command 
exit
 causes the shell to exit.
The output is
Running in interactive mode!
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
cartesi-machine:~ # ls /bin
arch           dmesg          linux64        nuke           stty
ash            dnsdomainname  ln             pidof          su
base32         dumpkmap       login          ping           sync
base64         echo           ls             pipe_progress  tar
busybox        egrep          lsattr         printenv       touch
cat            false          lsblk          ps             true
chattr         fdflush        mk_cmds        pwd            umount
chgrp          fgrep          mkdir          resume         uname
chmod          findmnt        mknod          rm             usleep
chown          getopt         mktemp         rmdir          vi
compile_et     grep           more           run-parts      watch
cp             gunzip         mount          sed            wdctl
cpio           gzip           mountpoint     setarch        zcat
cttyhack       hostname       mt             setpriv
date           kill           mv             setserial
dd             link           netstat        sh
df             linux32        nice           sleep
cartesi-machine:~ # exit
Halted
Cycles: 188641809
note
When running in interactive mode, not even the final cycle count is reproducible.
To avoid busy wait for new interactive input, the emulator sleeps from one Cartesi Machine timer interrupt to the next, skipping Cartesi Machine cycles forward so programs running inside to stay 
roughly
 in sync with wall-clock time outside.
This dynamic balancing act is sure to vary between executions and across different computers.
Flash drives
​
The command-line option 
--flash-drive=label:<label>,filename:<filename>
 can be used to add between 1 and 8 flash drives to the Cartesi Machine.
Here, the string 
<label>
 is the 
label
 for the flash drive, and 
<filename>
 points to an 
image file
 with the initial contents of the flash drive.
When the image file contains a valid file-system, the Cartesi-provided 
/sbin/init
 script will automatically mount this file-system at 
/mnt/<label>
.
To enable transparency, Cartesi Machine flash drives are mapped into the machine's 64-bit address space.
The start and length are set, respectively, by the 
start:<number>
 and 
length:<number>
 parameters to 
--flash-drive
.
By default, the start of the first flash drive (which typically holds the root file-system) is set to the beginning of the second half of the address space (i.e., at offset 2
63
).
Additional flash drives are automatically spaced uniformly within that second half of the address space.
They are therefore separated by 2
60
 bytes, which 
“
should be enough separation for everyone
”
.
(The machine will fail to instantiate if there is any overlap between the ranges occupied by multiple drives.)
If the 
start
 of 
any
 drive is specified, then the starts for 
all
 drives must be specified.
When the 
length
 parameter is omitted, the 
cartesi-machine
 utility automatically sets the size of a flash drive to match the size of its image file.
Because RISC-V uses 4KiB pages, image files must have a size multiple of 4KiB.
(The 
truncate
 utility can be used to pad a file with zeros so its size is a multiple of 4KiB.)
For convenience, numbers can be specified in decimal or hexadecimal (e.g., 
4096
 or 
0x1000
) and may include a suffix multiplier (i.e., 
Ki
 to multiply by 2
10
, 
Mi
 to multiply by 2
20
, and 
Gi
 to multiply by 2
30
).
They can also use the C programming language 
shift left
 notation to multiply by arbitrary powers of 2 (e.g. 
1 << 24
 meaning 2
24
).
When the 
length
 of a drive is specified, the 
filename
 parameter can be omitted.
In that case, the drive starts in a 
pristine
 state: i.e., filled with zeros.
If, however, both 
length
 and 
filename
 are specified, then the 
length
 must exactly match the size of image file referred to by the 
filename
 parameter.
The positioning of flash drives in the machine's address space has implications on certain operations, discussed in detail under 
the blockchain perspective
, that involve the manipulation of hashes of the Cartesi Machine state.
The preferred file-system type is 
ext2
.
This is because 
ext2
 image files can be easily created with the 
genext2fs
 command-line utility (available in Ubuntu as its own package), and manipulated with 
e2ls
, 
e2cp
, 
e2rm
, etc (command-line utilities available in Ubuntu from the 
e2tools
 package).
These utilities come pre-installed in the playground image.
Support for 
ext4
 is also enabled by default in the kernel.
(Support for additional file-systems can be enabled by modifying the configuration the 
Emulator SDK
 uses to produce 
linux.bin
 in the 
kernel/
 subdirectory.)
For example,
mkdir
 foo
echo
 
"Hello world!"
 
>
 foo/bar.txt
tar
 
\
    --sort
=
name 
\
    --mtime
=
"2022-01-01"
 
\
    --owner
=
1000
 
\
    --group
=
1000
 
\
    --numeric-owner 
\
    -cf foo.tar 
\
    --directory
=
foo 
.
genext2fs 
\
    -f 
\
    -b 
1024
 
\
    -a foo.tar 
\
    foo.ext2
cartesi-machine 
\
    --flash-drive
=
"label:foo,filename:foo.ext2"
 
\
    -- 
"cat /mnt/foo/bar.txt"
Here, a flash drive with label 
foo
 is initialized with the contents of an 
ext2
 file-system in the image file 
foo.ext2
.
note
The 
genext2fs
 command on its own would would produce a file-system that is 
not
 reproducible, in the sense that running it in different systems, or even running it twice in the same system may produce a different 
./foo.ext2
 file.
This is because the utility records modification times, user and group IDs, etc.
Worse still, it would traverse the files in the 
foo/
 directory in an unspecified order, progressively adding them to the 
foo.ext2
 file-system.
Using the 
-f
 (faketime) option eliminates the modification times problem, but does nothing to fix the remaining issues.
Enter the 
tar
 command.
It sorts all files before adding them to the archive.
It also allows us to specify the modification time, user and group IDS, etc.
The 
genext2fs
 then takes the reproducible 
tar
 file and creates a reproducible 
ext2
 file-system from it.
The Cartesi-provided 
/sbin/init
 mounts this as 
/mnt/foo
.
The command executed in the machine simply copies the contents of 
/mnt/foo/bar
 to the terminal.
The output is
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
Hello world!
Halted
Cycles: 72134050
Persistent flash drives
​
The emulator never modifies the ROM and RAM image files.
They are simply loaded into host memory and only this copy is exposed to changes caused by code executing in the target.
(The 
--dump-pmas
 command-line option can be used to inspect the modified copies for debugging purposes. See below.)
By default, the emulator does 
not
 modify the image files for any of the flash drives either.
However, since these image files can be very large, the emulator does not pre-allocate any host memory for flash drives.
Instead, it uses the operating system's memory mapping capabilities.
The operating system reads to host memory only those pages from the image file that are actually read by code executing in the target.
(Naturally, when a state hash is requested, all image files are read from disk in their entirety and processed. See below.)
These image files are mapped to host memory in a 
copy-on-write
 fashion.
When code running in the target causes the emulator to write to a mapped image file, the operating system makes a copy of the page before modification and replaces the mapping to point to the fresh copy.
The image files are never written to.
For example, running the machine
cartesi-machine 
\
    --flash-drive
=
"label:foo,filename:foo.ext2"
 
\
    -- 
"ls /mnt/foo/*.txt && cp /mnt/foo/bar.txt /mnt/foo/baz.txt && ls /mnt/foo/*.txt"
produces the output
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
/mnt/foo/bar.txt
cp: can't create '/mnt/foo/baz.txt': Permission denied
Halted
Cycles: 72008644
indicating that the file-system was modified, at least from the perspective of the target.
However, inspecting the 
foo.ext2
 image file from outside the emulator shows it is unchanged.
e2ls -al foo.ext2:*.txt
     12  100644   501    20       13 30-Jun-2020 19:40 bar.txt
This behavior is appropriate when the flash drives will only be used as inputs.
For output flash drives, target changes to the drives must reflect on the associated image files.
For that purpose, the parameter 
shared
 can be passed to command-line option 
--flash-drive
, causing the imaged files to be mapped to host memory in a 
shared
 fashion.
For example,
cartesi-machine 
\
    --flash-drive
=
"label:foo,filename:foo.ext2,shared"
 
\
    -- 
"ls /mnt/foo/*.txt && cp /mnt/foo/bar.txt /mnt/foo/baz.txt && ls /mnt/foo/*.txt"
produces exactly the same output as before.
However, the image file 
foo.ext2
 has now indeed been modified.
e2ls -al foo.ext2:*.txt
     12  100644   501    20       13 30-Jun-2020 19:40 bar.txt
     13  100644     0     0       13  1-Jan-1970 00:00 baz.txt
Limiting execution
​
Typically, the 
cartesi-machine
 utility only returns when the Cartesi Machine halts.  For example, running
cartesi-machine
produces the output
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
Nothing to do.
Halted
Cycles: 62388529
Here, the Cartesi-provided 
/sbin/init
 simply reports there is nothing to do before halting gracefully.
This takes many millions of cycles to complete: time mostly spent initializing the Linux kernel.
The machine's processor includes a control and status register (CSR), named 
mcycle
, that starts at 0 and is incremented after every instruction cycle.
The maximum cycle can be specified with the command-line option 
--max-mcycle=<number>
.
For example, adding the 
--max-mcycle=46598940
 command-line option
cartesi-machine --max-mcycle
=
46598940
produces the output
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
Cycles: 46598940
Note the execution was interrupted before the splash screen was even completed.
The ability to limit computation to an arbitrary number of cycles is fundamental to the verifiability of Cartesi Machines, as is explained in detail under the 
blockchain perspective
.
Progress feedback
​
A target application can inform the host of its progress by using a Cartesi-specific 
/dev/yield
 Linux device.
Within the target, the Linux device can be controlled in the command-line with the utility 
/opt/cartesi/bin/yield
, pre-installed in the root file-system 
rootfs.ext2
.
The progress feedback is accessed via the 
automatic progress <permil>
 command-line option.
For example, during the execution of the loop,
cartesi-machine 
\
    --htif-yield-automatic 
\
    -- 
$'for i in $(seq 0 5 1000); do yield automatic progress $i; done'
the 
cartesi-machine
 utility receives control back from the emulator at every iteration, when the target executes the 
yield
 utility.
(The directory 
/opt/cartesi/bin/
 is in the default search path for executable setup by 
/sbin/init
.)
If the 
--htif-yield-automatic
 command-line option to 
cartesi-machine
 is omitted, the emulator essentially ignores such yield requests from the target.
Each time 
cartesi-machine
 receives control due to a yield, it prints a progress message (shown at 44% below) and resumes the emulator so it can continue working.
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
Progress:  44.00
This feature is most useful when the emulator is controlled programmatically, via its Lua, C++, or gRPC interfaces, where Cartesi Machines typically run disconnected from the console.
In these situations, the progress device can be used to drive a dynamic user interface element that reassures users progress is being made during long, silent computations.
Its handling by 
cartesi-machine
, which does have access to the console, is simply to help with prototyping and debugging.
The protocols followed by the 
yield
 utility to interact with the 
/dev/yield
 driver and by the driver itself to communicate with the HTIF device are explained in detail under the 
target perspective
.
In particular, the section explains the 
manual
 yield commands (enabled by the 
--htif-yield-manual
 command-line option) needed for proper operation of Cartesi Rollups.
State hashes
​
The 
cartesi-machine
 utility can also be used to print Cartesi Machine state hashes.
State hashes are Merkle tree root hashes of the entire 64-bit address space of the Cartesi Machine, where the leaves are aligned 64-bit words.
(See the 
Hash view of states
 for an explanation of Merkle trees.)
Since Cartesi Machines are transparent, the contents of this address space encompass the entire machine state, including all processor CSRs and general-purpose registers, the contents of RAM and ROM, of all flash drives, and of all other devices connected to the board.
State hashes therefore work as cryptographic signatures of the machine, and implicitly of the computation they are about to execute.
To obtain the state hash right before execution starts, use the command-line option 
--initial-hash
.
Conversely, to obtain the state hash right after execution is done, use the option 
--final-hash
.
For example,
cartesi-machine 
\
    --max-mcycle
=
46598940
 
\
    --initial-hash 
\
    --final-hash
produces the output
0: 1392f3d52dcaa5b070fa1e91b377e8d31fecf242a5ab4e3a84cd191d5699e456
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
Cycles: 46598940
46598940: a00da7ebbe0d5d4b9fee481b9b8718fa4f91fb70bd791b5d984acb66f5c10db9
The initial state hash 
1392f3d5...
 is the Merkle tree root hash for the initial Cartesi Machine state.
Since Cartesi Machines are reproducible, the initial state hash also works as a 
promise
 on the result of the entire computation.
In other words, the 
“
final state hash
”
 
a00da7eb...
 is the 
“
only
”
 possible outcome for the 
--final-hash
 at cycle 46598940, given the result of the 
--initial-hash
 operation was 
1392f3d5...
.
info
The scare quotes around 
“
only
”
 are pedantic.
It is true that there are a multitude of machine states that produce the same state hash.
After all, the Keccak-256 state hashes fit in 256-bits, whereas machine states can take gigabytes.
There are therefore many more possible machine states than possible state hashes.
By the pigeonhole principle, there must be multiple machines with the same hash (i.e., hash collisions).
However, given only the state hash, finding a Cartesi Machine with that state hash should be virtually impossible.
Given a Cartesi Machine and its state hash, finding a 
second
 (distinct) Cartesi Machine with the same state hash should also be virtually impossible.
Even finding two different Cartesi Machines that have the same state hash (any hash) should be virtually impossible.
Cryptographic hash functions, such as Keccak-256, were designed 
specifically
 to have these properties.
Allowing the machine to run until it halts
cartesi-machine 
\
    --initial-hash 
\
    --final-hash
produces instead the output
0: 1392f3d52dcaa5b070fa1e91b377e8d31fecf242a5ab4e3a84cd191d5699e456
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
Nothing to do.
Halted
Cycles: 62388529
62388529: faa438df6e6dd027aab3710223852303964fe20f93af43c919120bc7ff3d27ba
Naturally, the initial state hash is the same as before.
However, the final state hash 
faa438df...
 now pertains to cycle 62388529, where the machine is halted.
This is the 
“
only
”
 possible state hash for a 
halted
 machine that started from state hash 
1392f3d5...
.
Persistent Cartesi Machines
​
At any point in their execution, Cartesi Machines can be stored to disk.
A stored machine can later be loaded to continue its execution from where it left off.
To store a machine to a given 
<directory>
, use the command-line option 
--store=<directory>
.
(In 
<directory>
, the 
%h
 escape will be replaced by the state hash in hex.)
The machine is stored as it was right before 
cartesi-machine
 returns to the command line.
For example, to store the machine corresponding to state hash 
a00da7eb...
cartesi-machine 
\
    --max-mcycle
=
46598940
 
\
    --store
=
"machine-a00da7eb"
This command creates a directory 
machine-a00da7eb/
, containing a variety of files that allow the Cartesi Machine emulator to recreate a machine state.
Every image file is copied into the directory, so no external dependencies remain.
note
If the machine initialization involved large image files or a considerable amount of RAM, this operation may consume significant disk space.
It will also take the time required by the copying of image files into the directory, and by the computation of the state hash.
If the directory already exists, the operation will fail.
(This prevents the overwriting of a Cartesi Machine by mistake.)
Once created, the directory can be compressed and transferred to other hosts.
To restore the corresponding Cartesi Machine, use the command-line option 
--load=<directory>
.
For example,
cartesi-machine 
\
    --load
=
"machine-a00da7eb"
 
\
    --initial-hash 
\
    --final-hash
produces the output
Loading machine: please wait
46598940: a00da7ebbe0d5d4b9fee481b9b8718fa4f91fb70bd791b5d984acb66f5c10db9
        \ /   MACHINE
         '
Nothing to do.
Halted
Cycles: 62388529
62388529: faa438df6e6dd027aab3710223852303964fe20f93af43c919120bc7ff3d27ba
Note that, other than 
--load
, no initialization command-line options were used.
These initializations were used to define the machine before it was stored: their values are implicitly encoded in the stored state.
The machine continues from where it left off, and reaches the same final state hash 
faa438df...
, as if it had never been interrupted.
Note also that the initial state hash 
a00da7eb...
 after 
--load
 matches the final state hash before 
--store
.
After all, they are state hashes concerning the state of the same machine at the same cycle.
In fact, 
--store
 writes this state hash inside the directory, and 
--load
 verifies that the state hash of the restored machine matches what it found in the directory.
The 
cartesi-machine-stored-hash
 command-line utility can be used to extract the state hash from a stored Cartesi Machine.
The command
cartesi-machine-stored-hash machine-a00da7eb
produces the output
a00da7ebbe0d5d4b9fee481b9b8718fa4f91fb70bd791b5d984acb66f5c10db9
Running as root
​
Starting at version 4.0 of 
rootfs.ext2
, the Cartesi-provided 
/sbin/init
 script runs the target application (or any initial command) as user 
uid=1000(dapp)
 group 
gid=1000(dapp)
.
This can be seen by running the command:
cartesi-machine 
\
    -- 
id
It shows the user and group are indeed 
dapp
.
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
uid=1000(dapp) gid=1000(dapp) groups=1000(dapp)
Halted
Cycles: 65938834
To instead run your target application as 
uid=0(root) gid=0(root)
, pass the parameter 
single=yes
:
cartesi-machine 
\
    --append-rom-bootargs
=
"single=yes"
 
\
    -- 
id
This produces the output:
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
uid=0(root) gid=0(root)
Halted
Cycles: 65904418
It shows the user and group are now 
root
.
Although running as root is not recommended, the feature can be used to perform setup tasks that require
elevated permissions.
Cartesi Machine templates
​
Templates
 are one of the key uses for Cartesi Machines stored to disk.
Cartesi Machine templates are machines in which the contents of one or more flash drives are still unknown.
To put it another way, Cartesi Machine templates behave like functions whose parameters are the yet-to-be-defined contents of one or more flash drives.
As discussed in detail under 
the blockchain perspective
, starting from template hashes, the hashes of the flash drives, and a small amount of 
additional information
, it is possible to obtain the state hash of the 
instantiated template
—
the state hash for a Cartesi Machine with drives replaced by their actual contents.
This is how a smart contract can specify a computation to be performed off-chain over arbitrary input.
Starting from the template hash, and in possession of the flash drive hashes, it instantiates the template, generating the initial state hash for the corresponding Cartesi Machine.
As an example, consider a Cartesi Machine that operates as an arbitrary-precision arithmetic expression evaluator.
The machine will take the expression in text format, inside a raw input flash drive labelled 
input
, and will copy the output in text format into a raw output flash drive, labelled 
output
 (
shared
, of course, so the output persists after the emulator is done).
Raw flash drives are flash drives that do not contain file-systems.
Instead, they contain data in any application-specific format.
Inside the Cartesi Machine, the 
dd
 or 
devio
 command-line utilities can be used to read data from or write data to
raw flash drives, assuming they have permission to access the underlying block device.
To simplify the examples in the documentation, we will simply run them as 
root
.
(Note that this is not recommended in deployed applications.)
The 
bc
 command-line utility is the perfect tool to evaluate the arithmetic expressions.
The command passed to 
cartesi-machine
 below reads the contents of the raw input flash drive using the 
dd
 command-line utility, extracts a zero-terminated string from it using a tiny Lua script run by the 
lua
 interpreter, pipes the result to 
bc
, and finally uses 
dd
 again to write its results to the raw output flash drive.
Here is the sample playground session
rm
 -f output.raw
truncate -s 4K output.raw
echo
 
"6*2^1024 + 3*2^512"
 
>
 input.raw
truncate -s 4K input.raw
cartesi-machine 
\
    --append-rom-bootargs
=
"single=yes"
 
\
    --flash-drive
=
"label:input,length:1<<12,filename:input.raw"
 
\
    --flash-drive
=
"label:output,length:1<<12,filename:output.raw,shared"
 
\
    -- 
$'dd status=none if=$(flashdrive input) | lua -e \'print((string.unpack("z",  io.read("a"))))\' | bc | dd status=none of=$(flashdrive output)'
lua5.3 -e 
'print((string.unpack("z", io.read("a"))))'
 
<
 output.raw
Using the 
truncate
 command-line utility, the session creates a 4KiB file 
output.raw
 containing only zeros to serve as the output drive image.
Then, it creates the 
input.raw
 file for use as the input drive image containing the expression 
6*2^1024 + 3*2^512\n
 to be evaluated.
This file is then padded with zeros to 4KiB in size by the 
truncate
 utility.
The session then invokes the 
cartesi-machine
 command-line utility to evaluate the expression.
The output of the 
cartesi-machine
 command is
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
Halted
Cycles: 85860002
Once the emulator returns, the session uses a tiny Lua script, run by the playground's 
lua5.3
 Lua interpreter, to print the contents of the output drive, which reads
10786158809173895446375831144734148401707861873653839436405804869463\
96054833005778796250863934445216126720683279228360145952738612886499\
73495708458383684478649003115037698421037988831222501494715481595948\
96901677837132352593468675094844090688678579236903861342030923488978\
36036892526733668721977278692363075584
This is indeed the result of 6
×
2
1024
+3
×
2
512
.
To create the template, simply omit the input and output image filenames.
This will cause the Cartesi Machine to assume both drives are filled with zeros.
Then, limit the computation with 
--max-mcycle=0
, to prevent the Cartesi Machine from running.
Finally, use the 
--store="calculator-template"
 command-line option to store the Cartesi Machine template.
The 
--final-hash
 command-line option prints the resulting template hash.
cartesi-machine \
    --append-rom-bootargs="single=yes" \
    --flash-drive="label:input,length:1<<12" \
    --flash-drive="label:output,length:1<<12" \
    --max-mcycle=0 \
    --final-hash \
    --store="calculator-template" \
    -- $'dd status=none if=$(flashdrive input) | lua -e \'print((string.unpack("z", io.read("a"))))\' | bc | dd status=none of=$(flashdrive output)'
The result is as follows
Cycles: 0
0: bce76332fea7cd5a2cdd28a8e85937bded73364a6cd868c36e80d88804cf64f8
Storing machine: please wait
The directory 
calculator-template/
 now contains the Cartesi Machine template.
And indeed, running
cartesi-machine-stored-hash calculator-template/
we can see from the output
370ffe6edd287bda120b6d6a3f6902e02dd1e3ca2cfaf5092970c847a38f0cb3
that the stored template hash is 
370ffe6e...
.
Templates are typically used by programs that control the emulator with the C++, Lua, or gRPC interfaces.
The 
--replace-flash-drive=start:<start>,length:<length>,filename:<filename>
 command-line option of the 
cartesi-machine
 utility can be used to replace an existing flash drive right before a machine is run.
(The 
--replace-memory-range
 command-line option is a synonym for 
--replace-flash-drive
.)
The flash drive to be replaced must be specified by its 
start
 and 
length
.
(Labels do not identify flash drives, they only provide convenient names for partitions.)
This functionality can be used to test templates.
For example, the following command loads the calculator template, and replaces its pristine input drive with a drive containing the contents of the 
input.raw
 file.
Then, it replaces the pristine output drive so the machine saves results in the file 
output.raw
.
rm
 -f output.raw
truncate -s 4K output.raw
echo
 
"6*2^1024 + 3*2^512"
 
>
 input.raw
truncate -s 4K input.raw
cartesi-machine 
\
    --load
=
"calculator-template"
 
\
    --replace-flash-drive
=
"start:0x9000000000000000,length:1<<12,filename:input.raw"
 
\
    --replace-flash-drive
=
"start:0xA000000000000000,length:1<<12,filename:output.raw,shared"
lua5.3 -e 
'print((string.unpack("z", io.read("a"))))'
 
<
 output.raw
The result of running the command is, as expected,
10786158809173895446375831144734148401707861873653839436405804869463\
96054833005778796250863934445216126720683279228360145952738612886499\
73495708458383684478649003115037698421037988831222501494715481595948\
96901677837132352593468675094844090688678579236903861342030923488978\
36036892526733668721977278692363075584
State value proofs
​
The 
cartesi-machine
 command-line utility can generate proofs concerning the contents of the machine state.
To generate a proof concerning the state as it is before the machine starts running, use the 
--initial-proof=address:<number>,log2_size:<number>[,filename=<filename>]
 option.
For proofs concerning the state after the emulator is done, use 
--final-proof
 instead.
In either case, the filename field is optional.
When provided, the proof will be written to the corresponding file.
Otherwise, the contents will be displayed on screen.
State value proofs
 are proofs that a given node in the Merkle tree of the Cartesi Machine state has a given label (i.e., a given associated hash).
Each Merkle tree node covers a contiguous range of the machine's 64-bit address space.
The size of a range is always a power of 2 (i.e., the 
<log2_size>
 power of 2).
Since the leaves have size 8 (for 64-bits), the valid values for 
<log2_size>
 are 3
…
64.
The range corresponding to each node starts at an 
<address>
 that is a multiple of its size.
For example, to generate a proof that the Cartesi Machine template above indeed contains a pristine input drive, use the command line
cartesi-machine 
\
    --load
=
"calculator-template"
 
\
    --max-mcycle
=
0
 
\
    --initial-hash 
\
    --initial-proof
=
"address:0x9000000000000000,log2_size:12,filename:pristine-input-proof"
Recall the first flash drive, the one with the 
rootfs.ext2
 image file, is present by default, and is automatically placed at starting address 
0x8000000000000000
.
The input flash drive is therefore the second drive.
It is automatically spaced by 2
60
 bytes relative to the first drive, so that its starting address is 
0x9000000000000000
.
The output of the command is
Loading machine: please wait
0: 370ffe6edd287bda120b6d6a3f6902e02dd1e3ca2cfaf5092970c847a38f0cb3
Cycles: 0
In addition, the 
pristine-input-proof
 file now contains a JSON structure with the requested proof
pristine-input-proof
{
  
"target_address"
:
 
10376293541461622784
,
  
"log2_target_size"
:
 
12
,
  
"log2_root_size"
:
 
64
,
  
"target_hash"
:
 
"d8b96e5b7f6f459e9cb6a2f41bf276c7b85c10cd4662c04cbbb365434726c0a0"
,
  
"sibling_hashes"
:
 
[
    
"7674c8ed1dcd5768ee452d76e093e93bcb003cf639169c042ec3ea100eb7f51f"
,
    
"785b01e980fc82c7e3532ce81876b778dd9f1ceeba4478e86411fb6fdd790683"
,
    
"41187451383460762c06d1c8a72b9cd718866ad4b689e10c9a8c38fe5ef045bd"
,
    
"5ba02fe28593d850f733209bb22f04bbc5537b30b206fd31eb1cb388b54cec29"
,
    
"6d4fe42ea8d1a120c03cf9c50622c2afe4acb0dad98fd62d07ab4e828a94495f"
,
    
"ced9a87b2a6a87e70bf251bb5075ab222138288164b2eda727515ea7de12e249"
,
    
"909efab43c42c0cb00695fc7f1ffe67c75ca894c3c51e1e5e731360199e600f6"
,
    
"414217a618ccb14caa9e92e8c61673afc9583662e812adba1f87a9c68202d60e"
,
    
"fa6a452470f8d645bebfad9779594fc0784bb764a22e3a8181d93db7bf97893c"
,
    
"27a31085634b6ec78864b6d8201c7e93903d75815067e378289a3d072ae172da"
,
    
"f75c40174a91f9ae6b8647854a156029f0b88b83316663ce574a4978277bb6bb"
,
    
"06cc0a6fd12230ea586dae83019fb9e06034ed2803c98d554b93c9a52348caff"
,
    
"712e55805248b92e8677d90f6d284d1d6ffaff2c430657042a0e82624fa3717b"
,
    
"214947127506073e44d5408ba166c512a0b86805d07f5a44d3c41706be2bc15e"
,
    
"7bdd613713ada493cc17efd313206380e6a685b8198475bbd021c6e9d94daab2"
,
    
"5ea69e2f7c7d2ccc85b7e654c07e96f0636ae4044fe0e38590b431795ad0f864"
,
    
"c61ce68b20307a1a81f71ca645b568fcd319ccbb5f651e87b707d37c39e15f94"
,
    
"76e1424883a45ec49d497ddaf808a5521ca74a999ab0b3c7aa9c80f85e93977e"
,
    
"91b4feecbe1789717021a158ace5d06744b40f551076b67cd63af60007f8c998"
,
    
"455306d01081bc3384f82c5fb2aacaa19d89cdfa46cc916eac61121475ba2e61"
,
    
"a1611f1b276b26530f58d7247df459ce1f86db1d734f6f811932f042cee45d0e"
,
    
"29927c21dd71e3f656826de5451c5da375aadecbd59d5ebf3a31fae65ac1b316"
,
    
"5d8b6aa5934f817252c028c90f56d413b9d5d10d89790707dae2fabb249f6499"
,
    
"8dff81e014ce25f2d132497923e267363963cdf4302c5049d63131dc03fd95f6"
,
    
"bec80f4f5d1daa251988826cef375c81c36bf457e09687056f924677cb0bccf9"
,
    
"847a230d34dfb71ed56f2965a7f6c72e6aa33c24c303fd67745d632656c5ef90"
,
    
"e63624cbd316a677cad529bbe4e97b9144e4bc06c4afd1de55dd3e1175f90423"
,
    
"a57b9796fdcb2eda87883c2640b072b140b946bfdf6575cacc066fdae04f6951"
,
    
"85d8820921ff5826148b60e6939acd7838e1d7f20562bff8ee4b5ec4a05ad997"
,
    
"1373a814641d6a1dcef97b883fee61bb84fe60a3409340217e629cc7e4dcc93b"
,
    
"d5d218ef5a296dda8ddc355f3f50c3d0b660a51dfa4d98a6a5a33564556cf83c"
,
    
"3abc751df07437834ba5acb32328a396994aebb3c40f759c2d6d7a3cb5377e55"
,
    
"674857e543d1d5b639058dd908186597e366ad5f3d9c7ceaff44d04d1550b8d3"
,
    
"21e2d8fa914e2559bb72bf0ab78c8ab92f00ef0d0d576eccdd486b64138a4172"
,
    
"4fd085aceaa7f542d787ee4196d365f3cc566e7bbcfbfd451230c48d804c017d"
,
    
"3c5126b9c7e33c8e5a5ac9738b8bd31247fb7402054f97b573e8abb9faad219f"
,
    
"fdc242788f654b57a4fb32a71b335ef6ff9a4cc118b282b53bdd6d6192b7a82c"
,
    
"fedc0d0dbbd855c8ead673544899b0960e4a5a7ca43b4ef90afe607de7698cae"
,
    
"766c5e8ac9a88b35b05c34747e6507f6b044ab66180dc76ac1a696de03189593"
,
    
"3e2337b715f6ac9a6a272622fdc2d67fcfe1da3459f8dab4ed7e40a657a54c36"
,
    
"f065ec220c1fd4ba57e341261d55997f85d66d32152526736872693d2b437a23"
,
    
"13e466a8935afff58bb533b3ef5d27fba63ee6b0fd9e67ff20af9d50deee3f8b"
,
    
"27d86025599a41233848702f0cfc0437b445682df51147a632a0a083d2d38b5e"
,
    
"99af665835aabfdc6740c7e2c3791a31c3cdc9f5ab962f681b12fc092816a62f"
,
    
"2b573c267a712a52e1d06421fe276a03efb1889f337201110fdc32a81f8e1524"
,
    
"7a71f6ee264c5d761379b3d7d617ca83677374b49d10aec50505ac087408ca89"
,
    
"f7549f26cc70ed5e18baeb6c81bb0625cb95bb4019aeecd40774ee87ae29ec51"
,
    
"2122e31e4bbd2b7c783d79cc30f60c6238651da7f0726f767d22747264fdb046"
,
    
"91e3eee5ca7a3da2b3053c9770db73599fb149f620e3facef95e947c0ee860b7"
,
    
"63e8806fa0d4b197a259e8c3ac28864268159d0ac85f8581ca28fa7d2c0c03eb"
,
    
"c9695393027fb106a8153109ac516288a88b28a93817899460d6310b71cf1e61"
,
    
"d8b96e5b7f6f459e9cb6a2f41bf276c7b85c10cd4662c04cbbb365434726c0a0"
  
]
,
  
"root_hash"
:
 
"370ffe6edd287bda120b6d6a3f6902e02dd1e3ca2cfaf5092970c847a38f0cb3"
}
The 
root_hash
 value 
370ffe6e...
 is the expected initial state hash seen in the output of the 
cartesi-machine
 command.
The 
address
 value 
10376293541461622784
 is the same as 
0x9000000000000000
 in decimal.
The 
log2_size
 value 
12
 refers to the size of the 4KiB input drive.
The 
target_hash
 value 
d8b96e5b7...
 in the proof gives the hash of the input drive.
The hash of the input drive can be also computed externally with the 
merkle-tree-hash
 command-line utility.
The utility can produce the hash of any file with a power-of-2 size.
The 
--tree-log2-size=<log2_size>
 option specifies the size.
If an input file is smaller than the specified size, the utility assumes the missing data is composed entirely of bytes 0.
The utility deals efficiently with zero paddings of any size because pristine hashes for all power-of-2 sizes can be precomputed.
For example, to quickly generate the hash for a pristine input with 4KiB size, run
head
 -c 
0
 
|
 merkle-tree-hash --tree-log2-size
=
12
to obtain
d8b96e5b7f6f459e9cb6a2f41bf276c7b85c10cd4662c04cbbb365434726c0a0
As expected, the hash values match.
The 
 
sibling_hashes
 
 array contains the hashes of the siblings to all nodes in the path from the root all the way down to the target node (excluding the root, which has no sibling).
In a process explained in the 
blockchain perspective
, using the 
address
 field, the 
target_hash
 hash, and the 
sibling_hashes
 array, it is possible to go up the tree computing the hashes along the path, until the root hash is produced.
If the root hash obtained by this process matches the expected root hash, the proof is valid.
Otherwise, something is amiss.
(Incidentally, from the hash of its sibling, the last entry in 
sibling_hashes
, it is possible to ascertain that the neighboring range to the input drive also contains 4KiB of bytes 0.)
To compute the hash for the desired 
input.raw
 file with contents 
6*2^1024 + 3*2^512\n
, padded with zeros, run
echo
 
"6*2^1024 + 3*2^512"
 
|
 merkle-tree-hash --tree-log2-size
=
12
to obtain
2c92c99754e85e3e2a29edd84228a62b051f9f55a5563f8decc7c6d5d9d8ef64
Using a process similar to the proof verification described above, it is possible to go up the Merkle tree for the template using the 
sibling_hashes
 array in the proof, but starting from the hash 
2c92c997...
 of the desired 
input.raw
 image rather than hash 
d8b96e5b...
 of the template's pristine drive.
The result is the initial state hash for the instantiated template: the same that can be seen in the initial state hash produced by the 
cartesi-machine
 command-line
echo
 
"6*2^1024 + 3*2^512"
 
>
 input.raw
truncate -s 4K input.raw
cartesi-machine 
\
    --load
=
"calculator-template"
 
\
    --replace-flash-drive
=
"start:0x9000000000000000,length:1<<12,filename:input.raw"
 
\
    --initial-hash 
\
    --initial-proof
=
"address:0x9000000000000000,log2_size:12,filename:input-proof"
 
\
    --max-mcycle
=
0
The contents of the 
input-proof
 are
input-proof
{
  
"target_address"
:
 
10376293541461622784
,
  
"log2_target_size"
:
 
12
,
  
"log2_root_size"
:
 
64
,
  
"target_hash"
:
 
"2c92c99754e85e3e2a29edd84228a62b051f9f55a5563f8decc7c6d5d9d8ef64"
,
  
"sibling_hashes"
:
 
[
    
"53bfe1357f9416dd72a9e443ed0484080380a5865df1507b6bff8f1f40b29abe"
,
    
"785b01e980fc82c7e3532ce81876b778dd9f1ceeba4478e86411fb6fdd790683"
,
    
"41187451383460762c06d1c8a72b9cd718866ad4b689e10c9a8c38fe5ef045bd"
,
    
"5ba02fe28593d850f733209bb22f04bbc5537b30b206fd31eb1cb388b54cec29"
,
    
"6d4fe42ea8d1a120c03cf9c50622c2afe4acb0dad98fd62d07ab4e828a94495f"
,
    
"ced9a87b2a6a87e70bf251bb5075ab222138288164b2eda727515ea7de12e249"
,
    
"909efab43c42c0cb00695fc7f1ffe67c75ca894c3c51e1e5e731360199e600f6"
,
    
"414217a618ccb14caa9e92e8c61673afc9583662e812adba1f87a9c68202d60e"
,
    
"fa6a452470f8d645bebfad9779594fc0784bb764a22e3a8181d93db7bf97893c"
,
    
"27a31085634b6ec78864b6d8201c7e93903d75815067e378289a3d072ae172da"
,
    
"f75c40174a91f9ae6b8647854a156029f0b88b83316663ce574a4978277bb6bb"
,
    
"06cc0a6fd12230ea586dae83019fb9e06034ed2803c98d554b93c9a52348caff"
,
    
"712e55805248b92e8677d90f6d284d1d6ffaff2c430657042a0e82624fa3717b"
,
    
"214947127506073e44d5408ba166c512a0b86805d07f5a44d3c41706be2bc15e"
,
    
"7bdd613713ada493cc17efd313206380e6a685b8198475bbd021c6e9d94daab2"
,
    
"5ea69e2f7c7d2ccc85b7e654c07e96f0636ae4044fe0e38590b431795ad0f864"
,
    
"c61ce68b20307a1a81f71ca645b568fcd319ccbb5f651e87b707d37c39e15f94"
,
    
"76e1424883a45ec49d497ddaf808a5521ca74a999ab0b3c7aa9c80f85e93977e"
,
    
"91b4feecbe1789717021a158ace5d06744b40f551076b67cd63af60007f8c998"
,
    
"455306d01081bc3384f82c5fb2aacaa19d89cdfa46cc916eac61121475ba2e61"
,
    
"a1611f1b276b26530f58d7247df459ce1f86db1d734f6f811932f042cee45d0e"
,
    
"29927c21dd71e3f656826de5451c5da375aadecbd59d5ebf3a31fae65ac1b316"
,
    
"5d8b6aa5934f817252c028c90f56d413b9d5d10d89790707dae2fabb249f6499"
,
    
"8dff81e014ce25f2d132497923e267363963cdf4302c5049d63131dc03fd95f6"
,
    
"bec80f4f5d1daa251988826cef375c81c36bf457e09687056f924677cb0bccf9"
,
    
"847a230d34dfb71ed56f2965a7f6c72e6aa33c24c303fd67745d632656c5ef90"
,
    
"e63624cbd316a677cad529bbe4e97b9144e4bc06c4afd1de55dd3e1175f90423"
,
    
"a57b9796fdcb2eda87883c2640b072b140b946bfdf6575cacc066fdae04f6951"
,
    
"85d8820921ff5826148b60e6939acd7838e1d7f20562bff8ee4b5ec4a05ad997"
,
    
"1373a814641d6a1dcef97b883fee61bb84fe60a3409340217e629cc7e4dcc93b"
,
    
"d5d218ef5a296dda8ddc355f3f50c3d0b660a51dfa4d98a6a5a33564556cf83c"
,
    
"3abc751df07437834ba5acb32328a396994aebb3c40f759c2d6d7a3cb5377e55"
,
    
"674857e543d1d5b639058dd908186597e366ad5f3d9c7ceaff44d04d1550b8d3"
,
    
"21e2d8fa914e2559bb72bf0ab78c8ab92f00ef0d0d576eccdd486b64138a4172"
,
    
"4fd085aceaa7f542d787ee4196d365f3cc566e7bbcfbfd451230c48d804c017d"
,
    
"3c5126b9c7e33c8e5a5ac9738b8bd31247fb7402054f97b573e8abb9faad219f"
,
    
"fdc242788f654b57a4fb32a71b335ef6ff9a4cc118b282b53bdd6d6192b7a82c"
,
    
"fedc0d0dbbd855c8ead673544899b0960e4a5a7ca43b4ef90afe607de7698cae"
,
    
"766c5e8ac9a88b35b05c34747e6507f6b044ab66180dc76ac1a696de03189593"
,
    
"3e2337b715f6ac9a6a272622fdc2d67fcfe1da3459f8dab4ed7e40a657a54c36"
,
    
"f065ec220c1fd4ba57e341261d55997f85d66d32152526736872693d2b437a23"
,
    
"13e466a8935afff58bb533b3ef5d27fba63ee6b0fd9e67ff20af9d50deee3f8b"
,
    
"27d86025599a41233848702f0cfc0437b445682df51147a632a0a083d2d38b5e"
,
    
"99af665835aabfdc6740c7e2c3791a31c3cdc9f5ab962f681b12fc092816a62f"
,
    
"2b573c267a712a52e1d06421fe276a03efb1889f337201110fdc32a81f8e1524"
,
    
"7a71f6ee264c5d761379b3d7d617ca83677374b49d10aec50505ac087408ca89"
,
    
"f7549f26cc70ed5e18baeb6c81bb0625cb95bb4019aeecd40774ee87ae29ec51"
,
    
"2122e31e4bbd2b7c783d79cc30f60c6238651da7f0726f767d22747264fdb046"
,
    
"91e3eee5ca7a3da2b3053c9770db73599fb149f620e3facef95e947c0ee860b7"
,
    
"63e8806fa0d4b197a259e8c3ac28864268159d0ac85f8581ca28fa7d2c0c03eb"
,
    
"c9695393027fb106a8153109ac516288a88b28a93817899460d6310b71cf1e61"
,
    
"d8b96e5b7f6f459e9cb6a2f41bf276c7b85c10cd4662c04cbbb365434726c0a0"
  
]
,
  
"root_hash"
:
 
"8cb551c358a7cb0680d0f288b27efdbe17dbb65dbca85ab90ead446f1037f018"
}
The 
target_hash
 value 
2c92c997...
 reflects the hash computed for the input, whereas 
root_hash
 value 
8cb551c3...
 differs from 
370ffe6e...
 obtained for template, as expected.
Moreover, the 
sibling_hashes
 entries in the template Cartesi Machine and in the instantiated Cartesi Machine remain the same, reflecting the fact that there were no other changes in the machine's initial state.
Another useful proof is the one for the 
output
 drive, once the machine is halted.
To obtain this proof, run
rm
 -f output.raw
truncate -s 4K output.raw
echo
 
"6*2^1024 + 3*2^512"
 
>
 input.raw
truncate -s 4K input.raw
cartesi-machine 
\
    --load
=
"calculator-template"
 
\
    --replace-flash-drive
=
"start:0x9000000000000000,length:1<<12,filename:input.raw"
 
\
    --replace-flash-drive
=
"start:0xa000000000000000,length:1<<12,filename:output.raw,shared"
 
\
    --final-hash 
\
    --final-proof
=
"address:0xa000000000000000,log2_size:12,filename:output-proof"
This produces the output
Loading machine: please wait
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
Halted
Cycles: 85941645
85941645: bbf5015f59cf06252e160b600ceb6b624935333a1a3561d8684fb8fd696cc3fd
The contents of the 
output-proof
 are
output-proof
{
  
"target_address"
:
 
11529215046068469760
,
  
"log2_target_size"
:
 
12
,
  
"log2_root_size"
:
 
64
,
  
"target_hash"
:
 
"b15a6b8aab8a423c725f9ad55fd46c4481ba91008f3a01593192de37a7a41565"
,
  
"sibling_hashes"
:
 
[
    
"66ce8ce2fe6a2a099af9407a1f407eabf29c53fb38825dd6042e6d92ea86786e"
,
    
"785b01e980fc82c7e3532ce81876b778dd9f1ceeba4478e86411fb6fdd790683"
,
    
"e989736814d39b0a523b034d86f8add116cb290b0e6e5b11688b216408dc070f"
,
    
"6d1ab973982c7ccbe6c1fae02788e4422ae22282fa49cbdb04ba54a7a238c6fc"
,
    
"6d4fe42ea8d1a120c03cf9c50622c2afe4acb0dad98fd62d07ab4e828a94495f"
,
    
"ced9a87b2a6a87e70bf251bb5075ab222138288164b2eda727515ea7de12e249"
,
    
"909efab43c42c0cb00695fc7f1ffe67c75ca894c3c51e1e5e731360199e600f6"
,
    
"414217a618ccb14caa9e92e8c61673afc9583662e812adba1f87a9c68202d60e"
,
    
"fa6a452470f8d645bebfad9779594fc0784bb764a22e3a8181d93db7bf97893c"
,
    
"27a31085634b6ec78864b6d8201c7e93903d75815067e378289a3d072ae172da"
,
    
"f75c40174a91f9ae6b8647854a156029f0b88b83316663ce574a4978277bb6bb"
,
    
"06cc0a6fd12230ea586dae83019fb9e06034ed2803c98d554b93c9a52348caff"
,
    
"712e55805248b92e8677d90f6d284d1d6ffaff2c430657042a0e82624fa3717b"
,
    
"214947127506073e44d5408ba166c512a0b86805d07f5a44d3c41706be2bc15e"
,
    
"7bdd613713ada493cc17efd313206380e6a685b8198475bbd021c6e9d94daab2"
,
    
"5ea69e2f7c7d2ccc85b7e654c07e96f0636ae4044fe0e38590b431795ad0f864"
,
    
"c61ce68b20307a1a81f71ca645b568fcd319ccbb5f651e87b707d37c39e15f94"
,
    
"76e1424883a45ec49d497ddaf808a5521ca74a999ab0b3c7aa9c80f85e93977e"
,
    
"91b4feecbe1789717021a158ace5d06744b40f551076b67cd63af60007f8c998"
,
    
"455306d01081bc3384f82c5fb2aacaa19d89cdfa46cc916eac61121475ba2e61"
,
    
"a1611f1b276b26530f58d7247df459ce1f86db1d734f6f811932f042cee45d0e"
,
    
"29927c21dd71e3f656826de5451c5da375aadecbd59d5ebf3a31fae65ac1b316"
,
    
"5d8b6aa5934f817252c028c90f56d413b9d5d10d89790707dae2fabb249f6499"
,
    
"8dff81e014ce25f2d132497923e267363963cdf4302c5049d63131dc03fd95f6"
,
    
"bec80f4f5d1daa251988826cef375c81c36bf457e09687056f924677cb0bccf9"
,
    
"847a230d34dfb71ed56f2965a7f6c72e6aa33c24c303fd67745d632656c5ef90"
,
    
"e63624cbd316a677cad529bbe4e97b9144e4bc06c4afd1de55dd3e1175f90423"
,
    
"a57b9796fdcb2eda87883c2640b072b140b946bfdf6575cacc066fdae04f6951"
,
    
"85d8820921ff5826148b60e6939acd7838e1d7f20562bff8ee4b5ec4a05ad997"
,
    
"1373a814641d6a1dcef97b883fee61bb84fe60a3409340217e629cc7e4dcc93b"
,
    
"d5d218ef5a296dda8ddc355f3f50c3d0b660a51dfa4d98a6a5a33564556cf83c"
,
    
"3abc751df07437834ba5acb32328a396994aebb3c40f759c2d6d7a3cb5377e55"
,
    
"674857e543d1d5b639058dd908186597e366ad5f3d9c7ceaff44d04d1550b8d3"
,
    
"21e2d8fa914e2559bb72bf0ab78c8ab92f00ef0d0d576eccdd486b64138a4172"
,
    
"4fd085aceaa7f542d787ee4196d365f3cc566e7bbcfbfd451230c48d804c017d"
,
    
"3c5126b9c7e33c8e5a5ac9738b8bd31247fb7402054f97b573e8abb9faad219f"
,
    
"fdc242788f654b57a4fb32a71b335ef6ff9a4cc118b282b53bdd6d6192b7a82c"
,
    
"fedc0d0dbbd855c8ead673544899b0960e4a5a7ca43b4ef90afe607de7698cae"
,
    
"766c5e8ac9a88b35b05c34747e6507f6b044ab66180dc76ac1a696de03189593"
,
    
"3e2337b715f6ac9a6a272622fdc2d67fcfe1da3459f8dab4ed7e40a657a54c36"
,
    
"f065ec220c1fd4ba57e341261d55997f85d66d32152526736872693d2b437a23"
,
    
"13e466a8935afff58bb533b3ef5d27fba63ee6b0fd9e67ff20af9d50deee3f8b"
,
    
"27d86025599a41233848702f0cfc0437b445682df51147a632a0a083d2d38b5e"
,
    
"99af665835aabfdc6740c7e2c3791a31c3cdc9f5ab962f681b12fc092816a62f"
,
    
"2b573c267a712a52e1d06421fe276a03efb1889f337201110fdc32a81f8e1524"
,
    
"7a71f6ee264c5d761379b3d7d617ca83677374b49d10aec50505ac087408ca89"
,
    
"f7549f26cc70ed5e18baeb6c81bb0625cb95bb4019aeecd40774ee87ae29ec51"
,
    
"2122e31e4bbd2b7c783d79cc30f60c6238651da7f0726f767d22747264fdb046"
,
    
"91e3eee5ca7a3da2b3053c9770db73599fb149f620e3facef95e947c0ee860b7"
,
    
"63e8806fa0d4b197a259e8c3ac28864268159d0ac85f8581ca28fa7d2c0c03eb"
,
    
"c9695393027fb106a8153109ac516288a88b28a93817899460d6310b71cf1e61"
,
    
"d8b96e5b7f6f459e9cb6a2f41bf276c7b85c10cd4662c04cbbb365434726c0a0"
  
]
,
  
"root_hash"
:
 
"bbf5015f59cf06252e160b600ceb6b624935333a1a3561d8684fb8fd696cc3fd"
}
Note how the 
root_hash
 field in the proof matches the final state hash 
bbf5015f...
 output by the 
cartesi-machine
 command-line utility.
To see that the 
target_hash
 field matches the 
output.raw
 drive, use the 
merkle-tree-hash
 command-line utility
merkle-tree-hash --tree-log2-size
=
12
 
<
 output.raw
to obtain
b15a6b8aab8a423c725f9ad55fd46c4481ba91008f3a01593192de37a7a41565
The 
cartesi-machine
 command-line utility accepts an arbitrary number of 
--initial-proof
 and 
--final-proof
 parameters.
They are computed one-by-one, and either printed or stored in the specified files, as requested.
To read more about proofs, refer to 
the blockchain perspective
.
Remote Cartesi Machines
​
The 
cartesi-machine
 command-line utility, as used until now, has always instantiated its own local Cartesi Machine.
However, it can also be used to control a remote Cartesi Machine.
Remote Cartesi Machines are managed by the 
remote-cartesi-machine
 server.
The server exposes a gRPC interface through which the 
cartesi-machine
 command-line utility (or any other software) can control the machine remotely.
To avoid confusion, it is best to run the server and client in separate shells in the playground container.
Leaving the existing shell for the client, open a separate shell for the server (For example, by running 
docker exec -it <container-name> /bin/bash
), then run
remote-cartesi-machine 
\
    --server-address
=
localhost:8080
The 
--server-address=<address>
 command-line option specifies the address and port the server will listen to.
note
In this case, since we selected 
localhost:8080
, the client must run in the same container in order to communicate with the server.
To be accessible from outside the container, the 
--server-address
 option would have to refer to an address and port that were 
exposed
 by the container.
To instruct the 
cartesi-machine
 command-line utility to connect with the server, add the command-line option

--remote-address=<address>
 to specify the remote server to connect to, and the 
--checkin-address=<address>
 option to specify an address the server will use to notify the client when it is ready.
The option 
--remote-shutdown
 causes the server to be shutdown by the client when the client exits.
(Otherwise, the server will remain available for the next client.)
All other options work as before.
Keep in mind that any image files referred to by an option passed to the command-line utility 
cartesi-machine
 must be accessible to the 
remote-cartesi-machine
 server (and not necessarily to the client).
Additionally, terminal output for the Cartesi Machine instantiated by the server will appear in the remote shell where the server was run (not the client's shell).
Terminal input, when enabled, must also happen via the remote shell.
With this in mind, running the command in the client shell
cartesi-machine 
\
    --remote-address
=
localhost:8080 
\
    --checkin-address
=
localhost:8081 
\
    --remote-shutdown
produces the following output on the client shell
Listening for checkin at 'localhost:8081'
Connecting to remote cartesi machine at 'localhost:8080'
Connected: remote version is 0.6.0
Halted
Cycles: 62388529
Shutting down remote cartesi machine
and the following output on the server shell
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
Nothing to do.
The client first binds to the check-in address, connects to the remote address, and prints out the version returned by the server.
It then asks the server to instantiate a machine (by sending the configuration over) and run it.
The machine that runs in the server prints out the splash screen, boots Linux, and cedes control to the
Cartesi-provided 
/sbin/init
 script.
The 
/sbin/init
 script figures out there is nothing to do and halts the machine.
The client detects the machine is halted and shuts down the server, as requested.
When it is desirable to leave the server running and preserve the instantiated machine, omit the 
--remote-shutdown

command-line option and add the 
--no-remote-destroy
.
For example, assuming the remote server has just been run:
remote-cartesi-machine 
\
    --server-address
=
localhost:8080
use the 
cartesi-machine
 command-line utility to instantiate and run a Cartesi Machine for 2^2O cycles:
cartesi-machine 
\
    --remote-address
=
localhost:8080 
\
    --checkin-address
=
localhost:8081 
\
    --no-remote-destroy 
\
    --max-mcycle
=
1Mi 
\
    -- 
echo
 
"Still here!"
The client shell shows:
Listening for checkin at 'localhost:8081'
Connecting to remote cartesi machine at 'localhost:8080'
Connected: remote version is 0.6.0
Cycles: 1048576
Shutting down remote cartesi machine
To continue execution of the same Cartesi Machine until it ends, rather than instantiating a new one, use the 
cartesi-machine
 command-line utility with the option 
--no-remote-create
:
cartesi-machine \
    --remote-address=localhost:8080 \
    --checkin-address=localhost:8081 \
    --no-remote-create
The client shell now shows:
Listening for checkin at 'localhost:8081'
Connecting to remote cartesi machine at 'localhost:8080'
Connected: remote version is 0.6.0
Halted
Cycles: 66003491
Shutting down remote cartesi machine
The server shell shows the execution of both sessions:
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
Still here!
Remote Cartesi Machines have one ability that local Cartesi Machines lack: they can create a state 
snapshot
 they can later 
rollback
 to.
Snapshots and rollbacks are the foundation on which the state inspection mechanism of Rolling Cartesi Machines is based, as well as the feature that enables the rejection of inputs to state advances.
Both situations require the state of the Rolling Cartesi Machine to remain unchanged.
Before Rolling Cartesi Machines were introduced, snapshots and rollbacks were used exclusively to enable efficient dispute resolution.
Rolling Cartesi Machines
​
Applications involving Rolling Cartesi Machines are not designed to interact with the 
cartesi-machine
 command-line utility.
Instead, they rely on a variety of software components that allow a front-end to post to the blockchain requests to advance the state of the server, that poll the blockchain for advance-state requests posted by others so a local copy of the server can be kept in sync, and that allow the front-end to inspect the state of the server.
Nevertheless, in debugging or prototyping tasks, the 
cartesi-machine
 command-line utility can simulate the external environment that a target application (running inside a Rolling Cartesi Machine) would encounter in production.
To use this functionality, the developer creates a sequence of advance-state requests as numbered files, or a single inspect-state request as a file, and instructs the 
cartesi-machine
 command-line utility to feed them to the target application.
As each request is processed, the utility stores the responses as separate files.
An advance-state request is composed by 
input metadata
 and an 
input
.
The input metadata include a variety of fields that are important for the operation of Cartesi Rollups (
message sender
, 
block number
, 
timestamp
, 
epoch index
, 
input index
).
The input contains only an application-specific payload.
Recall that, as responses, the target application can issue 
vouchers
, 
notices
, 
reports
, and 
exceptions
.
In contrast, an inspect state request carries only a 
query
 and, as response, produces only reports and exceptions.
Like the input to an advance-state request, the query in an inspect-state request consists of an application-specific payload.
Target applications running inside Rolling Cartesi Machines communicate with the outside world using the Cartesi-specific 
/dev/rollup
 Linux device.
The device can be accessed directly, via 
ioctl
 calls to the driver, via the 
/opt/cartesi/bin/rollup
 command-line utility, or by means of an HTTP service.
The 
/dev/rollup
 device owns a number of memory ranges that are used to pass data in and out of the machine, and uses the 
/dev/yield
 device to return control to the host and notify it of important events.
In a nutshell, the process is as follows.
When the target application attempts to obtain the next request from the device, the 
/dev/rollup
 device uses the 
/dev/yield
 device to issue a 
manual
 yield command returns control to the host (in our case, the 
cartesi-machine
 command-line utility).
The host then copies the next request to the appropriate memory ranges and resumes the machine, so the device can pass the request over to the target application for processing.
When the target application asks the device to output data (a voucher, notice, report, or exception), the 
/dev/rollup
 device copies the data to the appropriate memory ranges, then uses the 
/dev/yield
 device to issue an 
automatic
 yield command that notifies the host that a new output is available.
The host can then collect the output (in our case, saving it to files or printing it to the terminal) and resume the machine so the target application can continue processing the request.
When debugging production code, developers can obtain from Cartesi Rollups, as files, the input metadata and input associated to each advance-state request, so the sequence can be replayed locally in the command line.
When prototyping, developers can create their own files simulating requests that test the behavior of their target application under customized conditions.
Encoding requests
​
The 
rollup-memory-range
 command-line utility can encode input metadata, inputs, queries, vouchers, notices, and reports to files.
For example, the following commands create the input metadata and input files for two distinct advance-state requests
(saved as 
epoch-0-input-metadata-0.bin
, 
epoch-0-input-0.bin
, 
epoch-0-input-metadata-1.bin
, and 
epoch-0-input-1.bin
), and one query for an inspect state request (saved as 
query.bin
):
for
 
i
 
in
 
1
 
2
;
 
do
rollup-memory-range encode input-metadata 
>
 epoch-0-input-metadata-
$i
.bin 
<<-
EOF
    {
        "msg_sender": 
$(
printf
 
'"0x%040d"'
 $i
)
        "block_number": 0,
        "time_stamp": 0,
        "epoch_index": 0,
        "input_index": 
$i
    }
EOF
rollup-memory-range encode input 
>
 epoch-0-input-
$i
.bin 
<<-
EOF
    {
        "payload": "hello from input 
$i
!"
    }
EOF
done
rollup-memory-range encode input 
>
 query.bin 
<<-
EOF
{
    "payload": "hello from query!"
}
EOF
Listing the files created
ls
 *.bin
We see
epoch-0-input-1.bin  epoch-0-input-metadata-1.bin  query.bin
epoch-0-input-2.bin  epoch-0-input-metadata-2.bin
Running a simple target application
​
The command-line utility 
/opt/cartesi/bin/ioctl-echo-loop
, pre-installed in the root file-system 
rootfs.ext2
, is a simple Rolling Cartesi Machine application that merely outputs (as vouchers, notices, or reports) the payload it receives as the input to advance-state or query to inspect-state.
It is perfect to showcase the input-output mechanism.
Since Rolling Cartesi Machines rely on the snapshot/rollback functionality of Remote Cartesi Machines, running a Rolling Cartesi Machine in the command line requires using the 
remote-cartesi-machine
 server in combination with the 
cartesi-machine
 client.
With the files just created by 
rollup-memory-ranges
 in the working directory
ls
 *.bin
epoch-0-input-1.bin  epoch-0-input-metadata-1.bin  query.bin
epoch-0-input-2.bin  epoch-0-input-metadata-2.bin
run the remote server with the command
remote-cartesi-machine 
\
    --server-address
=
localhost:8080
Then, from a different shell into the same container, run the client with the command
cartesi-machine 
\
    --remote-address
=
localhost:8080 
\
    --checkin-address
=
localhost:8081 
\
    --remote-shutdown 
\
    --rollup 
\
    --rollup-advance-state
=
epoch_index:0,input_index_begin:1,input_index_end:3,hashes 
\
    --rollup-inspect-state 
\
    -- ioctl-echo-loop --vouchers
=
1
 --notices
=
1
 --reports
=
1
 --reject
=
1
The command-line option 
--rollup
 is a shortcut that combines a variety of settings needed by the Rolling Cartesi Machine functionality.
The command-line option 
--rollup-advance-state
 instructs the utility to look for input metadata and input files to use in a sequence of advance-state requests.
By default, the name of the input metadata and input files are 
epoch-%e-input-metadata-%i.bin
 and 
epoch-%e-input-%i.bin
, respectively, where 
%e
 is replaced by the epoch index and 
%i
 by the input index.
The epoch index is given by the parameter 
epoch_index=<number>
, and the input index progressively takes the values in the (open ended) range given by parameters 
input_index_begin=<number>
 and 
input_index_end=<number>
.
In the example, two advance-state requests will be performed for epoch 0: one for input 1 and one for input 2.
The file names therefore match those of the encoded files present in the working directory.
The parameter 
hashes
 instructs the utility to print the state hashes between state advances, both before and after it writes the request data to the appropriate memory ranges in the machine state.
The command-line option 
--rollup-inspect-state
 causes the utility to create an inspect-state request right after all advance-state requests have been carried out (if any).
By default, the query is loaded from a file 
query.bin
.
Finally, the command-line for 
ioctl-echo-loop
 instructs it to echo each payload as one voucher, one notice, and one report, and to reject the input with index 1.
As a result of these commands, the server shell simply shows the splash screen and a message from 
ioctl-echo-loop
 declaring what will be echoed:
         
.
        / 
\
      /    
\
\
---/---
\
  /----
\
 
\
       X       
\
  
\
----/  
\
---/---
\
       
\
    / CARTESI
        
\
 /   MACHINE
         '
Echoing as 
1
 voucher copies, 
1
 notice copies, and 
1
 report copies
The client shell shows a lot more activity:
Listening 
for
 checkin at 
'localhost:8081'
Connecting to remote cartesi machine at 
'localhost:8080'
Connected: remote version is 
0.6
.0
Manual yield rx-accepted 
(
0x100000000 data
)
..
.
The client starts by printing information about the remote server it connected to.
It then runs the machine in a loop, occasionally transferring information in and out.
The first 
manual yield rx-accepted
 signals the point at which the target application attempted to obtain the first request.
In other words, the application is 
ready
.
..
.
Epoch 
0
 before input 
1
65523739
: 3b038dea784432b1339830cadb5ec4c6ed6fcd49dfb92576daa0243a70039d3a
Loading epoch-0-input-metadata-1.bin
Loading epoch-0-input-1.bin
65523739
: e994e56a784c99f5da16df152731cc62f3f99ca05f65ac0f8ffa63605c8f96d2
Automatic yield tx-voucher 
(
0x300000000 data
)
Cycles: 
65606624
Storing epoch-0-input-1-voucher-0.bin
Automatic yield tx-notice 
(
0x400000000 data
)
Cycles: 
65619533
Storing epoch-0-input-1-notice-0.bin
Automatic yield tx-report 
(
0x500000000 data
)
Cycles: 
65620606
Storing epoch-0-input-1-report-0.bin
Manual yield rx-rejected 
(
0x200000000 data
)
Cycles: 
65621222
Storing epoch-0-input-1-voucher-hashes.bin
..
.
Upon receiving control back from the machine at cycle 65523739, the client prints the epoch index 0 and input index 1, prints state hash 
3b038dea...
, loads files 
epoch-0-input-metadata-1.bin
 and 
epoch-0-input-1.bin
 into the appropriate memory ranges, prints the modified state hash 
e994e56a...
, and resumes the machine.
The 
ioctl-echo-loop
 application reads the payload from the request input and echoes it into one voucher, one notice, and one report.
These operations generate the different flavors of 
automatic yield
 that can be seen in the client output: a 
tx-voucher
 at cycle 65606624, a 
tx-notice
 at cycle 65619533, and a 
tx-report
 at cycle 65620606.
For each of them, the client receives control back from the machine.
It reads the appropriate memory range to store files 
epoch-0-input-1-voucher-0.bin
, 
epoch-0-input-1-notice-0.bin
, and 
epoch-0-input-1-report-0.bin
, respectively.
The 
manual yield rx-rejected
 at cycle 65621222 signals that the 
ioctl-echo-loop
 application is done processing input index 1 of epoch 0 (and rejected it!).
During the processing of an advance-state request, when the 
/dev/rollup
 Linux device receives a voucher, it appends its hash into a memory array.
It does the same for the notices it receives.
Since there will be no more vouchers or notices generated for the input (it was, after all, rejected), the client saves the hash arrays into files 
epoch-0-index-1-voucher-hashes.bin
 and 
epoch-0-index-1-notice-hashes.bin
, respectively.
In production, when an input to an advance state request is rejected, the Server Manager will rollback the Rolling Cartesi Machine to the state it was before the input was processed.
Moreover, all vouchers and notices are deleted (the reports are preserved).
To make prototyping realistic, the 
cartesi-machine
 client also rolls the state back when an input is rejected by the target.
This can be confirmed by the fact that the cycle counts (65523739) and state hashes (
3b038dea...
) following the epoch 0 input 1 and epoch 0 input 2 are the same.
(The files with the vouchers and notices issued before rejection, as well as the files with the arrays of hashes, are left in place for the developer's inspection.)
..
.
Epoch 
0
 before input 
2
65523739
: 3b038dea784432b1339830cadb5ec4c6ed6fcd49dfb92576daa0243a70039d3a
Loading epoch-0-input-metadata-2.bin
Loading epoch-0-input-2.bin
65523739
: 7b8af5767f3fbf359b6d809c65175e49c7eee15c847e41a71190d3b7b967406d
Automatic yield tx-voucher 
(
0x300000000 data
)
Cycles: 
65606624
Storing epoch-0-input-2-voucher-0.bin
Automatic yield tx-notice 
(
0x400000000 data
)
Cycles: 
65619533
Storing epoch-0-input-2-notice-0.bin
Automatic yield tx-report 
(
0x500000000 data
)
Cycles: 
65620606
Storing epoch-0-input-2-report-0.bin
Manual yield rx-accepted 
(
0x100000000 data
)
Cycles: 
65621221
Storing epoch-0-input-2-voucher-hashes.bin
Storing epoch-0-input-2-notice-hashes.bin
..
.
A similar procedure is followed when processing the advance-state request with input index 2 of epoch index 0, except this time the input is accepted.
Indeed, when the 
manual yield rx-accepted
 at cycle 65621221 is received by the client, it has run out of advance-state requests to return.
..
.
Before query
Loading query.bin
Automatic yield tx-report 
(
0x500000000 data
)
Cycles: 
65622895
Storing query-report-0.bin
Manual yield rx-accepted 
(
0x100000000 data
)
Cycles: 
65623509
Shutting down remote cartesi machine
The client now moves to the inspect-state request.
It loads 
query.bin
, copies it to the appropriate memory range, and resumes the machine so the 
ioctl-echo-loop
 application can respond to the inspect-state request.
The 
automatic yield tx-report
 at cycle 65622895 signals the application issued a report, which the client then saves as 
query-report-0.bin
.
Finally, when the subsequent 
manual yield rx-accepted
 is received at cycle 656066240, the client simply shuts down the remote Cartesi Machine server and exits.
Here is the complete list of 
.bin
 files after the client exits:
ls
 *.bin
epoch-0-input-1-notice-0.bin        epoch-0-input-2-report-0.bin
epoch-0-input-1-notice-hashes.bin   epoch-0-input-2-voucher-0.bin
epoch-0-input-1-report-0.bin        epoch-0-input-2-voucher-hashes.bin
epoch-0-input-1-voucher-0.bin       epoch-0-input-2.bin
epoch-0-input-1-voucher-hashes.bin  epoch-0-input-metadata-1.bin
epoch-0-input-1.bin                 epoch-0-input-metadata-2.bin
epoch-0-input-2-notice-0.bin        query-report-0.bin
epoch-0-input-2-notice-hashes.bin   query.bin
Decoding responses
​
The 
rollup-memory-range
 command-line utility can decode input metadata, inputs, queries, vouchers, notices, reports, and hashes.
For example, we can decode the files we encoded for the first advance-state request we created above with the commands:
rollup-memory-range decode input-metadata 
<
 epoch-0-input-metadata-2.bin
{
  "msg_sender":"0x0000000000000000000000000000000000000002",
  "block_number":0,
  "time_stamp":0,
  "epoch_index":0,
  "input_index":2
}
rollup-memory-range decode input 
<
 epoch-0-input-2.bin
{
  "payload":"hello from input 2!"
}
A voucher carries an 
address
 and a 
payload
.
The 
ioctl-echo-loop
 utility copies the 
msg-sender
 field from the input metadata to the 
address
 field of the voucher, and the payload from the input to the payload of the voucher.
We can see this by decoding the voucher 
epoch-0-input-2-voucher-0.bin
 file with the commands
rollup-memory-range decode voucher 
<
 epoch-0-input-2-voucher-0.bin
{
  "address":"0x0000000000000000000000000000000000000002",
  "payload":"hello from input 2!"
}
The results match what was expected from the 
ioctl-echo-loop
 utility.
Notices and reports carry only a payload.
To decode them, run, for example:
rollup-memory-range decode notice 
<
 epoch-0-input-2-notice-0.bin
{
  "payload":"hello from input 2!"
}
rollup-memory-range decode report 
<
 query-report-0.bin
{
  "payload":"hello from query!"
}
Once again, the echo program does its job as expected.
Rolling Cartesi Machine templates
​
A Rolling Cartesi Machine template is a machine that has been configured to support Cartesi Rollups, is running a target application in a request-processing loop, is ready to process the next request, and has been stored.
As an example, we will create a Rolling Cartesi Machine template for an arbitrary-precision arithmetic expression evaluator that outputs, as a notices, the result of computation it receives as inputs to advance-state requests.
We will, once again, rely on the 
bc
 command-line utility to perform the computations.
To interact with the 
/dev/rollup
 Linux device (i.e., to obtain the advance-state request inputs and to generate the notices), we will use the 
/opt/cartesi/bin/rollup
 command-line utility.
Shell scripts become surprisingly powerful with the help of the 
rollup
 and 
jq
 command-line utilities.
A 
bc
-based arbitrary precision application, for example, might look like this:
calc.sh
#!/bin/sh
reqfile
=
$(
mktemp /tmp/calc.XXXXXX
)
status
=
"accept"
while
 
:
do
  rollup 
$status
 
>
 
"
$reqfile
"
  
request_type
=
$(
jq -j .request_type 
<
 
"
$reqfile
"
)
  
status
=
"reject"
  
if
 
[
 
"
$request_type
"
 
=
 
"advance_state"
 
]
;
  
then
    jq -j 
'.data.payload'
 
<
 
"
$reqfile
"
 
|
 
\
      
bc
 
|
 
\
        
tr
 -d 
'\\\n'
 
|
 
\
          jq -R 
'{ payload: . }'
 
|
 
\
            rollup notice 
>
 /dev/null 
&&
 
\
              
status
=
"accept"
  
fi
done
rm
 
"
$reqfile
"
The 
rollup
 command-line utility supports the commands 
accept
, 
reject
, 
voucher
, 
notice
, 
report
, and 
exception
.
It uses JSON objects as inputs and outputs.
The 
accept
 and 
reject
 commands accept or reject the previous request and output the next request.
For advance-state requests, the output is in the format
{
  
"request_type"
:
 
"advance_state"
  
"data"
:
 
{
    
"metadata"
:
 
{
      
"msg_sender"
:
 
<
hash
>
,
      
"timestamp"
:
 
<
number
>
,
      
"block_number"
:
 
<
number
>
,
      
"epoch_index"
:
 
<
number
>
,
      
"input_index"
:
 
<
number
>
    
}
,
    
"payload"
:
 
<
string
>
  
}
,
}
Appropriately, the 
notice
 command generates a notice.
The input format is as follows
{
  
"payload"
:
 
<
string
>
}
and the output (not used by 
calc.sh
) gives the index of the just-output notice as follows
{
  
"index"
:
 
<
number
>
}
The loop in the 
calc.sh
 script calls 
rollup finish
 to obtain the next request (and accept or reject the previous).
It uses 
jq
 to extract the 
request_type
 field and, if it is an 
"advance_state"
 request, it uses 
jq
 again to extract the 
"payload"
 field inside the 
"data"
 field.
This is passed to the 
bc
 utility, which outputs the result split into lines terminated by 
\
.
The 
tr
 utility joins the lines back together.
The result is again fed to 
jq
, which assembles the proper JSON object with a 
"payload"
 field that is passed to 
rollup notice
.
To use 
calc.sh
 in a Rolling Cartesi Machine template, first create a filesystem with the program:
mkdir calc
cp calc.sh calc
chmod +x calc/calc.sh
tar \
    --sort=name \
    --mtime="2022-01-01" \
    --owner=1000 \
    --group=1000 \
    --numeric-owner \
    -cf calc.tar \
    --directory=calc .
genext2fs \
    -f \
    -b 1024 \
    -a calc.tar \
    calc.ext2
Then, follow a procedure similar to the creation of Cartesi Machine templates, using the command line
cartesi-machine 
\
    --rollup 
\
    --flash-drive
=
label:calc,filename:calc.ext2 
\
    --store
=
"rolling-calculator-template"
 
\
    -- /mnt/calc/calc.sh
The result is as follows
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
Manual yield rx-accepted (0x100000000 data)
Cycles: 76814049
Storing machine: please wait
The machine execution stops when the first call to 
rollup finish
 yields, and the machine at that state is stored in directory 
"rolling-calculator-template"
.
note
In production, if the target application finds an irrecoverable error during initialization, it should abort with an exception.
In that case, the 
cartesi-machine
 command-line utility will detect the exception, print it to the console, and exit with a status-code reporting failure.
To test the template, create a couple advance-state requests (input and input metadata):
rollup-memory-range encode input-metadata 
>
 epoch-0-input-metadata-1.bin 
<<-
EOF
{
    "msg_sender": 
$(
printf
 
'"0x%040d"'
 
1
)
    "block_number": 0,
    "time_stamp": 0,
    "epoch_index": 0,
    "input_index": 1
}
EOF
rollup-memory-range encode input 
>
 epoch-0-input-1.bin 
<<-
EOF
{
    "payload": "invalid input"
}
EOF
rollup-memory-range encode input-metadata 
>
 epoch-0-input-metadata-2.bin 
<<-
EOF
{
    "msg_sender": 
$(
printf
 
'"0x%040d"'
 
2
)
    "block_number": 0,
    "time_stamp": 0,
    "epoch_index": 0,
    "input_index": 2
}
EOF
rollup-memory-range encode input  
>
 epoch-0-input-2.bin 
<<-
EOF
{
    "payload": "6*2^1024 + 3*2^512"
}
EOF
With the files just created by 
rollup-memory-ranges
 in the working directory, run the remote server with the command
ls
 *.bin
epoch-0-input-1.bin  epoch-0-input-metadata-1.bin
epoch-0-input-2.bin  epoch-0-input-metadata-2.bin
remote-cartesi-machine 
\
    --server-address
=
localhost:8080
Then, from a different shell into the same container, run the client with the command
cartesi-machine 
\
    --remote-address
=
localhost:8080 
\
    --checkin-address
=
localhost:8081 
\
    --remote-shutdown 
\
    --rollup 
\
    --rollup-advance-state
=
epoch_index:0,input_index_begin:1,input_index_end:3,hashes 
\
    --load
=
"rolling-calculator-template"
The client shell shows
Listening for checkin at 'localhost:8081'
Connecting to remote cartesi machine at 'localhost:8080'
Connected: remote version is 0.6.0
Loading machine: please wait
Manual yield rx-accepted (0x100000000 data)
Cycles: 76814049
Epoch 0 before input 1
76814049: c21c9af376e7549906c252f468e7c4d74f8ea4bc9af0ce2defdfb9facdb2add8
Loading epoch-0-input-metadata-1.bin
Loading epoch-0-input-1.bin
76814049: 68cefae426b0589152d8ad36c47c0e0739b17e7bbcbdc1e3e61d1836e03c5be8
Manual yield rx-rejected (0x200000000 data)
Cycles: 116070336
Storing epoch-0-input-1-voucher-hashes.bin
Storing epoch-0-input-1-notice-hashes.bin
Epoch 0 before input 2
76814049: c21c9af376e7549906c252f468e7c4d74f8ea4bc9af0ce2defdfb9facdb2add8
Loading epoch-0-input-metadata-2.bin
Loading epoch-0-input-2.bin
76814049: 34eb84e7149b168badef7c9a330a6bc40a1c10de94276431876923beda2ba219
Automatic yield tx-notice (0x400000000 data)
Cycles: 113292509
Storing epoch-0-input-2-notice-0.bin
Manual yield rx-accepted (0x100000000 data)
Cycles: 116831231
Storing epoch-0-input-2-voucher-hashes.bin
Storing epoch-0-input-2-notice-hashes.bin
Shutting down remote cartesi machine
It starts by loading the machine from directory 
"rolling-calculator-template"
 and printing again the same yielded state that held when the server template was created.
Then, the first input is rejected, as the payload 
"invalid input"
 is not an expression that 
bc
 can understand.
Finally, the second input, with payload 
"6*2^1024 + 3*2^512"
, is accepted.
Indeed, to see the result of the computation specified in the second input, run
rollup-memory-range decode notice 
<
 epoch-0-input-2-notice-0.bin 
|
 
\
    jq -r .payload 
|
 
\
    
fold
 -w 
68
to produce
10786158809173895446375831144734148401707861873653839436405804869463
96054833005778796250863934445216126720683279228360145952738612886499
73495708458383684478649003115037698421037988831222501494715481595948
96901677837132352593468675094844090688678579236903861342030923488978
36036892526733668721977278692363075584
The server shell shows only the error message output by 
bc
 and 
rollup
.
In production, these error messages should have been captured and output as a report, rather than being allowed to leak into the console.
bc: bad expression at 'input'
[json.exception.parse_error.101] parse error at line 1, column 1: syntax error while parsing value - unexpected end of input; expected '[', '{', or a literal
Rarely used options
​
danger
This is an advanced section, not needed by regular users of the Cartesi platform.
The command-line option 
--append-rom-bootargs=<string>
 can be used to append any 
<string>
 to the kernel command-line.
A detailed description of all kernel command-line parameters is beyond the scope of this document.
Please refer to the appropriate 
section of the kernel documentation
.
For example, to prevent clutter in the console, the 
cartesi-machine
 utility automatically adds the 
quiet
 option to the kernel command-line, disabling most log messages.
To override this setting and see more of the log messages output to console, use the 
loglevel=<n>
 parameter.
cartesi-machine 
\
    --append-rom-bootargs
=
"loglevel=8"
The output is
[    0.000000] OF: fdt: Ignoring memory range 0x80000000 - 0x80200000
[    0.000000] Linux version 5.5.19-ctsi-6 (developer@buildkitsandbox) (gcc version 10.2.0 (crosstool-NG 1.24.0.199_dd20ee5)) #1 Mon Aug 29 20:18:47 UTC 2022
[    0.000000] Zone ranges:
[    0.000000]   DMA32    [mem 0x0000000080200000-0x0000000083feffff]
[    0.000000]   Normal   empty
[    0.000000] Movable zone start for each node
[    0.000000] Early memory node ranges
[    0.000000]   node   0: [mem 0x0000000080200000-0x0000000083feffff]
[    0.000000] Initmem setup node 0 [mem 0x0000000080200000-0x0000000083feffff]
[    0.000000] On node 0 totalpages: 15856
[    0.000000]   DMA32 zone: 217 pages used for memmap
[    0.000000]   DMA32 zone: 0 pages reserved
[    0.000000]   DMA32 zone: 15856 pages, LIFO batch:3
[    0.000000] software IO TLB: mapped [mem 0x83eed000-0x83eed800] (0MB)
[    0.000000] elf_hwcap is 0x1101
[    0.000000] pcpu-alloc: s0 r0 d32768 u32768 alloc=1*32768
[    0.000000] pcpu-alloc: [0] 0 
[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 15639
[    0.000000] Kernel command line: console=hvc0 rootfstype=ext2 root=/dev/mtdblock0 rw quiet swiotlb=noforce mtdparts=flash.0:-(root) loglevel=8
[    0.000000] Dentry cache hash table entries: 8192 (order: 4, 65536 bytes, linear)
[    0.000000] Inode-cache hash table entries: 4096 (order: 3, 32768 bytes, linear)
[    0.000000] Sorting __ex_table...
[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off
[    0.000000] Memory: 57472K/63424K available (3582K kernel code, 200K rwdata, 605K rodata, 128K init, 242K bss, 5952K reserved, 0K cma-reserved)
[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
[    0.000000] NR_IRQS: 0, nr_irqs: 0, preallocated irqs: 0
[    0.000000] riscv_timer_init_dt: Registering clocksource cpuid [0] hartid [0]
[    0.000000] clocksource: riscv_clocksource: mask: 0xffffffffffffffff max_cycles: 0x1d854df40, max_idle_ns: 3526361616960 ns
[    0.000033] sched_clock: 64 bits at 1000kHz, resolution 1000ns, wraps every 2199023255500ns
[    0.000534] Console: colour dummy device 80x25
[    0.004712] printk: console [hvc0] enabled
[    0.004893] Calibrating delay loop (skipped), value calculated using timer frequency.. 2.00 BogoMIPS (lpj=10000)
[    0.005156] pid_max: default: 32768 minimum: 301
[    0.005808] Mount-cache hash table entries: 512 (order: 0, 4096 bytes, linear)
[    0.006011] Mountpoint-cache hash table entries: 512 (order: 0, 4096 bytes, linear)
[    0.009544] devtmpfs: initialized
[    0.011817] random: get_random_u32 called from bucket_table_alloc.isra.0+0x6c/0x11c with crng_init=0
[    0.012501] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns
[    0.012949] futex hash table entries: 256 (order: 0, 6144 bytes, linear)
[    0.014444] NET: Registered protocol family 16
[    0.031225] clocksource: Switched to clocksource riscv_clocksource
[    0.050902] NET: Registered protocol family 2
[    0.053463] tcp_listen_portaddr_hash hash table entries: 256 (order: 0, 4096 bytes, linear)
[    0.053715] TCP established hash table entries: 512 (order: 0, 4096 bytes, linear)
[    0.053974] TCP bind hash table entries: 512 (order: 0, 4096 bytes, linear)
[    0.054197] TCP: Hash tables configured (established 512 bind 512)
[    0.054558] UDP hash table entries: 256 (order: 1, 8192 bytes, linear)
[    0.054801] UDP-Lite hash table entries: 256 (order: 1, 8192 bytes, linear)
[    0.055442] NET: Registered protocol family 1
[    0.057002] workingset: timestamp_bits=62 max_order=14 bucket_order=0
[    0.354216] physmap-flash 8000000000000000.flash: physmap platform flash device: [mem 0x8000000000000000-0x8000000004ffffff]
[    0.354494] 1 cmdlinepart partitions found on MTD device flash.0
[    0.354647] Creating 1 MTD partitions on "flash.0":
[    0.354786] 0x000000000000-0x000005000000 : "root"
[    0.359122] NET: Registered protocol family 17
[    0.361116] VFS: Mounted root (ext2 filesystem) on device 31:0.
[    0.361486] devtmpfs: mounted
[    0.361890] Freeing unused kernel memory: 128K
[    0.362007] This architecture does not have kernel memory protection.
[    0.362164] Run /sbin/init as init process
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
[    0.466375] random: crng init done
Nothing to do.
[    0.567990] reboot: Power down
Halted
Cycles: 63873507
To clear the kernel command-line, use the option 
--no-rom-bootargs
.
Notice that, without any options, the machine will not operate properly.
In particular, as explained under the 
Lua interface
, flash-drives use kernel command-line arguments.
For example, running the 
cartesi-machine
 command-line utility with no arguments produces a kernel command-line
equivalent to running the command
cartesi-machine 
\
    --no-rom-bootargs 
\
    --append-rom-bootargs
=
"console=hvc0 rootfstype=ext2 root=/dev/mtdblock0 rw quiet swiotlb=noforce mtdparts=flash.0:-(root)"
The command-line option 
--periodic-hashes=<number-period>[,<number-start>]
 causes the command-line utility to periodically obtain and print the state hash.
The 
<number-period>
 argument gives the distance between hashes in cycles. The optional 
<number-start>
 argument gives the starting cycle for the periodic hashes. (Both 
--initial-hash
 and 
--final-hash
 are implied by this option.)
For example, to see the last 10 state hashes from the calculator machine computation, run the command
echo
 
"6*2^1024 + 3*2^512"
 
>
 input.raw
truncate -s 4K input.raw
cartesi-machine 
\
    --load
=
"calculator-template"
 
\
    --replace-flash-drive
=
"start:0x9000000000000000,length:1<<12,filename:input.raw"
 
\
    --periodic-hashes
=
1,85941635
The output is
Loading machine: please wait
0: 8cb551c358a7cb0680d0f288b27efdbe17dbb65dbca85ab90ead446f1037f018
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
85941635: baec7c3805d03d80ed82abffbdb07e8ce444321057d8c128e4e8191fa6c63125
85941636: 4381ad2b52fe6dca408d1c3f922c4adbcc119b554867dfb5e467651bbe69866f
85941637: 1e7397164110cbd88b2f6fbe6b412287c763b51ef2b0f46ae613a0e390af1bad
85941638: 29dcc26b33fbdf08145d4edf378fb7fc167def96dcd442424520ccf08ff1e3c3
85941639: 230d31a46ad24ae2c097e337e27bfba82541e0b7f3e514e19bbf9b73a7601730
85941640: 7bfe0c514f93e8765781216221b7efabb02a3f883fadac2f57ef715636598952
85941641: 97baf0dd63c88a826f0f4cac452d78fd6b54bc0f15be4c74cc3d0bda0857e62e
85941642: bd589544dd0bdffb664a6b9d502c79672d6f7e9ff0a41ad5132bc67d83621ef1
85941643: 57e749c5d441bfac0f9bf5fa4a346809cfa9ed2c96514edf8182cd776fc80cd2
85941644: 88d976d5fcbea213c338f307a69c93c5aa0ff339db1d8e244b305f45eff122c6
Halted
Cycles: 85941645
85941645: bbf5015f59cf06252e160b600ceb6b624935333a1a3561d8684fb8fd696cc3fd
The command-line option 
--dump-pmas
 causes the emulator to dump the contents of all mapped spans in the address space to files.
Each span produces a file 
<start>--<length>.bin
.
Every other byte in the address space has value 0.
This is useful to inspect the entire state of the machine from outside the emulator.
The command-line options 
--store-config
 and 
--load-config
 store or load a file with information that can be used to initialize the exact same Cartesi Machine that the 
cartesi-machine
 command-line utility will use.
The format of these configuration files is explained in detail under the 
Lua interface
 to Cartesi Machines.
In particular,  the 
--store-config
 option, without arguments, dumps to screen all the options used to define the Cartesi Machine.
This information can be very useful when debugging problems.
The remaining options in the command-line utility 
cartesi-machine
 are mostly useful for low-level tests and debugging.
As such, they require some context.
During verification, the blockchain mediates a 
verification game
 between the disputing parties.
This process is explained in detail under the 
the blockchain perspective
.
In a nutshell, both parties started from a Cartesi Machine that has a known and agreed upon initial state hash.
(E.g., an agreed upon template that was instantiated with an agreed upon input drive.)
At the end of the computation, these parties now disagree on the state hash for the halted machine.
The state hash evolves as the machine executes steps in its fetch-execute loop.
The first stage of the verification game therefore searches for the 
step of disagreement
: the particular cycle such that the parties agree on the state hash before the step, but disagree on the state hash after the step.
Once this step of disagreement is identified, one of the parties sends to the blockchain a log of state accesses that happen along the step, including cryptographic proofs for every value read from or written to the state.
This log proves to the blockchain that the execution of the step transitions the state in such a way that it reaches the state hash claimed by the submitting party.
The 
--step
 command-line option instructs 
cartesi-machine
 to dump to screen an abridged, user-friendly version of this state access log.
For the sake of completeness, consider the example in which the Cartesi Machine was stopped while it drew the splash screen.
The example below shows the step it was about to execute
cartesi-machine 
\
    --max-mcycle
=
46598940
 
\
    --step 
>
 /dev/null
and produces the log
Cycles: 46598940
Gathering step proof: please wait
begin step
  hash a00da7eb
  1: read mcycle@0x120(288): 0x2c70b1c(46598940)
  hash a00da7eb
  2: read iflags.H@0x1d0(464): 0x18(24)
  hash a00da7eb
  3: read iflags.Y@0x1d0(464): 0x18(24)
  hash a00da7eb
  4: read iflags.X (superfluous)@0x1d0(464): 0x18(24)
  hash a00da7eb
  5: write iflags.X@0x1d0(464): 0x18(24) -> 0x18(24)
  begin set_rtc_interrupt
  end set_rtc_interrupt
  begin raise_interrupt_if_any
    hash a00da7eb
    6: read mip@0x170(368): 0x0(0)
    hash a00da7eb
    7: read mie@0x168(360): 0x2aa(682)
  end raise_interrupt_if_any
  begin fetch_insn
    hash a00da7eb
    8: read pc@0x100(256): 0x80002fa0(2147495840)
    begin translate_virtual_address
      hash a00da7eb
      9: read iflags.PRV@0x1d0(464): 0x18(24)
      hash a00da7eb
      10: read mstatus@0x130(304): 0xa00000820(42949675040)
    end translate_virtual_address
    begin find_pma_entry
      hash a00da7eb
      11: read pma.istart@0x800(2048): 0x800000f9(2147483897)
      hash a00da7eb
      12: read pma.ilength@0x808(2056): 0x4000000(67108864)
    end find_pma_entry
    hash a00da7eb
    13: read memory@0x80002fa0(2147495840): 0x7378300f6b023(2031360633384995)
  end fetch_insn
  begin sd
    hash a00da7eb
    14: read x@0x68(104): 0x40008000(1073774592)
    hash a00da7eb
    15: read x@0x78(120): 0x10100000000000a(72339069014638602)
    begin translate_virtual_address
      hash a00da7eb
      16: read iflags.PRV@0x1d0(464): 0x18(24)
      hash a00da7eb
      17: read mstatus@0x130(304): 0xa00000820(42949675040)
    end translate_virtual_address
    begin find_pma_entry
      hash a00da7eb
      18: read pma.istart@0x800(2048): 0x800000f9(2147483897)
      hash a00da7eb
      19: read pma.ilength@0x808(2056): 0x4000000(67108864)
      hash a00da7eb
      20: read pma.istart@0x810(2064): 0x1069(4201)
      hash a00da7eb
      21: read pma.ilength@0x818(2072): 0xf000(61440)
      hash a00da7eb
      22: read pma.istart@0x820(2080): 0x80000000000002d9(9223372036854776537)
      hash a00da7eb
      23: read pma.ilength@0x828(2088): 0x5000000(83886080)
      hash a00da7eb
      24: read pma.istart@0x830(2096): 0x4000841a(1073775642)
      hash a00da7eb
      25: read pma.ilength@0x838(2104): 0x1000(4096)
    end find_pma_entry
    hash a00da7eb
    26: write htif.tohost@0x40008000(1073774592): 0x10100000000000d(72339069014638605) -> 0x10100000000000a(72339069014638602)
    hash 8ebc16f9
    27: read htif.iconsole@0x40008018(1073774616): 0x2(2)
    hash 8ebc16f9
    28: write htif.fromhost@0x40008008(1073774600): 0x0(0) -> 0x101000000000000(72339069014638592)
    hash 7fa4fe27
    29: write pc@0x100(256): 0x80002fa0(2147495840) -> 0x80002fa4(2147495844)
  end sd
  hash bac08fcc
  30: read minstret@0x128(296): 0x2c70aef(46598895)
  hash bac08fcc
  31: write minstret@0x128(296): 0x2c70aef(46598895) -> 0x2c70af0(46598896)
  hash 65519976
  32: read mcycle@0x120(288): 0x2c70b1c(46598940)
  hash 65519976
  33: write mcycle@0x120(288): 0x2c70b1c(46598940) -> 0x2c70b1d(46598941)
end step
Understanding these logs in detail is unnecessary for all but the most low-level internal development at Cartesi.
It requires deep knowledge of not only RISC-V architecture, but also how Cartesi's emulator implements it.
The material is therefore beyond the scope of this document.
This particular example, however, was hand-picked for illustration purposes.
The RISC-V instruction being executed, 
sd
, writes the 64-bit word 
0x010100000000000a
 to address 
0x40008000
 (access
 
#23).
This is the memory-mapped address of HTIF's 
tohost
 CSR.
The value refers to the console subdevice (
DEV=0x01
) , command 
putchar
 (
CMD=0x01
), and causes the device to output a line-feed (
DATA=0x0a
) to the emulator's console.
I.e., the instruction is completing the row 
       \    / CARTESI
 in the splash screen.
The command-line option 
--json-steps=<filename>
 outputs a machine-readable version of the step log 
for each cycle
 executed by the emulator.
It is used by internal integration tests that verify the consistency between the Cartesi Machine as implemented by the off-chain emulator and as implemented by the on-chain step verification function.
Needless to say, even for brief computations, the resulting log files can be 
very
 large.
The 
--rollup
 command-line option sets the 
--htif-yield-automatic
 and 
--htif-yield-manual
 options for the 
/dev/yield
 device.
See the 
target perspective
 for details on automatic and manual yield commands and how they are used by Cartesi Rollups.
The 
--rollup
 option also configures a variety of memory ranges used by the 
/dev/rollup
 device.
There are five memory ranges: 
rollup-rx-buffer
, 
rollup-input-metadata
, 
rollup-tx-buffer
, 
rollup-voucher-hashes
, and 
rollup-notice-hashes
.
The values implied by the 
--rollup
 command-line option are 
--rollup-rx-buffer=start:0x60000000,length:2<<20
, 
--rollup-tx-buffer=start:0x60200000,length:2<<20
, 
--rollup-input-metadata=start:0x60400000,length:4096
, 
--rollup-voucher-hashes=start:0x60600000,length:2<<20
, and 
--rollup-notice-hashes=start:0x60800000,length:2<<20
.
Initialization
Interactive sessions
Flash drives
Persistent flash drives
Limiting execution
Progress feedback
State hashes
Persistent Cartesi Machines
Running as root
Cartesi Machine templates
State value proofs
Remote Cartesi Machines
Rolling Cartesi Machines
Encoding requests
Running a simple target application
Decoding responses
Rolling Cartesi Machine templates
Rarely used options
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 31---










Overview | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
The combination of 
an Optimistic Rollups framework
 and 
the Cartesi Machine Emulator
 enables the development of smart contracts and DApps using any package or library that is available for Linux. This allows developers to break free from the scalability limitations of the Ethereum Virtual Machine (EVM), and brings the rise of a new blockchain era to handle real-life and complex use-cases.
A DApp running on Cartesi Rollups consists of the following main components:
Cartesi Rollups
, a set of on-chain and off-chain components that implement an Optimistic Rollups solution and provide the general framework for building DApps.
Cartesi Machine
, a virtual machine (VM) that runs an entire Linux OS, in which each DApp's 
back-end
 is executed.
DApp Back-end
, the application's state and verifiable logic, which corresponds to the DApp's smart contract. The back-end runs inside the Cartesi Machine as a regular Linux application.
DApp Front-end
, the application's user-facing interface, such as a web app.
The diagram below shows the overall architecture:

note
You can 
run a simple DApp
 that we already built using Python
What is a blockchain rollup?
​
A rollup is a blockchain scalability solution that pushes complex computations "off-chain", meaning that they run on a separate computing environment (layer-2) outside of the main network (layer 1, such as the Ethereum network). When employing rollups, the blockchain's role becomes solely to receive transactions and log them. On rare occasions in which parties disagree with the outcomes of a computation, the blockchain also gets involved in resolving these disputes.
Offloading the blockchain from complex computations along with aggregating and compressing data is expected to increase the number of transactions a blockchain can process by a factor of at least 40x. Additionally, transactions can now involve much more complex logic since applications running in a rollup are able to perform virtually any computation and can also take advantage of more powerful virtual machines (VMs) running on layer-2.
How does a rollup work?
​
Users interact with a rollup through transactions on the base layer (layer 1). They send messages (inputs) to the rollup on-chain smart contracts to define a computation to be processed, and as such advance the state of the computing environment on layer-2. Interested parties run an off-chain component (a layer-2 node) that watches the blockchain for inputs, understanding and executing the state updates.
Once in a while, the state of the machine is checkpointed on-chain, at which point the state is considered to be 
finalized
 and can thus be accepted by any smart contract on layer 1. It is of course vital to ensure this operation is secure, meaning that the layer-2 node needs to somehow 
prove
 the new state to the base layer.
Let’s think about this question:

"How does a blockchain system, such as Ethereum, know that the data posted by an off-chain layer-2 node is valid and was not submitted in a malicious way?"
The answer depends on the rollup implementation, which basically falls within one of two categories according to the type of proof used:
Zero-knowledge Rollups (ZK Rollups)
, which use validity proofs
Optimistic Rollups (ORs)
, which use fraud proofs
In validity proof schemes, every state update comes accompanied by a cryptographic proof, created off-chain, attesting its validity. The update is only accepted if the proof successfully passes verification on-chain. 
Zero-knowledge proofs
 are frequently used for this, which is why these types of rollups are usually referred to as ZK Rollups. Validity proofs bring the big benefit of instant finality — as soon as a state update appears on-chain, they can be fully trusted and acted upon. The choice, however, also brings less than ideal properties: generating ZK proofs for general-purpose computations is, when possible, immensely expensive and each on-chain state update must pay the extra gas fee from including and verifying a validity proof.
Fraud-proof schemes work by a different paradigm. State updates come unaccompanied by proofs, they’re proposed and, if not challenged, confirmed on-chain. Challenging a state update proposal is done by the use of fraud proofs, which can be divided into two categories: non-interactive fraud proofs and interactive fraud proofs.
Non-interactive refers to the fact that the challengers can prove that a state update is invalid in one single step. With interactive fraud proofs, the claimer and challenger have to, mediated by the blockchain, partake in something similar to a verification game. The assumption that state updates will most likely be honest often gives solutions like this the name of Optimistic Rollups. Naturally, this optimism comes paired up with financial incentives for honest behavior and guarantees that, unless the proposed false state is undisputed for a significant amount of time, it will never get accepted.
Summary of a rollup solution
Executes transaction computations off-chain. This way the computations are not carried out by the base layer. Instead, they are executed in a separate computation environment and the rollup protocol ensures transaction validity via either validity proofs or fraud proofs.
Capable of compressing data from several transactions into a bundle to decrease both transaction costs and size, increasing overall efficiency.
Allows blockchains to scale while keeping the security guarantees of its consensus mechanism.
Cartesi Rollups
​
Cartesi’s version of Optimistic Rollups
 uses interactive fraud proofs. The model was chosen because it imposes a higher ceiling to the size of computations that can be executed. In other words, with this model the blockchain base layer is never responsible for executing entire computations: either there are no disputes and no computation takes place there, or, if a dispute occurs, it only needs to compute a single instruction to distinguish between misbehavior and honesty. In either case, the results themselves are always computed off-chain, and as a consequence the computation involved can be massive.
In the next sections, we will first describe 
Cartesi Rollups' internal components
 and how they work. Then, we will explain in detail the 
architecture of DApps
 that run on our rollups framework, as well as the 
APIs that developers can use
 to communicate with it. Finally, we share our vision of a 
step-by-step process for developing applications
 on Cartesi Rollups, from the initial design stage up to its final deployment.
note
You can read the article 
Everything you need to know about Optimistic Rollup
 to get more information about optimistic rollups in general.
note
You can read the article 
Fraud proofs and virtual machines
 or go into more details 
here
See Also
​
Blockchain For Beginners #1 - Smart Contracts With Ethereum & Solidity
What is a blockchain rollup?
How does a rollup work?
Cartesi Rollups
See Also
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 32---










Components | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
As explained in the 
previous section
, the Cartesi Rollups framework achieves scalability by moving the bulk of the computation outside the blockchain, using the ledger as a data source but not as an execution environment. As such, the solution contains both on-chain (layer-1) and off-chain (layer-2) components.
note
In this section, we describe the internal components of the Cartesi Rollups framework in more detail, to clarify how the system works inside. DApp developers may chose to skip directly to the 
DApp architecture
 section to understand how to build applications.
Main concepts
​
Cartesi Nodes
​
As explained before, 
Cartesi Machines
 provide DApp developers with an environment in which large scale verifiable computations can be executed. These machines are integrated with the on-chain smart contracts by a 
middleware
 that manages and controls the communication between them. As such, this middleware is responsible for first reading data from the layer-1 smart contracts, then sending them to the machine to be processed, and finally publishing their results back to the blockchain.
The 
Cartesi Node
 is the layer-2 component that consists of the combination of the Cartesi Machine and this middleware, and can be used by anyone interested in the rollups state of affairs. Put simply, Cartesi Nodes play a role that is similar to what Geth does on the Ethereum ecosystem: execution and retrieval of information.
In practice, there are two distinct kinds of agents that run Cartesi Nodes: 
users
 and 
validators
. Each of them interacts with the on-chain rollups in different ways, and thus run different types of Cartesi Nodes:
User or Reader Nodes
, which are only involved in advancing the state of the off-chain machine, and making that state publicly available. They consume information from the blockchain but do not bother to enforce state updates, trusting that validators will ensure the validity of all on-chain state updates.
Validator Nodes
, which have more responsibility: they not only watch the blockchain but also fight possible dishonest validators to ensure the prevalence of honest claims for state updates. On the other hand, if Reader Nodes are available, validators do not need to expose endpoints for retrieving application state. Therefore, they can run in more secure environments and remain inaccessible to external clients and users.
Epochs
​
In order to avoid over interacting with the blockchain, validators don't checkpoint every new state update on the off-chain machine. They do it at the end of an 
epoch
, which are batched inputs that follow the same cycle.
We can imagine epochs in three different states:
Accumulating
, when the epoch is open and waiting for inputs.
Sealed
, when the inputs for that epoch are well defined and the validators are preparing to send their claims. Sealed epochs can also be under dispute.
Finalized
, when consensus was reached and the outputs can be safely executed.
The on-chain state, depending on what phase it is, can contain one or two epochs, as illustrated by the diagram below.
Input Accumulation
: there is a single accumulating epoch, active and waiting for the inputs it is going to batch.
Awaiting Consensus
: there are two epochs. A sealed one, for which validators are preparing to or sending their claims, and an accumulating one, which is active and receiving inputs.
Awaiting Dispute
: there are also two epochs. A sealed one and an accumulating one. The sealed epoch is under dispute. At least two conflicting claims were received and the validators are enrolling in a verification game to decide which claim stands. Since the sealed epoch's inputs are well defined, honest validators will always reach the same claim. A dispute necessarily means that a claim is provably false.
To better understand the whole process on a timeline, let's describe how the system schedules different rollups phases.
On a given epoch N, the involved validator nodes batch all the input messages that were enqueued on-chain from the beginning of the previous 
epoch’s processing
 slot until the beginning of the current epoch’s 
processing slot
.
The nodes then process every message of the batch through the Cartesi Machine, producing an output hash that summarizes the state transition of the entire epoch. Then, one of the validators, henceforth called 
claimer
, places on-chain the hash representing the layer-2 contract state at the end of epoch N, 
S(N)
.
After a challenge period is over, if there was no dispute, 
S(N)
 is assumed final by the system. Otherwise, disputes will follow until the correct state claim represented by its output hash is enforced. The 
settlement period
 displayed on the diagram above accounts for a 
challenge period
, with or without disputes.
To guarantee a minimum duration for each epoch, the rollups protocol also requires an 
accumulation slot
. This is a minimal latency imposed on on-chain finalization to prevent frequent claims being sent to layer-1, for the sake of Ethereum fee cost-effectiveness. The rollup developer can configure a specific accumulation slot period for their application to accommodate eventual specific requirements for balancing latency to finality and security.
Vouchers
​
A 
voucher
 is a combination of a target address and a payload in bytes. It is used by the off-chain machine to respond and interact with layer-1 smart contracts. Upon execution, a voucher sends a message to the target address with the payload as a parameter. Vouchers can be used for anything, ranging from providing liquidity in a DeFi protocol to withdrawing funds from the 
Portal
. Vouchers can only be executed when the epoch in which they are contained is 
finalized
, at which point a 
validity proof
 will be available to ensure layer-1 smart contracts can trust its content.
Notices
​
A 
notice
 is an arbitrary payload in bytes that is submitted by the off-chain machine for informational purposes. Similarly to vouchers, when the epoch containing a notice is finalized a proof will be produced so that the validity of the notice's content can be verified on-chain by any interested party.
Reports
​
A 
report
 is an application log or a piece of diagnostic information. Like a notice, it is represented by an arbitrary payload in bytes. However, a report is never associated with a proof and is thus not suitable for trustless interactions such as on-chain processing or convincing independent third parties of DApp outcomes. Reports are commonly used to indicate processing errors or to retrieve application information for display.
On-chain components
​
These consist of the Cartesi Rollups smart contracts that were designed to mediate the relationship of the off-chain components with other smart contracts and externally owned accounts. They include several modules, each with clear responsibilities and well-defined interfaces.
Cartesi Rollups Manager
​
The 
Cartesi Rollups Manager
 is responsible for synchronicity between the modules. It defines the duration of the different phases and notifies the other modules of any phase change. Among others, the responsibilities of this module are:
Define to which epoch an input is destined, depending on the current state and deadlines.
Receive and forward claims to the Validator Manager.
Forward disputes to the Dispute Resolution module.
Forward the result of disputes to the Validator Manager.
Forward the summary of finalized outputs (vouchers and notices) to the Output module.
Notify other modules of phase changes.
Input contract
​
As discussed above, the on-chain contracts often have two concurrent epochs: a sealed but unfinalized epoch, and an accumulating one. The 
Input contract
 keeps one inbox for each of those epochs, switching between them depending on the Cartesi Rollups Manager's notifications.
For anyone to be able to synchronize the machine from its beginning without needing to trust a data provider, the full content of inputs is always present in calldata on the blockchain. In on-chain storage, which needs to be used in a more parsimonious way, we keep a single hash for each input of an active epoch.
This input hash summarizes both the input itself and its metadata, which corresponds to the sender's address and the time of reception. Notice that this input implementation is permissionless: the permission layer is delegated to the off-chain machine which will, for example, judge if a sender is allowed to do what their input wants to do.
Output contract
​
Each input can generate a number of notices and vouchers that will have an accompanying 
validity proof
 available once the epoch containing them is finalized. These proofs can be used with the 
Output contract
 to execute vouchers or verify the validity of a notice's content.
For vouchers, while the Output contract is indifferent to their content, it does enforce some sanity checks before allowing their execution, since vouchers are unique and can only be successfully executed once. Vouchers are executed asynchronously and don't require an access check, and the order of execution is not enforced. As long as vouchers are contained in a finalized epoch and were not executed before, the contract will allow their execution by anyone.
Portal
​
The Portal, as the name suggests, is used to teleport assets from the Ethereum blockchain to DApps running on Cartesi Rollups. Once deposited, those layer-1 assets gain a representation in layer-2 and are owned, there, by whomever the depositor assigned them to. After being teleported, layer-2 assets can be moved around in a significantly cheaper way, using simple inputs that are understood by the Linux logic.
When an asset is deposited, the Portal contract sends an input to the DApp’s inbox, describing the type of asset, amount, receivers, and some data the depositor might want the DApp to read. This allows deposits and instructions to be sent as a single layer-1 interaction. One could think of the Portal as a bank account, owned by the off-chain machine.
Anyone can deposit assets there but only the DApp — through its Output contract — can decide on withdrawals. The withdrawal process is quite simple from a user perspective. They send an input requesting a withdrawal, which gets processed and interpreted off-chain. If everything is correct, the machine creates a voucher destined to the Portal contract, ordering and finalizing that withdrawal request. Currently, we support the following types of assets:
Ether (ETH)
ERC-20
ERC-721 (NFTs)
Validator Manager
​
The 
Validator Manager
 module was created to help DApps manage their claims, claim permissions, and punishments for bad behavior. Initially, our suggested implementation for this module includes the following characteristics: the set of payable validators is defined in construction time, validators send a claim for every epoch and those that lose a dispute are kicked off the validators set.
The 
Cartesi Rollups Manager
 receives claims and redirects them to the Validator Manager. When receiving a claim, the Validator Manager checks which other claims have arrived at that epoch and returns the information that Cartesi Rollups Manager needs to continue. The module can respond to received claims in one of the following ways:
If the sender is not a validator or the claim is invalid, the transaction reverts.
If the claim is valid, doesn’t disagree with any of the other claims in the epoch, and does not generate consensus, it returns a "No Conflict" response.
If the claim is valid but disagrees with another claim for that epoch, it warns the Cartesi Rollups Manager that a conflict is happening and what are the conflicting claims and claimants involved. When that dispute is resolved the Validator Manager module gets notified so it can deal however it likes with the validators involved. In our initially suggested implementation, the loser of a dispute is removed from the validator set.
If the claim is valid, agrees with all other claims in that epoch, and is the last claim to be received, it lets Cartesi Rollups know that consensus was reached. This allows the rollups DApp to finalize the epoch and allow for the execution of its vouchers. Regardless of what the name might suggest, validators do not interact with this module at all.
Fee Manager and Bank
​
The 
Fee Manager facet
 and 
Bank contract
 aim to create an economical incentive for validators to run a given DApp. When you develop an application, you will need to define two parameters:
A fee to be paid to the validators each time they submit a claim. This fee will be debited from the funds stored in the DApp's Bank contract.
An owner for the Fee Manager facet, who has the option to change the fee value, if needed.
Entities running validator nodes should configure them to either be 
altruistic
 or require a minimum retainer (i.e., a minimum fee to process inputs for the DApp). If they are altruistic, they will work regardless of any financial compensation. On the other hand, non-altruistic validators must ensure that the following two conditions are met before processing inputs and submitting claims:
The fee paid by the DApp must be bigger than their required retainer
The DApp's Bank must have enough funds to pay the validator
The fee value is given in CTSI and is reserved for a validator every time a claim is made. The validator is free to withdraw received CTSI fees at any time of its convenience. While the Fee Manager controls the fee value and the amount of claims made by each validator, the Bank stores - on a separate contract - the CTSI tokens that will be distributed to them.
The code does not enforce a way for the Bank to be funded. Therefore, DApps and communities are free to choose their preferred procedures, such as direct transfer, charging per input, creating a tax system on top of the Portal, or other methods. For convenience, a 
FundBank
 hardhat task is provided which transfers money from the signer to a DApp's Bank.
Dispute Resolution
​
Disputes occur when two validators claim different state updates to the same epoch. Because of the deterministic nature of our virtual machine and the fact that the inputs that constitute an epoch are agreed upon beforehand, conflicting claims imply dishonest behavior. When a conflict occurs, the module that mediates the interactions between both validators is the Dispute Resolution contract.
The code for rollups dispute resolution is not being published yet - but a big part of it is available on the Cartesi Rollups SDK, using the 
Arbitration dlib
.
Off-chain components
​
These consist of the internal modules of the 
Cartesi Node
. As explained before, Cartesi Nodes form the network that sustains the Cartesi Rollups solution, being responsible for executing the computations that arrive and presenting their results to the interested parties.
State Server
​
This service is responsible for ensuring that the remaining modules have access to a consistent view of the state of the blockchain. The service is an instance of  Cartesi's 
State Fold tool
 and monitors all relevant activity from the Cartesi Rollups smart contracts, consolidating the information that gets emitted by the blockchain.
Rollups Dispatcher
​
Responsible for interpreting the current state of the Cartesi Rollups smart contracts, this module informs the 
Server Manager
 about any incoming inputs and, in the case of Validator Nodes, also submits transactions to layer-1 corresponding to state update claims. It will also handle any disputes should they arise.
Server Manager
​
This module manages the Cartesi Machine, sending inputs to it and reading the produced outputs. It is responsible for starting and stopping the machine as appropriate, as well as providing an API for the other modules to query the machine's state.
The 
Host Server Manager
 is an alternative implementation of the Server Manager for development purposes. It implements the same API and mimics the behavior of an actual Server Manager, but does not in fact instantiate a Cartesi Machine. Instead, it makes HTTP requests directly to a DApp running in the host computer. The Host Server Manager is intended to be used in the 
implementation stage of the DApp life cycle
.
Rollups Indexer
​
This service is responsible for consolidating the state of the Cartesi Node. It queries blockchain information from the 
State Server
 as well as data produced by the DApp back-end through the 
Server Manager
, consolidating everything in a local database.
Query Server
​
Module that provides an externally accessible 
GraphQL API
 for querying the consolidated state of the Cartesi Node, as maintained by the 
Rollups Indexer
. This allows users and client applications to retrieve vouchers, notices and reports produced by the DApp back-end.
Main concepts
Cartesi Nodes
Epochs
Vouchers
Notices
Reports
On-chain components
Cartesi Rollups Manager
Input contract
Output contract
Portal
Validator Manager
Fee Manager and Bank
Dispute Resolution
Off-chain components
State Server
Rollups Dispatcher
Server Manager
Rollups Indexer
Query Server
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 33---










DApp architecture | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Borrowing from familiar mainstream terminology, from a developer’s point of view a Cartesi DApp is developed by implementing two main components: a 
front-end
 and a 
back-end
.
Here, the yellow boxes represent the parts that the developer needs to implement to build a DApp, which are discussed in more detail below. On the other hand, the parts in blue correspond to the general Rollups framework provided by Cartesi. This framework includes both the underlying layer-1 blockchain, with Cartesi Rollups smart contracts deployed, and the layer-2 off-chain nodes.
Back-end
​
The back-end of a Cartesi DApp contains the business logic of the application, similar to what traditional systems would run inside a server. The difference here — and the reason for using blockchain technology in general — is that decentralized applications need this back-end logic to be verifiable and hence trustless. As such, it is executed inside the Cartesi Rollups framework.
The back-end stores and updates the application state as user input is received and produces corresponding outputs. These outputs can come in the form of 
vouchers
 (transactions that can be carried out on layer-1, such as a transfer of assets), 
notices
 (informational statements, such as the resulting score of a game), or 
reports
 (application logs and diagnostic information, such as error or warning messages).
In practical terms, a Cartesi DApp back-end can be seen as a smart contract, but on steroids.
Front-end
​
The front-end of a Cartesi DApp corresponds to the user-facing interface, which will often provide a GUI (e.g., a web application) but may also be just a command-line interface, such as a Hardhat task using ethers.js, or a command-line tool written in Python.
The front-end's job is usually to collect user input and submit it to the DApp, as well as to query and show the DApp's state.
Communication
​
When compared to traditional software development, the main difference of a Cartesi DApp is that the back-end is deployed to a decentralized network of layer-2 nodes, which continuously verify the correctness of all processing results. As a consequence, the front-end and back-end do not communicate directly with each other. Rather, the front-end sends inputs to the Cartesi Rollups framework, which in turn makes them available to the back-end instances running inside each node. After the inputs are processed by the back-end logic, the corresponding outputs are then informed back to the Rollups framework, which enforces their correctness and makes them available to the front-end and any other interested parties.
The sequence diagram below illustrates how all of this works:
note
The Cartesi Rollups framework provides a set of APIs to specify how the DApp's front-end and back-end should communicate with it. These APIs are explained in detail in the 
next section
.
Other components
​
Aside from the back-end running inside the Cartesi Rollups infrastructure, the DApp front-end may also use external resources such as third-party services. Indeed, for more complex DApps it is expected that there will be other back-ends besides the one running verifiable logic. They would be used whenever the application doesn’t need a service to be decentralized and trustless, such as providing fast and accessible data caches, helping users communicate with each other, or interfacing with other non-blockchain services.
Conversely, it is also possible for complex DApps to provide more than one front-end application, with the goal of supporting different kinds of users and use cases.
Back-end
Front-end
Communication
Other components
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 34---










Introduction | Blockchain OS Documentation - Cartesi
























Skip to main content
This section describes Cartesi Machines from the perspective of the blockchain.
Using the Cartesi platform, smart contracts gain a new ability.
They can get their users to agree on the results of computations that cannot be performed natively as smart contracts: computations that either involve too much data, are too computationally demanding, or require a sophisticated software infrastructure that is simply not available for use on-chain.
Users that have a stake in a given computation are represented off-chain by Cartesi Nodes under their control.
Cartesi Nodes react to Cartesi-enabled smart contracts and instantiate Cartesi Machines to perform the required computations and post the result back to the blockchain.
Since Cartesi Machines are self-contained and reproducible, the results of off-chain computations performed by honest users will agree.
The smart contract can then make decisions of consequence that depend on these results.
When the Cartesi Node representing an honest user identifies an incorrect result posted by a dishonest user, it disputes the result.
The opposing Cartesi Nodes then engage in an automatic dispute resolution protocol presided by the blockchain, which results in the dishonest user being proven wrong.
The smart contract that commanded the computation can then punish the dishonest user and reward the honest one.
The Cartesi Machine emulator is one of a kind.
It doesn't simply emulate the RISC-V ISA to the extent that it can boot a performant operating system based on Linux.
It does so in a way that allows smart contracts to specify computations, replace their inputs, inspect their outputs, and direct the dispute resolution protocol.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 35---










Linux environment | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
note
The host perspective
 section describes in detail the 
cartesi-machine
 command-line utility and the general structure of Cartesi Machines.
In order to avoid repetition, this section assumes familiarity with the material presented there.
The most direct way for target developers to familiarize themselves with the embedded Linux environment is to run the Cartesi Machine emulator in interactive mode.
The 
cartesi/playground
 Docker image comes pre-installed with the emulator and all its support files.
Inside the playground, the following command instructs the emulator to load the default machine configuration and run a shell in interactive mode
cartesi-machine -i -- 
sh
Once executed, the Cartesi Machine boots Linux and drops into an interactive shell (The 
sh
 argument in the command-line.)
Running in interactive mode!
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
cartesi-machine:~ # cd /bin
cartesi-machine:/bin # ls
arch           dmesg          linux64        nuke           stty
ash            dnsdomainname  ln             pidof          su
base32         dumpkmap       login          ping           sync
base64         echo           ls             pipe_progress  tar
busybox        egrep          lsattr         printenv       touch
cat            false          lsblk          ps             true
chattr         fdflush        mk_cmds        pwd            umount
chgrp          fgrep          mkdir          resume         uname
chmod          findmnt        mknod          rm             usleep
chown          getopt         mktemp         rmdir          vi
compile_et     grep           more           run-parts      watch
cp             gunzip         mount          sed            wdctl
cpio           gzip           mountpoint     setarch        zcat
cttyhack       hostname       mt             setpriv
date           kill           mv             setserial
dd             link           netstat        sh
df             linux32        nice           sleep
cartesi-machine:/bin # cd /usr/bin
cartesi-machine:/usr/bin # ls
7zr                fdtget             lzcat              sqlite3
[                  fdtoverlay         lzcmp              strace
[[                 fdtput             lzdiff             strace-log-merge
ar                 filecap            lzegrep            strings
ascii              fileop             lzfgrep            svc
attr               fincore            lzgrep             svok
awk                find               lzip               tail
basename           flask              lzless             taskset
bc                 flock              lzma               tee
brotli             fold               lzmadec            telnet
bunzip2            free               lzmainfo           test
bzcat              fuser              lzmore             tftp
bzcmp              genext2fs          lzop               time
bzdiff             getfacl            lzopcat            tinymembench
bzegrep            getfattr           make               tjs
bzfgrep            getopt             mcookie            top
bzgrep             gpg                md5sum             tr
bzip2              gpg-agent          mesg               traceroute
bzip2recover       gpg-connect-agent  microcom           truncate
bzless             gpg-error          mkfifo             ts
bzmore             gpg-wks-server     mkpasswd           tty
captest            gpgconf            mpicalc            uclampset
ccat               gpgparsemail       namei              ul
ccdecrypt          gpgrt-config       netcap             uname26
ccencrypt          gpgscm             newgrp             uniq
ccguess            gpgsm              nl                 unix2dos
ccrypt             gpgsplit           nohup              unlink
chacl              gpgtar             normalizer         unlzma
chardetect         gsl-histogram      nproc              unlzop
choom              gsl-randist        npth-config        unrar
chrt               gunicorn           nsenter            unshare
chvt               head               nslookup           unxz
cksum              hexdump            od                 unzip
clear              hexedit            openvt             uptime
cmp                hmac256            passwd             utmpdump
col                hostid             paste              uudecode
colcrt             id                 patch              uuencode
colrm              install            printf             uuidgen
column             ionice             prlimit            uuidparse
convert-dtsv0      iozone             pscap              vlock
crc32              ipcmk              python             w
crontab            ipcrm              python3            wall
cut                ipcs               python3.10         watchgnupg
dc                 irqtop             ramspeed           wc
deallocvt          isosize            readlink           wget
devio              jq                 realpath           whereis
dhrystone          kbxutil            rename             whetstone
dieharder          killall            renice             which
diff               ksba-config        reset              who
dirmngr            last               resize             whoami
dirmngr-client     lastb              rev                write
dirname            ldd                script             xargs
dos2unix           less               scriptlive         xxd
dtc                line               scriptreplay       xz
du                 linux32            seq                xzcat
dumpsexp           linux64            setarch            xzcmp
e2cp               logger             setfacl            xzdec
e2ln               logname            setfattr           xzdiff
e2ls               look               setkeycodes        xzegrep
e2mkdir            lscpu              setpriv            xzfgrep
e2mv               lsipc              setsid             xzgrep
e2rm               lsirq              setterm            xzless
e2tail             lslocks            sha1sum            xzmore
eject              lsns               sha256sum          yes
em                 lsof               sha3sum            zip
env                lspci              sha512sum          zipcloak
expr               lsscsi             shred              zipnote
factor             lsusb              sl                 zipsplit
fallocate          lua                smtpd.py.10
fdtdump            luac               sort
cartesi-machine:/usr/bin # exit
Halted
Cycles: 194206795
The session shows a user changing the working directory to 
/bin/
 and listing its contents.
The user then does the same with directory 
/usr/bin/
, before finally leaving the emulator with the 
exit
 command.
The point of the exercise is that, from the inside, the environment will be familiar to any regular Unix user.
One of the key differences is that, unlike stand-alone systems, most embedded systems are not self-hosting.
None of the utilities visible inside the 
/usr/bin/
 and 
/bin/
 directories were built with a compiler that ran inside a Cartesi Machine.
They were built in a separate host system, on which a cross-compiling toolchain for the target architecture has been installed.
In the case of Linux, the key elements in the toolchain are the GNU Compiler Collection and the GNU C Library.
Support for RISC-V is upstream in the official 
GCC compiler collection
.
Nevertheless, building a cross-compiler is time-consuming, even with the help of specialized tools such as 
crosstool-ng
.
The 
Emulator SDK
 includes a Docker image 
cartesi/toolchain
 with the toolchain pre-installed.
The same toolchain is available in the 
cartesi/playground
 Docker image.
Target "Hello world!"
​
Other than using a cross-compiler in the host to create executables for a different target platform, cross-development is not that different from hosted development.
As an example, consider the simple task of compiling the ubiquitous 
“
Hello world!
”
 program in the C++ programming language to run in the target.
(Printing 5 lines, to at least offer a taste of the programming language.)
hello.cpp
#include <iostream>
int main(int argc, char *argv[]) {
    for (int i = 0; i < 5; i++) {
        std::cout << i+1 << ": Hello world from C++!\n";
    }
    return 0;
}
To produce the binary in the playground, run
riscv64-cartesi-linux-gnu-g++ -O2 -o hello-cpp hello.cpp
Note the prefix 
riscv64-cartesi-linux-gnu-
 to the typical 
g++
 command.
This prefix identifies the cross-compiler.
The resulting file is a RISC-V executable suitable for running on the target.
This can be see by running the command
file
 hello-cpp
which produces
hello-cpp: ELF 64-bit LSB executable, UCB RISC-V, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-riscv64-lp64.so.1, for GNU/Linux 5.5.19, with debug_info, not stripped
If the bare 
gcc
 command was used instead, the resulting binary would be suitable for running on the host.
The executable can now be placed inside a new 
hello.ext2
 file-system:
mkdir
 hello
cp
 hello-cpp hello
genext2fs -b 
1024
 -d hello hello.ext2
The 
hello-cpp
 program can then be run from using the 
cartesi-machine
 command-line utility as follows:
cartesi-machine 
\
    --flash-drive
=
label:hello,filename:hello.ext2 
\
    -- /mnt/hello/hello-cpp
The output is
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
1: Hello world from C++!
2: Hello world from C++!
3: Hello world from C++!
4: Hello world from C++!
5: Hello world from C++!
Halted
Cycles: 76503434
To create the 
“
Hello world!
”
 program in Rust, first create a Cargo project:
cargo new hello-rust
Then, edit the 
hello-rust/src/main.rs
 file so it contains our modified program:
main.rs
fn main() {
    for i in 1..6 {
        println!("{}: Hello world from Rust!", i);
    }
}
Cross-compiling in Rust requires an additional configuration step.
To that end, create a file with the following JSON object:
riscv64ima-cartesi-linux-gnu.json
{
    
"arch"
:
 
"riscv64"
,
    
"code-model"
:
 
"medium"
,
    
"cpu"
:
 
"generic-rv64"
,
    
"crt-static-respected"
:
 
true
,
    
"data-layout"
:
 
"e-m:e-p:64:64-i64:64-i128:128-n64-S128"
,
    
"dynamic-linking"
:
 
true
,
    
"env"
:
 
"gnu"
,
    
"executables"
:
 
true
,
    
"features"
:
 
"+m,+a"
,
    
"has-rpath"
:
 
true
,
    
"is-builtin"
:
 
false
,
    
"llvm-abiname"
:
 
"lp64"
,
    
"llvm-target"
:
 
"riscv64"
,
    
"max-atomic-width"
:
 
64
,
    
"os"
:
 
"linux"
,
    
"position-independent-executables"
:
 
true
,
    
"relro-level"
:
 
"full"
,
    
"target-family"
:
 
[
      
"unix"
    
]
,
    
"linker-flavor"
:
 
"gcc"
,
    
"linker"
:
 
"riscv64-cartesi-linux-gnu-gcc"
,
    
"pre-link-args"
:
 
{
        
"gcc"
:
 
[
]
    
}
,
    
"post-link-args"
:
 
{
        
"gcc"
:
 
[
            
"-Wl,--allow-multiple-definition"
,
            
"-Wl,--start-group,-lc,-lm,-lgcc,-lstdc++,-lsupc++,--end-group"
        
]
    
}
,
    
"target-pointer-width"
:
 
"64"
,
    
"panic-strategy"
:
 
"abort"
}
Now invoke Cargo with with the following command-line:
cargo build -Z build-std
=
std,core,alloc,panic_abort,proc_macro --target riscv64ima-cartesi-linux-gnu.json --release
The compiled program should appear in 
hello-rust/target/riscv64ima-cartesi-linux-gnu/release/hello-rust
.
One of the advantages of running Linux is the large number of well-established software development tools available.
By default, the 
rootfs.ext2
 root file-system includes the 
ash
 shell, and a Lua interpreter, both of which can be used for scripting.
For example, to run the shell script version of the 
“
Hello world!
”
 program:
hello.sh
#!/bin/sh
for
 
i
 
in
 
$(
seq
 
1
 
5
)
;
 
do
    
echo
 
"
$i
: Hello world from sh!"
done
cp
 hello.sh hello
chmod
 +x hello/hello.sh
genext2fs -b 
1024
 -d hello hello.ext2
cartesi-machine 
\
    --flash-drive
=
label:hello,filename:hello.ext2 
\
    -- /mnt/hello/hello.sh
Running these commands produce an output that is very similar to the C++ version.
The root file-system
​
The 
fs/
 submodule in the 
Emulator SDK
 uses the 
Buildroot
 tool to create the root file-system 
rootfs.ext2
 (mounted as 
/
).
Buildroot is a highly configurable tool, and an explanation of how to use it to its full potential is beyond the scope of this documentation.
Please refer to its 
manual
.
Even relative to other embedded Linux root file-systems, the Cartesi-provided 
rootfs.ext2
 is very simple.
The only significant customization is the Cartesi-provided 
/sbin/init
 script, which performs a few initialization tasks before handing control to the application chosen by the developer to run inside the Cartesi Machine, and finally shuts down after the application exits.
As is typical in the field, 
rootfs.ext2
 uses 
BusyBox
 to consolidate tiny versions of many common UNIX utilities (
ls
, 
cd
, 
rm
, etc) into a single binary.
It also includes a variety of typical command-line utilities, as can be seen in the listings of directories 
/bin/
 and 
/usr/bin/
 above.
Using Buildroot, it is rather easy to add new packages, or to remove unnecessary ones.
Hundreds of packages are available for installation.
To that end, from inside the Emulator SDK, change into the 
fs/
 directory and run 
make config
.
This will bring up a textual menu interface, from which the option 
Target packages
 can be selected.
For example, additional scripting languages are available from the 
Interpreter languages and scripting
 section.
After selecting the options for 
4th
, 
lua
, 
qjs
, 
perl
, 
php
, 
python3
, 
ruby
, and 
tcl
 and replacing the old 
rootfs.ext2
 with the freshly generated one, all these scripting languages become available for use inside the Cartesi Machine.
Here are 
“
Hello world!
”
 programs for each of these languages:
hello.4th
6 1 do i <# # #> type ." : Hello world from Forth!" cr loop
hello.js
#!/usr/bin/env qjs
for
 
(
var
 i 
=
 
1
;
 i 
<=
 
5
;
 i
++
)
 
{
    
console
.
log
(
i 
+
 
": Hello world from JavaScript!"
)
}
hello.lua
#!/usr/bin/env lua
for
 i 
=
 
1
,
 
5
 
do
    
print
(
i 
..
 
": Hello world from Lua!"
)
end
hello.pl
#!/usr/bin/env perl
for my $i (1..5){
    print("$i: Hello from Perl!\n");
}
hello.php
#!/usr/bin/env php
<?php
for ($i = 1; $i <= 5; $i++) {
    print "$i: Hello world from PHP!\n";
}
?>
hello.py
#!/usr/bin/env python3
for
 i 
in
 
range
(
1
,
6
)
:
    
print
(
"{}: Hello world from Python3"
.
format
(
i
)
)
hello.rb
#!/usr/bin/env ruby
for i in 1..5 do
    puts "%d: Hello world from Ruby!" % i
end
hello.tcl
#!/usr/bin/env tclsh
for {set i 1} {$i <= 5} {incr i} {
    puts "$i: Hello world from TCL!"
}
The following shell script invokes all of them:
all.sh
#!/bin/sh
cd
 
$(
dirname
 $0
)
./hello-cpp
./hello-rust
4th cxq hello.4th
./hello.lua
./hello.js
./hello.pl
./hello.php
./hello.py
./hello.rb
./hello.sh
./hello.tcl
After adding all these files to 
hello.ext2
 (with 
execute
 permissions), the result of the command line
cartesi-machine 
\
    --flash-drive
=
label:hello,filename:hello.ext2 
\
    -- 
"/mnt/hello/all.sh"
is as follows:
         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '
1: Hello world from C++!
2: Hello world from C++!
3: Hello world from C++!
4: Hello world from C++!
5: Hello world from C++!
1: Hello world from Rust!
2: Hello world from Rust!
3: Hello world from Rust!
4: Hello world from Rust!
5: Hello world from Rust!
1: Hello world from Forth!
2: Hello world from Forth!
3: Hello world from Forth!
4: Hello world from Forth!
5: Hello world from Forth!
1: Hello world from Lua!
2: Hello world from Lua!
3: Hello world from Lua!
4: Hello world from Lua!
5: Hello world from Lua!
1: Hello world from JavaScript!
2: Hello world from JavaScript!
3: Hello world from JavaScript!
4: Hello world from JavaScript!
5: Hello world from JavaScript!
1: Hello world from Perl!
2: Hello world from Perl!
3: Hello world from Perl!
4: Hello world from Perl!
5: Hello world from Perl!
1: Hello world from PHP!
2: Hello world from PHP!
3: Hello world from PHP!
4: Hello world from PHP!
5: Hello world from PHP!
1: Hello world from Python3
2: Hello world from Python3
3: Hello world from Python3
4: Hello world from Python3
5: Hello world from Python3
1: Hello world from Ruby!
2: Hello world from Ruby!
3: Hello world from Ruby!
4: Hello world from Ruby!
5: Hello world from Ruby!
1: Hello world from sh!
2: Hello world from sh!
3: Hello world from sh!
4: Hello world from sh!
5: Hello world from sh!
1: Hello world from TCL!
2: Hello world from TCL!
3: Hello world from TCL!
4: Hello world from TCL!
5: Hello world from TCL!
Halted
Cycles: 205939605
The take-away message is that developers can use the tools they are most familiar with to accomplish the task at hand.
note
Note that your cycle count may vary, since your new 
rootfs.ext2
 may differ from the one used to produce the results above.
note
As of version 0.4.0 of the 
rootfs.ext2
, the Ruby interpreter does not compile.
We are working on a fix.
Flash drives
​
Flash drives are simply regions of physical memory under the control of Linux's 
mtd-ram
 driver.
The flash drives 0
–
7 receive device names 
flash.0
–
flash.7
, and the driver makes them accessible as block devices 
/dev/mtdblock0
–
/dev/mtdblock7
.
The kernel command-line parameters 
rootfstype=ext2 root=/dev/mtdblock0 rw
 declare that the root file-system is of type 
ext2
, that it resides in device 
/dev/mtdblock0
, i.e., flash drive 0, and that it should be mounted read-write.
Partitioning information for flash drives and, in particular, custom labels can be specified with the 
mtdparts
 parameter in the Linux kernel command line.
The format for the parameter is documented in the 
source-code
 for the kernel module responsible for parsing it.
For example, the parameter 
mtdparts=flash.0:-(root)
 specifies a single partition with label 
root
 for 
flash.0
.
A flash drive holds whatever data is made available by the emulator in the corresponding target physical memory region.
The data can come from an image file specified during machine instantiation, from an image file specified after instantiation via the 
machine:replace_memory_range(<memory_range_config>)
, or through external state access method 
machine:write_memory()
.
The Cartesi-provided 
/sbin/init
 script scans flash drives 1
–
7 for valid file-systems.
When a valid file-system is detected, the script automatically mounts the file-system at 
/mnt/<label>
, using the corresponding 
<label>
 from the 
mtdparts
 kernel parameter.
In this fashion, file-systems present in all flash drives are available for use right after Linux boots.
This was the case with the command
cartesi-machine 
\
    --flash-drive
=
label:hello,filename:hello.ext2 
\
    -- 
"/mnt/hello/all.sh"
The 
cartesi-machine
 command-line utility instructed the emulator to add a new flash drive, initialized with the contents of the 
hello.ext2
 image file.
It gave the label 
hello
 to that flash drive using the kernel command-line parameter 
mtdparts=flash.0:-(root);flash.1:-(hello)
.
The 
/sbin/init
 script identified a valid file-system in the device, and used its label to mount it at 
/mnt/hello
.
It then executed the command 
/mnt/hello/all.sh
, causing all the 
“
Hello world!
”
 messages to be printed to screen.
Raw flash drives
​
Raw flash drives, i.e., flash drives containing free-format data, are not mounted.
Instead, the data in raw flash drives are read from/written to directly by accessing the underlying block device.
The layout and contents of data written to raw flash drives is completely up to application developers.
Depending on the layout and contents, it may be simple or difficult to read from/write to raw flash drives from the command line.
The most popular tool for reading and writing block devices is the 
dd
 command-line utility.
Another alternative is the 
devio
 tool.
Some scripting languages, like the Lua programming language, have packing and unpacking libraries that can be very helpful.
For example, consider the previously discussed Cartesi Machine that operates as an arbitrary-precision calculator
\
rm -f output.raw
truncate -s 4K output.raw
echo
 
"6*2^1024 + 3*2^512"
 
>
 input.raw
truncate -s 4K input.raw
cartesi-machine 
\
    --flash-drive
=
"label:input,length:1<<12,filename:input.raw"
 
\
    --flash-drive
=
"label:output,length:1<<12,filename:output.raw,shared"
 
\
    -- 
$'dd status=none if=$(flashdrive input) | lua -e \'print((string.unpack("z", io.read("a"))))\' | bc | dd status=none of=$(flashdrive output)'
luapp5.3 -e 
'print((string.unpack("z", io.read("a"))))'
 
<
 output.raw
The input is a null-terminated string containing the expression to be evaluated.
This string is stored inside a raw flash drive with label 
input
.
The output is once again a null-terminated string with the result, this time stored inside a raw flash drive with label 
output
.
The command executed inside the machine is
dd
 
status
=
none 
if
=
$(
flashdrive input
)
 
|
 
\
    lua -e 
'print((string.unpack("z", io.read("a"))))'
 
|
 
\
    
bc
 
|
 
\
    
dd
 
status
=
none 
of
=
$(
flashdrive output
)
The 
flashdrive
 command-line utility prints the name of the device corresponding to a given label.
In this case, 
flashdrive input
 prints 
/dev/mtdblock1
 and 
flashdrive output
 prints 
/dev/mtdblock2
 (recall 
/dev/mtdblock0
 is the root file-system, defined by default to load the 
rootfs.ext2
 image).
The first command, 
dd status=none if=$(flashdrive input)
 therefore reads the entire 4KiB of the raw input flash drive and sends it to the standard output.
The second command, 
lua -e 'print((string.unpack("z", io.read("a"))))'
 extracts the first null-terminated string and prints it to standard out.
This is the meaning of the 
"z"
 format argument to the 
string.unpack()
 function.
There are a variety of other formats available, including reading integers of different sizes, big- or little-endian etc.
Please see the 
documentation for the 
string.unpack()
 function for more details.
The string is received by the 
bc
 command-line utility.
In the example, that string is 
6*2^1024 + 3*2^512\n
.
The 
bc
 command-line utility computes the value of the expression and sends it to standard out.
This is finally received by the last command, 
dd status=none of=$(flashdrive output)
, which writes it to the raw output flash drive.
(No need to null-terminate, since the drive is already completely filled with zeros.)
Initialization
​
By default, a Cartesi Machine starts its execution from the image loaded into ROM.
In order to boot Linux, the Cartesi-provided 
rom.bin
 image first builds a 
devicetree
 describing the hardware.
The organization of a Cartesi Machine is defined during machine instantiation from its configuration.
This includes the number, starts, and lengths of all flash drives and rollup memory ranges, the amount of RAM, and which HTIF commands are supported (yield manual, yield automatic, console getchar etc).
The 
rom.bin
 program reads a Cartesi-specific low-level description of this organization from special machine registers and translates it into a devicetree that Linux can understand.
The configuration also includes the initial contents of ROM, RAM, all flash drives and rollup memory ranges, all registers, and the command-line parameters to be passed to the Linux kernel.
The latter is also added to the devicetree.
Once the devicetree is ready, 
rom.bin
 jumps to the image loaded into RAM, passing the address of the devicetree (which resides at the end of RAM) in a register.
The Cartesi-provided 
linux.bin
 image is composed of the Linux kernel linked with the Berkeley Boot Loader (BBL).
BBL is a thin abstraction layer that isolates Linux from details of the particular RISC-V machine on which it is running.
The abstraction layer gives Linux the ability to perform tasks such as powering the machine down and outputting a character to the console.
Once this functionality has been installed, BBL jumps to the kernel entrypoint.
The Linux kernel reads the devicetree to find out about the machine organization, loads the appropriate drivers, and performs its own initialization.
When the kernel initialization is complete, it tries to mount a root file-system.
The information of where this root file-system resides comes from the kernel command-line parameter.
In normal situations, this will reside in 
/dev/mtdblock0
.
Once the root file-system is mounted, the kernel executes 
/sbin/init
.
The Cartesi-provided 
/sbin/init
 script in 
rootfs.ext2
 sets up a basic Linux environment on which applications can run.
In particular, it goes over the available flash drive devices (
/dev/mtdblock1
–
/dev/mtdblock7
) looking for valid file-systems, and mounting them at the appropriate 
/mnt/<label>
 mount points.
The Linux kernel passes to 
/sbin/init
, unmodified, everything after the separator 
--
 in its own command-line.
Once its initialization tasks are complete, the Cartesi-provided 
/sbin/init
 concatenates all its arguments into a string and executes them in a shell.
This is how the commands passed to 
cartesi-machine
 come to be executed in the Linux environment that runs inside the Cartesi Machine.
Given a proper 
rootfs.ext2
 and an appropriate command-line, the applications can run any general computation, consuming input from any flash drives, and writing outputs to any flash drives.
Once the application exits, control returns to 
/sbin/init
.
The script then unmounts all file-systems and gracefully halts the machine.
Cartesi-specific devices
​
The Linux kernel produced in the 
kernel/
 directory of the 
Cartesi Machine SDK
 includes two Cartesi-specific device drivers, accessible via 
/dev/yield
 and 
/dev/rollup
.
The 
/dev/yield
 device allows target applications to return control back to the host, while signaling a variety of conditions that may require its attention.
The 
/dev/rollup
 device allows target applications to interact with Cartesi Rollups, receiving requests and returning responses.
(Internally, the 
/dev/rollup
 device uses the 
/dev/yield
 device.)
ioctl for /dev/yield
​
The 
/dev/yield
 device can be controlled directly via its 
ioctl
 interface.
This is how the 
/opt/cartesi/bin/yield
 command-line utility operates.
The only 
ioctl
 request code exported is 
IOCTL_YIELD
.
It takes as argument a structure 
yield_request
 defined as follows:
struct yield_request {
    __u8 dev;
    __u8 cmd;
    __u16 reason;
    __u32 data;
};
The 
dev
 field must take the value 
HTIF_DEVICE_YIELD
.
The 
cmd
 field can take one of two values: 
HTIF_YIELD_MANUAL
 or  
HTIF_YIELD_AUTOMATIC
.
Sending either a manual yield or an automatic yield command to the device causes the emulator to return control to the host, giving it access to the 
reason
 and 
data
 fields.
Manual yields are used when the target application needs some kind of manual intervention from the host that modifies the machine state before resuming, typically when it needs some kind of input or throws an exception.
In that case, the Y bit in the 
iflags
 CSR will be set, and must be externally reset before the machine can continue executing.
Automatic yields are used when the target application has produced some data for the host, and can be resumed without further action, automatically.
The X bit in the 
iflags
 CSR will be set instead, and will be automatically reset when the machine is resumed.
The 
HTIF_YIELD_REASON_PROGRESS
 value for the 
reason
 field is used with automatic yields.
In this case, the value of the 
data
 field should contain an integer with the progress in parts per thousand.
The remaining values for the 
reason
 field are in conjunction with the 
/dev/rollup
 device.
ioctl for /dev/rollup
​
The 
/dev/rollup
 device also exposes an 
ioctl
 interface.
It exports a variety of 
ioctl
 requests.
These are used, for example, by the 
/opt/cartesi/bin/rollup
 and 
/opt/cartesi/bin/rollup-http-server
 command-line utilities.
Recall that Cartesi Rollups is a mechanism by which a target application receives requests for processing and produces responses to those requests.
There are two types of rollup requests: advance-state requests and inspect-state requests.
There are four types of rollup responses: vouchers, notices, reports, and exceptions.
The 
ioctl
 request 
IOCTL_ROLLUP_FINISH
 is used to transition between one rollup request to the next.
It takes as argument a structure 
rollup_finish
 defined as follows:
struct rollup_finish {
    /* True if previous request should be accepted */
    /* False if previous request should be rejected */
    bool accept_previous_request;
    int next_request_type; /* either CARTESI_ROLLUP_ADVANCE or CARTESI_ROLLUP_INSPECT */
    int next_request_payload_length;
};
The 
accept_previous_request
 field is set to 
true
 when accepting the previous request, or to 
false
 when rejecting it.
As a result, the 
/dev/rollup
 device will issue an yield manual command to the 
/dev/yield
 device, passing as 
reason
 field, respectively, 
HTIF_YIELD_REASON_RX_ACCEPTED
 or 
HTIF_YIELD_REASON_RX_REJECTED
.
Upon return, the value of field 
next_request_type
 will contain 
CARTESI_ROLLUP_ADVANCE
 if the next request is an advance-state request, or 
CARTESI_ROLLUP_INSPECT
 if the next request is an inspect-state request.
Moreover, the 
next_request_payload_length
 field will contain the length of the request payload.
To obtain the advance-state request data, the target application should then use the 
ioctl
 request 
IOCTL_ROLLUP_READ_ADVANCE_STATE
.
It takes as argument a structure 
rollup_advance_state
 defined as follows:
struct rollup_bytes {
    unsigned char *data;
    uint64_t length;
};
struct rollup_input_metadata {
    uint8_t msg_sender[CARTESI_ROLLUP_ADDRESS_SIZE];
    uint64_t block_number;
    uint64_t timestamp;
    uint64_t epoch_index;
    uint64_t input_index;
};
struct rollup_advance_state {
    struct rollup_input_metadata metadata;
    struct rollup_bytes payload;
};
The 
payload
 field should contain a 
rollup_bytes
 structure, where the 
payload.data
 points to a buffer that can hold 
payload.length
 bytes.
Note that the value of 
payload.length
 should be no less than the value of 
next_request_payload_length
 returned in the 
rollup_finish
 argument to the previous 
ioctl
 request 
IOCTL_ROLLUP_FINISH
.
Upon return, the 
payload.data
 buffer will contain the advance-state request payload.
This data comes from what the host wrote to the 
rollup.rx_buffer
 memory range.
In addition, the 
metadata
 field will contain all the associated input metadata.
This data comes from what the host wrote to the 
rollup.input_metadata
 memory range.
To obtain the inspect-state request data, the target application should then use the 
ioctl
 request 
IOCTL_ROLLUP_READ_ADVANCE_STATE
.
It takes as argument a structure 
rollup_advance_state
 defined as follows:
struct rollup_inspect_state {
    struct rollup_bytes payload;
};
The 
payload
 field should contain a 
rollup_bytes
 structure, where the 
payload.data
 points to a buffer that can hold 
payload.length
 bytes.
Note that the value of 
payload.length
 should be no less than the value of 
next_request_payload_length
 returned in the 
rollup_finish
 argument to the previous 
ioctl
 request 
IOCTL_ROLLUP_FINISH
.
Upon return, the 
payload.data
 buffer will contain the inspect-state request payload.
This data comes from what the host wrote to the 
rollup.rx_buffer
 memory range.
While processing a request, to produce a voucher, the target application should use the 
ioctl
 request 
IOCTL_ROLLUP_WRITE_VOUCHER
.
It takes as argument a structure 
rollup_voucher
 defined as follows:
struct rollup_voucher {
    uint8_t address[CARTESI_ROLLUP_ADDRESS_SIZE];
    struct rollup_bytes payload;
    uint64_t index;
};
The 
address
 field should contain the desired voucher address.
The 
payload
 field should contain a 
rollup_bytes
 structure with the desired voucher payload.
The 
/dev/rollup
 device copies this data to the 
rollup.tx_buffer
 memory range for the host to read.
Then, the 
/dev/rollup
 device issues an yield automatic command to the 
/dev/yield
 device, passing as 
reason
 field 
HTIF_YIELD_REASON_TX_VOUCHER
.
Upon return, the 
index
 field contains the index of the emitted voucher.
While processing a request, to produce a rollup notice, the target application should use the 
ioctl
 request 
IOCTL_ROLLUP_WRITE_NOTICE
.
It takes as argument a structure 
rollup_notice
 defined as follows:
struct rollup_notice {
    struct rollup_bytes payload;
    uint64_t index;
};
The 
payload
 field should contain a 
rollup_bytes
 structure with the desired notice payload.
The 
/dev/rollup
 device copies this data to the 
rollup.tx_buffer
 memory range for the host to read.
Then, the 
/dev/rollup
 device issues an yield automatic command to the 
/dev/yield
 device, passing as 
reason
 field 
HTIF_YIELD_REASON_TX_NOTICE
.
Upon return, the 
index
 field contains the index of the emitted notice.
While processing a request, to produce a rollup report, the target application should use the 
ioctl
 request 
IOCTL_ROLLUP_WRITE_REPORT
.
It takes as argument a structure 
rollup_report
 defined as follows:
struct rollup_report {
    struct rollup_bytes payload;
};
The 
payload
 field should contain a 
rollup_bytes
 structure with the desired report payload.
The 
/dev/rollup
 device copies this data to the 
rollup.tx_buffer
 memory range for the host to read.
Then, the 
/dev/rollup
 device issues an yield automatic command to the 
/dev/yield
 device, passing as 
reason
 field 
HTIF_YIELD_REASON_TX_REPORT
.
Finally, to throw a rollup exception, the target application should use the 
ioctl
 request

IOCTL_ROLLUP_THROW_EXCEPTION
.
It takes as argument a structure 
rollup_exception
 defined as follows:
struct rollup_exception {
    struct rollup_bytes payload;
};
The 
payload
 field should contain a 
rollup_bytes
 structure with the desired exception payload.
The 
/dev/rollup
 device copies this data to the 
rollup.tx_buffer
 memory range for the host to read.
Then, the 
/dev/rollup
 device issues an yield 
manual
 command to the 
/dev/yield
 device, passing as 
reason
 field 
HTIF_YIELD_REASON_TX_EXCEPTION
.
Target "Hello world!"
The root file-system
Flash drives
Raw flash drives
Initialization
Cartesi-specific devices
ioctl for /dev/yield
ioctl for /dev/rollup
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 36---










11 docs tagged with "dapps" | Blockchain OS Documentation - Cartesi
























Skip to main content
Components
As explained in the previous section, the Cartesi Rollups framework achieves scalability by moving the bulk of the computation outside the blockchain, using the ledger as a data source but not as an execution environment. As such, the solution contains both on-chain (layer-1) and off-chain (layer-2) components.
Create your first DApp
Once you learned how to run a simple example, it is now time to create one of your own. In order to do this, we will make use of the DApp template available in Cartesi's rollups-examples Github repository. Once again, make sure you have installed all the necessary requirements before proceeding.
DApp architecture
Borrowing from familiar mainstream terminology, from a developer’s point of view a Cartesi DApp is developed by implementing two main components: a front-end and a back-end.
DApp life cycle
Now that we have described the architecture of a Cartesi DApp and how the front-end and back-end communicate with the Cartesi Rollups framework, let’s step back a bit to discuss how a DApp can be implemented in practice.
Deploying DApps
Please check the full documentation for deploying Rollups DApps to Cartesi's cloud-based execution infrastructure.
General requirements
To start developing applications using Cartesi Rollups, first make sure that the packages listed in this section are all installed and working in your system. The instructions listed below should be enough to turn a fresh copy of the latest Ubuntu LTS distribution into a fully fledged Cartesi development environment.
Overview
The combination of an Optimistic Rollups framework and the Cartesi Machine Emulator enables the development of smart contracts and DApps using any package or library that is available for Linux. This allows developers to break free from the scalability limitations of the Ethereum Virtual Machine (EVM), and brings the rise of a new blockchain era to handle real-life and complex use-cases.
Overview of building DApps
Navigate to our Quick Start tutorial if you want to build DApps now!
Quick Start
This article explains how to build and interact with a minimalistic Cartesi Rollups application.
Rollups HTTP APIs
In a Cartesi DApp, the front-end and back-end parts of the application communicate with each other through the Rollups framework via a set of HTTP APIs.
Run back-end in Host Mode
When developing an application, it is often important to easily test and debug it. For that matter, it is possible to run the Cartesi Rollups environment in host mode, so that the DApp's back-end can be executed directly on the host machine, allowing it to be debugged using regular development tools such as an IDE.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 37---










DApp life cycle | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Now that we have described the 
architecture of a Cartesi DApp
 and how 
the front-end and back-end communicate with the Cartesi Rollups framework
, let’s step back a bit to discuss how a DApp can be implemented in practice.
As mentioned before, we at Cartesi wanted to provide a development experience that would feel as familiar as possible for mainstream developers. With that in mind, we defined a series of 
stages
 covering the entire life cycle of a Cartesi DApp’s development. The intention here is to allow developers to use their usual mainstream development environment for the larger part of their projects, and to make that possible Cartesi will provide the necessary tools and infrastructure.
Stage 1: Design
​
This would involve the overall conceptual design of the application, specifying the main scope of the front-end and back-end logic, as well as general technology requirements (e.g., whether it will use an SQL database, execute a trained AI model, etc.)
Stage 2: Proof of Concept
​
Checkpoint stage to implement a proof of concept ensuring the feasibility of executing the intended back-end logic and tech stacks inside a Cartesi Machine. This stage might involve cross-compiling a library to Cartesi’s RISC-V Linux OS and verifying that the performance of running the intended software in the Cartesi Machine is satisfactory.
Stage 3: Implementation
​
This is the stage where the front-end and back-end logic are actually implemented, representing the bulk of the work in the DApp’s development life cycle.
At this stage, the DApp developer will make use of the 
Cartesi Rollups Host Environment
 to implement the front-end and back-end modules of the DApp using common mainstream technologies and tools. This environment provides the very same HTTP API as the regular one, mimicking the behavior of the actual layer-1 and layer-2 components. This way, the front-end and back-end modules can be tested as any regular application, such as having a web application front-end in the browser and a native back-end running on localhost. This allows the developer to run and debug them using familiar tools, such as an IDE.
We expect this feature to be a game-changer in terms of DApp development productivity. The Cartesi Rollups Host Environment can be executed by simply running a Docker Compose file, and detailed instructions about using it can be found in our 
Rollups Github repository
.
Stage 4: Packaging
​
In this stage, the back-end part is packaged to run inside a Cartesi Machine, to be executed by a real Layer-2 node (i.e., not a development version in which the back-end runs directly on the host). The feasibility of running it inside a Cartesi Machine should have already been accessed during Stage 2, and now we will just see if the full DApp implementation runs satisfactorily as well.
Since the back-end will keep using the very same HTTP API as before, it remains unchanged. The only difference is that this time around it will interact with a service running inside the Cartesi Machine itself, instead of directly communicating with the Rollups Host infrastructure as in Stage 3.
Stage 5: Deployment
​
With the full application working fine inside a Cartesi Machine, the final step is to deploy it. This can be tested on a local environment in which a 
Hardhat instance acts as a local blockchain
, but the ultimate goal is of course to deploy it to a remote public blockchain network.
This stage involves publishing the DApp back-end so that Cartesi Layer-2 nodes can execute its logic inside a Cartesi Machine. To that end, the DApp developer will use a 
deployment procedure
 that will register the DApp in the target blockchain and upload the back-end machine configuration so that it can be used by the target Cartesi nodes.
Stage 1: Design
Stage 2: Proof of Concept
Stage 3: Implementation
Stage 4: Packaging
Stage 5: Deployment
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 38---










Cartesi Compute | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Cartesi Compute SDK
​
Overview
How it works
Architecture
Wallets
Execution timeline
Machines off-chain
Machines on-chain
On-chain API
Instantiate
Drives
Provider drives
Logger drives
Topologies
Supported networks
Cartesi Compute Tutorials
​
Introduction
General requirements
Cartesi Compute SDK Environment
Hello World DApp
​
Creating basic DApp
Hello World machine
Instantiating computation
Retrieving result
Deploying and running
Calculator DApp
​
Calculator project
Calculator machine
Full Calculator DApp
Generic Script DApp
​
Generic Script project
Custom root file-system
Generic Script machine
Full Generic Script DApp
GPG Verify DApp
​
GPG Verify project
Using ext2 files and GPG
GPG Verify machine
Full GPG Verify DApp
Processing larger files
Dogecoin Hash DApp
​
Dogecoin Hash project
Computing scrypt using C
Dogecoin Hash machine
Full Dogecoin Hash DApp
Cartesi Compute SDK
Cartesi Compute Tutorials
Hello World DApp
Calculator DApp
Generic Script DApp
GPG Verify DApp
Dogecoin Hash DApp
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 39---










The Blockchain OS | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Cartesi
, The Blockchain OS, is a layer-2 platform for the development and deployment of scalable decentralized applications. The 
Blockchain OS
 offers a Linux operating system coupled with a blockchain infrastructure, which allows DApps to be developed in familiar programming languages like Python without the need to write Solidity code.
Limitations, develop with The Blockchain OS!
​
Other blockchain platforms do not allow you to develop a DApp that uses a file-system, an SQL database or a machine learning model. Generally there are also harsh limitations related to gas limits and high fees when performing computations such as looping over arrays and manipulating strings, which are commonplace in regular mainstream applications.
Today there is a large number of developers and companies who want to enter the blockchain world but face a steep learning curve and a confusing landscape. Cartesi solves this with The Blockchain OS, so that you can develop a DApp using any traditional software stack.
Here comes the mission of Cartesi:
To offer a full operating system for blockchain applications.
To solve the 
scalability problem
 using Optimistic Rollups along with the Cartesi Machine to support complex computations.
To develop DApps of arbitrary complexity using mainstream development tools and software stacks, and have all of it sit on top of established blockchain networks such as Ethereum, Polygon, Avalanche and BNB Smart Chain.
Cartesi, The Blockchain OS provides lower gas and crypto costs. Additionally, if you are a web developer and you want to build a simple application as your first step in blockchain development, with Cartesi you will not be forced to use a specific language, such as Solidity for Ethereum, nor be forced to reinvent the wheel because a given functionality or math library is not available.
How are Cartesi Rollups different?
​
Most current general-purpose rollups layer 2 solutions, such as 
those based on Optimistic Rollups
, strive to be EVM-compatible because they are focusing on providing lower transaction costs and higher throughputs for the smart contracts that already run on Ethereum. However, Cartesi focuses on providing a true operating system for blockchain developers, allowing them for the first time to leverage decades of software development from the mainstream industry. With that goal in mind, 
Cartesi Rollups
 not only solves the scalability problem by using an Optimistic Rollups framework, but also takes advantage of the 
Cartesi Machine Emulator
 to boost productivity and application complexity by allowing developers to code their smart contracts using any software stack that is already available for Linux.
You can think of Cartesi Rollups as a special operating system that makes your life easier, allowing you to create computationally heavy DApps while providing you with the freedom to choose the programming languages, libraries and tools of your preference. At Cartesi, we believe that this freedom will help start a new era for blockchain application development.
See Also
​
Why Cartesi Rollups is Unique
Rollups On-Chain
Cartesi Node
Testnet
Transaction Manager
State Fold
Limitations, develop with The Blockchain OS!
How are Cartesi Rollups different?
See Also
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 40---










6 docs tagged with "machine" | Blockchain OS Documentation - Cartesi
























Skip to main content
Hash view of state
One of the key goals of moving computations off-chain is to allow them to manipulate vast amounts of data: so much data that it becomes economically prohibitive to explicitly store them in the blockchain.
Introduction
This section describes Cartesi Machines from the perspective of the blockchain.
Introduction
The Cartesi Machine is Cartesi's solution for verifiable computation.
Lua interface
This entire chapter is for advanced users only, since typical users of the Cartesi platform will likely never need to programmatically control a Cartesi Machine.
Overview
Cartesi's reference off-chain implementation of Cartesi Machines is based on software emulation.
Verification game
This section is still under construction.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 41---










DApp architecture | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Borrowing from familiar mainstream terminology, from a developer’s point of view a Cartesi DApp is developed by implementing two main components: a 
front-end
 and a 
back-end
.
Here, the yellow boxes represent the parts that the developer needs to implement to build a DApp, which are discussed in more detail below. On the other hand, the parts in blue correspond to the general Rollups framework provided by Cartesi. This framework includes both the underlying layer-1 blockchain, with Cartesi Rollups smart contracts deployed, and the layer-2 off-chain nodes.
Back-end
​
The back-end of a Cartesi DApp contains the business logic of the application, similar to what traditional systems would run inside a server. The difference here — and the reason for using blockchain technology in general — is that decentralized applications need this back-end logic to be verifiable and hence trustless. As such, it is executed inside the Cartesi Rollups framework.
The back-end stores and updates the application state as user input is received and produces corresponding outputs. These outputs can come in the form of 
vouchers
 (transactions that can be carried out on layer-1, such as a transfer of assets), 
notices
 (informational statements, such as the resulting score of a game), or 
reports
 (application logs and diagnostic information, such as error or warning messages).
In practical terms, a Cartesi DApp back-end can be seen as a smart contract, but on steroids.
Front-end
​
The front-end of a Cartesi DApp corresponds to the user-facing interface, which will often provide a GUI (e.g., a web application) but may also be just a command-line interface, such as a Hardhat task using ethers.js, or a command-line tool written in Python.
The front-end's job is usually to collect user input and submit it to the DApp, as well as to query and show the DApp's state.
Communication
​
When compared to traditional software development, the main difference of a Cartesi DApp is that the back-end is deployed to a decentralized network of layer-2 nodes, which continuously verify the correctness of all processing results. As a consequence, the front-end and back-end do not communicate directly with each other. Rather, the front-end sends inputs to the Cartesi Rollups framework, which in turn makes them available to the back-end instances running inside each node. After the inputs are processed by the back-end logic, the corresponding outputs are then informed back to the Rollups framework, which enforces their correctness and makes them available to the front-end and any other interested parties.
The sequence diagram below illustrates how all of this works:
note
The Cartesi Rollups framework provides a set of APIs to specify how the DApp's front-end and back-end should communicate with it. These APIs are explained in detail in the 
next section
.
Other components
​
Aside from the back-end running inside the Cartesi Rollups infrastructure, the DApp front-end may also use external resources such as third-party services. Indeed, for more complex DApps it is expected that there will be other back-ends besides the one running verifiable logic. They would be used whenever the application doesn’t need a service to be decentralized and trustless, such as providing fast and accessible data caches, helping users communicate with each other, or interfacing with other non-blockchain services.
Conversely, it is also possible for complex DApps to provide more than one front-end application, with the goal of supporting different kinds of users and use cases.
Back-end
Front-end
Communication
Other components
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 42---










One doc tagged with "deploy" | Blockchain OS Documentation - Cartesi
























Skip to main content
Deploying DApps
Please check the full documentation for deploying Rollups DApps to Cartesi's cloud-based execution infrastructure.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 43---










Overview | Blockchain OS Documentation - Cartesi
























Skip to main content
The goal of the target perspective is to serve both target application-developers and target system-developers.
The documentation therefore starts from the familiar Linux environment that runs inside Cartesi Machines.
This is the abstraction level at which target application-developers interact with Cartesi Machines.
The documentation then moves towards the system architecture implemented by Cartesi Machines, including Cartesi-specific extensions to the RISC-V architecture.
This is what surrounds the Linux environment, and is the abstraction level at which target system-developers work.
This is, of course, not the most natural order for presenting the material.
After all, running the embedded Linux environment experienced by application-developers is only possible after successful initialization of the Linux kernel, which in turn depends on knowledge of the system architecture.
However, presenting the material in this order would quickly alienate application developers.
Since there are many more application developers than system developers, we cater to the former.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 44---










General requirements | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
To start developing applications using Cartesi Rollups, first make sure that the packages listed in this section are all installed and working in your system. The instructions listed below should be enough to turn a fresh copy of the latest Ubuntu LTS distribution into a fully fledged Cartesi development environment.
Section Goal
ensure you have all the necessary dependencies for building Cartesi DApps
Basic tools
​
Before installing any package specifically needed for Cartesi Rollups development, we must first make sure that some basic tools are available.
First of all, let's install the 
curl
 tool for transferring data using a number of supported protocols:
sudo
 
apt-get
 update
sudo
 
apt-get
 
install
 
curl
Now, let's also install the 
wget
 tool for non-interactive download of files from the Web:
sudo
 
apt-get
 
install
 
wget
Docker and Docker Compose
​
Docker
 is a widely used platform for users to build, run, and share applications with containers, and is a great way of distributing the Cartesi Rollups framework and all of its dependencies.
Docker Compose
 is an additional tool that allows us to start multiple Docker containers simultaneously and set up the communication between them. With Compose, we can locally instantiate a full Cartesi Rollups environment (i.e., all off-chain and on-chain components, including the local "testnet" blockchain itself), and thus test our Cartesi DApps using only your physical development machine.
To install Docker and Docker Compose, you can follow the 
official installation instructions from the Docker website
. For Ubuntu, you may also refer to 
installation instructions that are specific for the platform
. Below, we reproduce the installation steps that we have verified as working for a fresh Ubuntu installation:
First, we need to set up Docker's repository:
sudo
 
apt-get
 update
sudo
 
apt-get
 
install
 ca-certificates 
curl
 gnupg lsb-release
sudo
 
mkdir
 -p /etc/apt/keyrings
curl
 -fsSL https://download.docker.com/linux/ubuntu/gpg 
|
 
sudo
 gpg --dearmor -o /etc/apt/keyrings/docker.gpg
echo
 
\
  
"deb [arch=
$(
dpkg --print-architecture
)
 signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  
$(
lsb_release -cs
)
 stable"
 
|
 
sudo
 
tee
 /etc/apt/sources.list.d/docker.list 
>
 /dev/null
And then install Docker itself:
sudo
 
apt-get
 update
sudo
 
apt-get
 
install
 docker-ce docker-ce-cli containerd.io docker-compose-plugin
Finally, it is a good idea to allow non-root users to manage Docker, so as to avoid having to type 
sudo
 for every Docker command:
sudo
 
usermod
 -aG 
docker
 
$USER
newgrp 
docker
After that, you can check if Docker is property installed by running:
docker --version
It is recommended that the installed Docker version be at least 
20.10.14
 in order to adequately build a development environment and execute 
example DApps
 made available by Cartesi.
Node.js and NPM
​
Node.js
 is a very popular asynchronous event-driven JavaScript runtime, and is often distributed along with the 
NPM package manager
. These are required for running 
Yarn
.
To install Node.js, follow 
the official instructions
. Specifically for Ubuntu, you can perform the steps below:
curl
 -sL https://deb.nodesource.com/setup_16.x 
|
 
sudo
 -E 
bash
 -
sudo
 
apt-get
 
install
 -y nodejs
And then test them:
node
 –-version
npm
 –-version
Yarn
​
Yarn
 is a great dependency management tool, and will be used for adding dependencies to your Cartesi DApps. You can install it by accessing 
the official installation site
. The official instructions for installing on Ubuntu are as follows.
First, configure the repository:
curl
 -sS https://dl.yarnpkg.com/debian/pubkey.gpg 
|
 
sudo
 apt-key 
add
 -
echo
 
"deb https://dl.yarnpkg.com/debian/ stable main"
 
|
 
sudo
 
tee
 /etc/apt/sources.list.d/yarn.list
Then, run:
sudo
 
apt-get
 update 
&&
 
sudo
 
apt-get
 
install
 
yarn
And finally, test that Yarn is installed and working property:
yarn
 --version
Basic tools
Docker and Docker Compose
Node.js and NPM
Yarn
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 45---










References | Blockchain OS Documentation - Cartesi
























Skip to main content
Code samples
Deployment samples
Changelog
Releases
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 46---










Components | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
As explained in the 
previous section
, the Cartesi Rollups framework achieves scalability by moving the bulk of the computation outside the blockchain, using the ledger as a data source but not as an execution environment. As such, the solution contains both on-chain (layer-1) and off-chain (layer-2) components.
note
In this section, we describe the internal components of the Cartesi Rollups framework in more detail, to clarify how the system works inside. DApp developers may chose to skip directly to the 
DApp architecture
 section to understand how to build applications.
Main concepts
​
Cartesi Nodes
​
As explained before, 
Cartesi Machines
 provide DApp developers with an environment in which large scale verifiable computations can be executed. These machines are integrated with the on-chain smart contracts by a 
middleware
 that manages and controls the communication between them. As such, this middleware is responsible for first reading data from the layer-1 smart contracts, then sending them to the machine to be processed, and finally publishing their results back to the blockchain.
The 
Cartesi Node
 is the layer-2 component that consists of the combination of the Cartesi Machine and this middleware, and can be used by anyone interested in the rollups state of affairs. Put simply, Cartesi Nodes play a role that is similar to what Geth does on the Ethereum ecosystem: execution and retrieval of information.
In practice, there are two distinct kinds of agents that run Cartesi Nodes: 
users
 and 
validators
. Each of them interacts with the on-chain rollups in different ways, and thus run different types of Cartesi Nodes:
User or Reader Nodes
, which are only involved in advancing the state of the off-chain machine, and making that state publicly available. They consume information from the blockchain but do not bother to enforce state updates, trusting that validators will ensure the validity of all on-chain state updates.
Validator Nodes
, which have more responsibility: they not only watch the blockchain but also fight possible dishonest validators to ensure the prevalence of honest claims for state updates. On the other hand, if Reader Nodes are available, validators do not need to expose endpoints for retrieving application state. Therefore, they can run in more secure environments and remain inaccessible to external clients and users.
Epochs
​
In order to avoid over interacting with the blockchain, validators don't checkpoint every new state update on the off-chain machine. They do it at the end of an 
epoch
, which are batched inputs that follow the same cycle.
We can imagine epochs in three different states:
Accumulating
, when the epoch is open and waiting for inputs.
Sealed
, when the inputs for that epoch are well defined and the validators are preparing to send their claims. Sealed epochs can also be under dispute.
Finalized
, when consensus was reached and the outputs can be safely executed.
The on-chain state, depending on what phase it is, can contain one or two epochs, as illustrated by the diagram below.
Input Accumulation
: there is a single accumulating epoch, active and waiting for the inputs it is going to batch.
Awaiting Consensus
: there are two epochs. A sealed one, for which validators are preparing to or sending their claims, and an accumulating one, which is active and receiving inputs.
Awaiting Dispute
: there are also two epochs. A sealed one and an accumulating one. The sealed epoch is under dispute. At least two conflicting claims were received and the validators are enrolling in a verification game to decide which claim stands. Since the sealed epoch's inputs are well defined, honest validators will always reach the same claim. A dispute necessarily means that a claim is provably false.
To better understand the whole process on a timeline, let's describe how the system schedules different rollups phases.
On a given epoch N, the involved validator nodes batch all the input messages that were enqueued on-chain from the beginning of the previous 
epoch’s processing
 slot until the beginning of the current epoch’s 
processing slot
.
The nodes then process every message of the batch through the Cartesi Machine, producing an output hash that summarizes the state transition of the entire epoch. Then, one of the validators, henceforth called 
claimer
, places on-chain the hash representing the layer-2 contract state at the end of epoch N, 
S(N)
.
After a challenge period is over, if there was no dispute, 
S(N)
 is assumed final by the system. Otherwise, disputes will follow until the correct state claim represented by its output hash is enforced. The 
settlement period
 displayed on the diagram above accounts for a 
challenge period
, with or without disputes.
To guarantee a minimum duration for each epoch, the rollups protocol also requires an 
accumulation slot
. This is a minimal latency imposed on on-chain finalization to prevent frequent claims being sent to layer-1, for the sake of Ethereum fee cost-effectiveness. The rollup developer can configure a specific accumulation slot period for their application to accommodate eventual specific requirements for balancing latency to finality and security.
Vouchers
​
A 
voucher
 is a combination of a target address and a payload in bytes. It is used by the off-chain machine to respond and interact with layer-1 smart contracts. Upon execution, a voucher sends a message to the target address with the payload as a parameter. Vouchers can be used for anything, ranging from providing liquidity in a DeFi protocol to withdrawing funds from the 
Portal
. Vouchers can only be executed when the epoch in which they are contained is 
finalized
, at which point a 
validity proof
 will be available to ensure layer-1 smart contracts can trust its content.
Notices
​
A 
notice
 is an arbitrary payload in bytes that is submitted by the off-chain machine for informational purposes. Similarly to vouchers, when the epoch containing a notice is finalized a proof will be produced so that the validity of the notice's content can be verified on-chain by any interested party.
Reports
​
A 
report
 is an application log or a piece of diagnostic information. Like a notice, it is represented by an arbitrary payload in bytes. However, a report is never associated with a proof and is thus not suitable for trustless interactions such as on-chain processing or convincing independent third parties of DApp outcomes. Reports are commonly used to indicate processing errors or to retrieve application information for display.
On-chain components
​
These consist of the Cartesi Rollups smart contracts that were designed to mediate the relationship of the off-chain components with other smart contracts and externally owned accounts. They include several modules, each with clear responsibilities and well-defined interfaces.
Cartesi Rollups Manager
​
The 
Cartesi Rollups Manager
 is responsible for synchronicity between the modules. It defines the duration of the different phases and notifies the other modules of any phase change. Among others, the responsibilities of this module are:
Define to which epoch an input is destined, depending on the current state and deadlines.
Receive and forward claims to the Validator Manager.
Forward disputes to the Dispute Resolution module.
Forward the result of disputes to the Validator Manager.
Forward the summary of finalized outputs (vouchers and notices) to the Output module.
Notify other modules of phase changes.
Input contract
​
As discussed above, the on-chain contracts often have two concurrent epochs: a sealed but unfinalized epoch, and an accumulating one. The 
Input contract
 keeps one inbox for each of those epochs, switching between them depending on the Cartesi Rollups Manager's notifications.
For anyone to be able to synchronize the machine from its beginning without needing to trust a data provider, the full content of inputs is always present in calldata on the blockchain. In on-chain storage, which needs to be used in a more parsimonious way, we keep a single hash for each input of an active epoch.
This input hash summarizes both the input itself and its metadata, which corresponds to the sender's address and the time of reception. Notice that this input implementation is permissionless: the permission layer is delegated to the off-chain machine which will, for example, judge if a sender is allowed to do what their input wants to do.
Output contract
​
Each input can generate a number of notices and vouchers that will have an accompanying 
validity proof
 available once the epoch containing them is finalized. These proofs can be used with the 
Output contract
 to execute vouchers or verify the validity of a notice's content.
For vouchers, while the Output contract is indifferent to their content, it does enforce some sanity checks before allowing their execution, since vouchers are unique and can only be successfully executed once. Vouchers are executed asynchronously and don't require an access check, and the order of execution is not enforced. As long as vouchers are contained in a finalized epoch and were not executed before, the contract will allow their execution by anyone.
Portal
​
The Portal, as the name suggests, is used to teleport assets from the Ethereum blockchain to DApps running on Cartesi Rollups. Once deposited, those layer-1 assets gain a representation in layer-2 and are owned, there, by whomever the depositor assigned them to. After being teleported, layer-2 assets can be moved around in a significantly cheaper way, using simple inputs that are understood by the Linux logic.
When an asset is deposited, the Portal contract sends an input to the DApp’s inbox, describing the type of asset, amount, receivers, and some data the depositor might want the DApp to read. This allows deposits and instructions to be sent as a single layer-1 interaction. One could think of the Portal as a bank account, owned by the off-chain machine.
Anyone can deposit assets there but only the DApp — through its Output contract — can decide on withdrawals. The withdrawal process is quite simple from a user perspective. They send an input requesting a withdrawal, which gets processed and interpreted off-chain. If everything is correct, the machine creates a voucher destined to the Portal contract, ordering and finalizing that withdrawal request. Currently, we support the following types of assets:
Ether (ETH)
ERC-20
ERC-721 (NFTs)
Validator Manager
​
The 
Validator Manager
 module was created to help DApps manage their claims, claim permissions, and punishments for bad behavior. Initially, our suggested implementation for this module includes the following characteristics: the set of payable validators is defined in construction time, validators send a claim for every epoch and those that lose a dispute are kicked off the validators set.
The 
Cartesi Rollups Manager
 receives claims and redirects them to the Validator Manager. When receiving a claim, the Validator Manager checks which other claims have arrived at that epoch and returns the information that Cartesi Rollups Manager needs to continue. The module can respond to received claims in one of the following ways:
If the sender is not a validator or the claim is invalid, the transaction reverts.
If the claim is valid, doesn’t disagree with any of the other claims in the epoch, and does not generate consensus, it returns a "No Conflict" response.
If the claim is valid but disagrees with another claim for that epoch, it warns the Cartesi Rollups Manager that a conflict is happening and what are the conflicting claims and claimants involved. When that dispute is resolved the Validator Manager module gets notified so it can deal however it likes with the validators involved. In our initially suggested implementation, the loser of a dispute is removed from the validator set.
If the claim is valid, agrees with all other claims in that epoch, and is the last claim to be received, it lets Cartesi Rollups know that consensus was reached. This allows the rollups DApp to finalize the epoch and allow for the execution of its vouchers. Regardless of what the name might suggest, validators do not interact with this module at all.
Fee Manager and Bank
​
The 
Fee Manager facet
 and 
Bank contract
 aim to create an economical incentive for validators to run a given DApp. When you develop an application, you will need to define two parameters:
A fee to be paid to the validators each time they submit a claim. This fee will be debited from the funds stored in the DApp's Bank contract.
An owner for the Fee Manager facet, who has the option to change the fee value, if needed.
Entities running validator nodes should configure them to either be 
altruistic
 or require a minimum retainer (i.e., a minimum fee to process inputs for the DApp). If they are altruistic, they will work regardless of any financial compensation. On the other hand, non-altruistic validators must ensure that the following two conditions are met before processing inputs and submitting claims:
The fee paid by the DApp must be bigger than their required retainer
The DApp's Bank must have enough funds to pay the validator
The fee value is given in CTSI and is reserved for a validator every time a claim is made. The validator is free to withdraw received CTSI fees at any time of its convenience. While the Fee Manager controls the fee value and the amount of claims made by each validator, the Bank stores - on a separate contract - the CTSI tokens that will be distributed to them.
The code does not enforce a way for the Bank to be funded. Therefore, DApps and communities are free to choose their preferred procedures, such as direct transfer, charging per input, creating a tax system on top of the Portal, or other methods. For convenience, a 
FundBank
 hardhat task is provided which transfers money from the signer to a DApp's Bank.
Dispute Resolution
​
Disputes occur when two validators claim different state updates to the same epoch. Because of the deterministic nature of our virtual machine and the fact that the inputs that constitute an epoch are agreed upon beforehand, conflicting claims imply dishonest behavior. When a conflict occurs, the module that mediates the interactions between both validators is the Dispute Resolution contract.
The code for rollups dispute resolution is not being published yet - but a big part of it is available on the Cartesi Rollups SDK, using the 
Arbitration dlib
.
Off-chain components
​
These consist of the internal modules of the 
Cartesi Node
. As explained before, Cartesi Nodes form the network that sustains the Cartesi Rollups solution, being responsible for executing the computations that arrive and presenting their results to the interested parties.
State Server
​
This service is responsible for ensuring that the remaining modules have access to a consistent view of the state of the blockchain. The service is an instance of  Cartesi's 
State Fold tool
 and monitors all relevant activity from the Cartesi Rollups smart contracts, consolidating the information that gets emitted by the blockchain.
Rollups Dispatcher
​
Responsible for interpreting the current state of the Cartesi Rollups smart contracts, this module informs the 
Server Manager
 about any incoming inputs and, in the case of Validator Nodes, also submits transactions to layer-1 corresponding to state update claims. It will also handle any disputes should they arise.
Server Manager
​
This module manages the Cartesi Machine, sending inputs to it and reading the produced outputs. It is responsible for starting and stopping the machine as appropriate, as well as providing an API for the other modules to query the machine's state.
The 
Host Server Manager
 is an alternative implementation of the Server Manager for development purposes. It implements the same API and mimics the behavior of an actual Server Manager, but does not in fact instantiate a Cartesi Machine. Instead, it makes HTTP requests directly to a DApp running in the host computer. The Host Server Manager is intended to be used in the 
implementation stage of the DApp life cycle
.
Rollups Indexer
​
This service is responsible for consolidating the state of the Cartesi Node. It queries blockchain information from the 
State Server
 as well as data produced by the DApp back-end through the 
Server Manager
, consolidating everything in a local database.
Query Server
​
Module that provides an externally accessible 
GraphQL API
 for querying the consolidated state of the Cartesi Node, as maintained by the 
Rollups Indexer
. This allows users and client applications to retrieve vouchers, notices and reports produced by the DApp back-end.
Main concepts
Cartesi Nodes
Epochs
Vouchers
Notices
Reports
On-chain components
Cartesi Rollups Manager
Input contract
Output contract
Portal
Validator Manager
Fee Manager and Bank
Dispute Resolution
Off-chain components
State Server
Rollups Dispatcher
Server Manager
Rollups Indexer
Query Server
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 47---










Cartesi Compute | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Cartesi Compute SDK
​
Overview
How it works
Architecture
Wallets
Execution timeline
Machines off-chain
Machines on-chain
On-chain API
Instantiate
Drives
Provider drives
Logger drives
Topologies
Supported networks
Cartesi Compute Tutorials
​
Introduction
General requirements
Cartesi Compute SDK Environment
Hello World DApp
​
Creating basic DApp
Hello World machine
Instantiating computation
Retrieving result
Deploying and running
Calculator DApp
​
Calculator project
Calculator machine
Full Calculator DApp
Generic Script DApp
​
Generic Script project
Custom root file-system
Generic Script machine
Full Generic Script DApp
GPG Verify DApp
​
GPG Verify project
Using ext2 files and GPG
GPG Verify machine
Full GPG Verify DApp
Processing larger files
Dogecoin Hash DApp
​
Dogecoin Hash project
Computing scrypt using C
Dogecoin Hash machine
Full Dogecoin Hash DApp
Cartesi Compute SDK
Cartesi Compute Tutorials
Hello World DApp
Calculator DApp
Generic Script DApp
GPG Verify DApp
Dogecoin Hash DApp
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 48---










Choose your Onboarding Path | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Our onboarding paths answer the following questions:
What can the Blockchain OS do for you as a new blockchain user?
What can the Blockchain OS do for you as a developer?
What can the Blockchain OS do for you as a researcher/low-level developer?
Beginner
Developer
Researcher & Low-level developer
note
This section of documentation targets new blockchain users who want to learn more about blockchain technology, DApps, and Rollups.
You can start by watching our Blockchain Course (available on Youtube):
Smart Contracts With Ethereum & Solidity
How Does Ethereum Work?
Introduction To Solidity
Solidity NFT Auction
Blockchain Limitations
Ethereum Scaling Solutions 
tip
Read the article about 
Scalability
 to learn more about solving the scalability issue in a blockchain system.
note
This section targets developers who want to start building DApps.
As a developer, you can use all the programming languages, tools, libraries, software, and services you are already familiar with. By moving most of the complex logic of their DApps to portable off-chain components, developers are freed from the limitations and idiosyncrasies imposed by blockchains. In this way, Cartesi empowers developers to select the best run-time environment in which to host each part of their DApps.
Quick start to run your first DApp
​
The fastest way of getting started is by 
Running a Simple DApp
 that we already built using Python.
tip
Check the section 
Cartesi Rollups
 to learn theoretical concepts such as DApp architecture, available APIs, and how Cartesi's off-chain and on-chain components work under the hood.
Navigate to 
Build DApps
 section for more guides:
Technical Prerequisites
Steps to create a DApp
Check 
more examples on GitHub
 such as:
Echo Python DApp
Echo C++ DApp
Echo Rust DApp
Echo Lua DApp
Echo JS DApp
Echo Low-Level
Converter DApp
Calculator DApp
SQLite DApp
k-NN DApp
m2cgen DApp
ERC-20 DApp
Auction DApp
Run your DApp off-chain using Cartesi Compute SDK
​
You can use the 
Cartesi Compute SDK
 to leverage Cartesi to run one-off complex computations that could never be executed inside a normal smart contract. Instead, those computations are executed off-chain with automatic dispute resolution guarantees, and its results can later be used on-chain.
Navigate to 
Cartesi Compute Tutorials
 section for more examples:
HelloWorld
Calculator
Dogecoin Hash
Generic Script
GPG Verify
note
This section targets researchers and low-level programmers who want to dive into our core technology.
You can dive deeper into the Blockchain OS core technology by reading the section about 
The Cartesi Machine
, which is a virtual machine that allows for verifiable computing using a Linux operating system.
Quick start to run your first DApp
Run your DApp off-chain using Cartesi Compute SDK
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 49---










Create a public pool | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
This guide provides more details for individuals or organizations who intend to provide staking services for users by creating Staking Pools and managing Noether nodes.
Pools
 are built on top of the current PoS and aggregate the staking requests from their users.
Pool operators
 are responsible for managing a Noether node, and they earn a commission out of the blocks rewards as compensation for operating the pool and the ETH fees they have to spend.
Staking Pools
 were built on top of the Staking smart contract, so they are subject to the same rules any other direct stakers are, such as the maturation time windows of a minimum of 6 hours for staking and 48 hours for unstaking. Additionally, pools need a larger time window to make sure that the staking, unstaking and withdrawal requests from their users are handled properly.
Individual pool users staking requests may take up to an additional 6 hours, and unstaking requests may take up to an additional 48 hours to complete. The pool performs aggregate staking and unstaking requests to the PoS and at the moment a user issues their individual request, the pool is probably in the middle of waiting for a previously issued staking/unstaking request to be completed. As it would happen with individual users, issuing an overlapping staking/unstaking request would restart the maturation/unlocking counter associated with the pool stake.
Noether
 is a layer-2 solution. It rewards block producers with CTSI, and requires ETH to pay for layer 1 transaction costs. The fees for block production are paid by the pool manager. Users pay ETH fees to initiate staking, unstaking and withdrawal requests, but the pool also needs to pay ETH fees to fulfill those requests (as the users interface with the pool smart contract and the pool then has to fulfill the requests on the PoS smart contracts).
The ETH to fund these transactions must be deposited in the wallet managed by the Noether node, created and managed by the pool manager. As a pool manager, one must keep track of the node’s wallet balance and replenish it as needed to make sure the node always has enough funds to operate correctly.
Prerequisites
​
Any organization or individual is free to create and operate a pool. There are no restrictions or special requirements, anyone can create a pool as long as they are willing to pay the necessary ETH fees to create and manage the pool.
The main prerequisites are:
Set up Ethereum node as the Cartesi node connects to the Ethereum network through a standard gateway. The Ethereum node works with any standard JSON-RPC Ethereum provider. It's important to use a stable and reliable provider, you can use 
Infura
 or 
Alchemy
 as Ethereum gateway
Install Docker enginer, you can download it for 
macOS
 or for 
Windows
Commission
​
Pool operators have two main responsibilities:
Make sure the Noether node is online and works properly 24x7
Pay the Ethereum fees that are necessary for block production and also maintenance operations like staking, unstaking and withdrawing from the Staking contract, on behalf of the users that delegate to their pool.
The first decision the pool owner has to make when creating a pool is choosing the commission model. Once created and configured, the pool manager cannot change the selected commission model.
There are two models available:
Flat rate commission
Gas-based commission
note
After you have selected and created the commission model, the commission value cannot be increased, but can be decreased at any time. This allows for fine adjustments of the economics of the pool, while preserving the public commitment not to increase the commission value.
You can increase the commission value with rules in place about maximum increases. For example, flat-rate commissions at the moment are at 5% and they can only increase once a week (i.e. they need to wait for seven days to be able to increase again)
Flat Rate
​
The Flat rate commission model is straightforward. A flat percentage is taken off the block reward before it is distributed among the pool stakers.
Example
​
A pool is configured with a 10% flat rate. Upon producing a block the pool receives 2,900 CTSI as reward. It takes 290 CTSI as commission, and distributes the remaining 2,610 CTSI to its users, in proportion to each user’s share in the total pool stake.
Gas Based
​
A gas based commission model takes into account the gas costs of producing the block. If the gas price at the moment of production is high, the cut will be higher, if the gas price is low, the cut will be lower. This model accommodates a variable gas price and CTSI price, but it’s harder to predict the final fee because of its complexity.
Example
​
A pool is configured to charge 400,000 gas. Upon producing a block this cost is “converted” to CTSI to calculate the commission. First it’s multiplied by the gas price at that moment, provided by a ChainLink oracle. Then it’s converted to CTSI by using an ETH/CTSI pair price provided by Uniswap V2.
Consider the following scenario:
gas price = 20 Gwei. 1 ETH = 4,000 CTSI
400,000 gas x 20 Gwei = 0.008 ETH
0.008 ETH x 4000 = 32 CTSI
Now consider that the gas price surges to 400 Gwei, and the CTSI price goes up in relation to ETH such that
1 ETH = 3200 CTSI
400,000 gas x 400 Gwei = 0.16 ETH
0.16 ETH x 3,200 = 512 CTSI
In the first example (20 Gwei gas price) the commission for that block is 1.1% (32/2,900) considering a reward of 2,900 CTSI. In the second example (400 Gwei gas price) the commission for the block is 17.6% (512/2,900) for the same reward amount. Compared to a flat rate pool with a 10% rate, for instance, the gas based commission can have a lower or higher fee depending on the gas price, CTSI price, and ETH price as shown in the previous examples.
No matter the selected commission model, the Cartesi Explorer will show the actual historical commission taken by each pool, as well as an estimate of the commission for the next block. Users can make an informed decision about which pool to choose based on the commission and reliability of pool operators (more about it below).
Steps to create a public pool
​
Navigate to our 
Staking Portal
Click on the button "CONNECT TO WALLET" 
Navigate to the 
Node Runners
 option in the top menu
Click on the button "CREATE PUBLIC POOL" 
Navigate to the section 
Create a Pool
 and make sure to follow all required steps
note
When the pool is created, the account connected to metamask is assigned as the pool owner and management operations can be done using that same account. Pool managers are responsible for running a Noether node and making sure it works properly 24x7, with a reliable internet connection, well funded and using a reliable Ethereum provider.
Prerequisites
Commission
Flat Rate
Gas Based
Steps to create a public pool
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 50---










Cartesi Compute | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Cartesi Compute SDK
​
Overview
How it works
Architecture
Wallets
Execution timeline
Machines off-chain
Machines on-chain
On-chain API
Instantiate
Drives
Provider drives
Logger drives
Topologies
Supported networks
Cartesi Compute Tutorials
​
Introduction
General requirements
Cartesi Compute SDK Environment
Hello World DApp
​
Creating basic DApp
Hello World machine
Instantiating computation
Retrieving result
Deploying and running
Calculator DApp
​
Calculator project
Calculator machine
Full Calculator DApp
Generic Script DApp
​
Generic Script project
Custom root file-system
Generic Script machine
Full Generic Script DApp
GPG Verify DApp
​
GPG Verify project
Using ext2 files and GPG
GPG Verify machine
Full GPG Verify DApp
Processing larger files
Dogecoin Hash DApp
​
Dogecoin Hash project
Computing scrypt using C
Dogecoin Hash machine
Full Dogecoin Hash DApp
Cartesi Compute SDK
Cartesi Compute Tutorials
Hello World DApp
Calculator DApp
Generic Script DApp
GPG Verify DApp
Dogecoin Hash DApp
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 51---










DApp architecture | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Borrowing from familiar mainstream terminology, from a developer’s point of view a Cartesi DApp is developed by implementing two main components: a 
front-end
 and a 
back-end
.
Here, the yellow boxes represent the parts that the developer needs to implement to build a DApp, which are discussed in more detail below. On the other hand, the parts in blue correspond to the general Rollups framework provided by Cartesi. This framework includes both the underlying layer-1 blockchain, with Cartesi Rollups smart contracts deployed, and the layer-2 off-chain nodes.
Back-end
​
The back-end of a Cartesi DApp contains the business logic of the application, similar to what traditional systems would run inside a server. The difference here — and the reason for using blockchain technology in general — is that decentralized applications need this back-end logic to be verifiable and hence trustless. As such, it is executed inside the Cartesi Rollups framework.
The back-end stores and updates the application state as user input is received and produces corresponding outputs. These outputs can come in the form of 
vouchers
 (transactions that can be carried out on layer-1, such as a transfer of assets), 
notices
 (informational statements, such as the resulting score of a game), or 
reports
 (application logs and diagnostic information, such as error or warning messages).
In practical terms, a Cartesi DApp back-end can be seen as a smart contract, but on steroids.
Front-end
​
The front-end of a Cartesi DApp corresponds to the user-facing interface, which will often provide a GUI (e.g., a web application) but may also be just a command-line interface, such as a Hardhat task using ethers.js, or a command-line tool written in Python.
The front-end's job is usually to collect user input and submit it to the DApp, as well as to query and show the DApp's state.
Communication
​
When compared to traditional software development, the main difference of a Cartesi DApp is that the back-end is deployed to a decentralized network of layer-2 nodes, which continuously verify the correctness of all processing results. As a consequence, the front-end and back-end do not communicate directly with each other. Rather, the front-end sends inputs to the Cartesi Rollups framework, which in turn makes them available to the back-end instances running inside each node. After the inputs are processed by the back-end logic, the corresponding outputs are then informed back to the Rollups framework, which enforces their correctness and makes them available to the front-end and any other interested parties.
The sequence diagram below illustrates how all of this works:
note
The Cartesi Rollups framework provides a set of APIs to specify how the DApp's front-end and back-end should communicate with it. These APIs are explained in detail in the 
next section
.
Other components
​
Aside from the back-end running inside the Cartesi Rollups infrastructure, the DApp front-end may also use external resources such as third-party services. Indeed, for more complex DApps it is expected that there will be other back-ends besides the one running verifiable logic. They would be used whenever the application doesn’t need a service to be decentralized and trustless, such as providing fast and accessible data caches, helping users communicate with each other, or interfacing with other non-blockchain services.
Conversely, it is also possible for complex DApps to provide more than one front-end application, with the goal of supporting different kinds of users and use cases.
Back-end
Front-end
Communication
Other components
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 52---










Introduction | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
The Cartesi Machine is Cartesi's solution for verifiable computation.
It was designed to bring mainstream scalability to DApps and mainstream productivity to DApp developers.
Scalability
​
DApps running exclusively on smart contracts face severe constraints on the amount of data they can manipulate and on the complexity of computations they can perform.
These limitations manifest themselves as exorbitant transaction costs and, even if such costs could somehow be overcome, as extremely long computation times.
In comparison, DApps running inside Cartesi Machines can process relatively unlimited amounts of data, and at a pace over 4 orders of magnitude faster.
This is possible because Cartesi Machines run off-chain, free of the overhead imposed by the consensus mechanisms used by blockchains.
In a typical scenario, one of the parties involved in a DApp will execute the Cartesi Machine off-chain and report its results to the blockchain.
Different parties do not need to trust each other because the Cartesi platform includes an automatic dispute mechanism for Cartesi Machines.
All interested parties repeat the computation off-chain and, if their results do not agree, they enter into a dispute, which the mechanism guarantees to be always won by an honest party against any dishonest party.
To enable this dispute mechanism, Cartesi Machines are executed inside a special emulator that has three unique properties:
Cartesi Machines are 
self contained
 
—
 They run in isolation from any external influence on the computation;
Cartesi Machines are 
reproducible
 
—
 Two parties performing the same computation always obtain exactly the same results;
Cartesi Machines are 
transparent
 
—
 They expose their entire state for external inspection.
From the point of view of the blockchain, the disputes require only a tiny fraction of the amount of computation performed by the Cartesi Machine.
Dispute resolution thus becomes an ordinary task and dishonest parties are generally expected to be exposed, which discourages the posting of incorrect results and further increases the efficiency of the platform.
Cartesi Machines allow DApps to take advantage of vastly increased computing capabilities off-chain, while enjoying the same security guarantees offered by code that runs natively as smart contracts.
This is what Cartesi means by scalability.
Productivity
​
Scalability is not the only impediment to widespread blockchain adoption.
Another serious limiting factor is the reduced developer productivity.
Modern software development involves the combination of dozens of off-the-shelf software components.
Creating these components took the concerted effort of an active worldwide community over the course of several decades.
They have all been developed and tested using well-established toolchains (programming languages, compilers, linkers, profilers, debuggers, etc.), and rely on multiple services provided by modern operating systems (memory management, multi-tasking, file systems, networking, etc.).
Smart contracts are developed using ad-hoc toolchains, and run directly on top of custom virtual machines, without the support of an underlying operating system.
This arrangement deprives developers of the tools of their trade, severely reduces their expressive power, and consequently decimates their productivity.
In contrast, Cartesi Machines are based on a proven platform: 
RISC-V
.
RISC-V was born of research in academia at UC Berkeley.
It is now maintained by its own independent foundation.
Unlike many of its academic counterparts, it is important to keep in mind that RISC-V is not a toy architecture.
It is suitable for direct native hardware implementation, which is indeed currently commercialized by a large (and ever-increasing) number of 
vendors
.
This means that, in the future, Cartesi will not be limited to emulation or binary translation off-chain.
The RISC-V platform is supported by a vibrant community of developers.
Their efforts have produced an extensive software infrastructure, most notably ports of the Linux Operating System and the GNU toolchain.
By moving key parts of their DApp logic to run inside Cartesi Machines, but on top of the Linux Operating System, developers are isolated not only from the limitations and idiosyncrasies of specific blockchains, but also from irrelevant details of the Cartesi Machine architecture itself.
They regain access to all the tools they have come to rely on when writing applications.
This is Cartesi's contribution to empowering DApp developers to express their creativity unimpeded, and to boost their productivity.
What's in a machine
​
All the components needed to create and run Cartesi Machines are distributed in the 
Emulator SDK
.
Cartesi Machines are separated into a processor and a board.
The processor performs the computations, executing the traditional fetch-execute loop while maintaining a variety of registers.
The board defines the surrounding environment with an assortment of memories (ROM, RAM, flash drives, memory ranges) and a number of devices.
Memories and devices are mapped to the 64-bit physical address space of the Cartesi Machine.
The amount of RAM, as well as the number, length, and position of the flash drives and memory ranges in the address space can be chosen according to the needs of each particular application.
The Cartesi Machine emulator is a program that carefully implements the Cartesi Machine architecture so that its executions are reproducible.
It can be built in the 
/emulator
 directory of the Emulator SDK.
The initialization of a Cartesi Machine loads a ROM image, a RAM image, and a root file-system (as a flash drive) from regular files in the host file-system.
Execution starts from the ROM image, which contains a simple program that creates a description of the machine organization for the Linux kernel.
The ROM image 
rom.bin
 can be built in the 
rom/
 directory in the Emulator SDK.
The Linux kernel itself resides in the RAM image 
linux.bin
, built in the 
kernel/
 directory in the Emulator SDK.
After it is done with its own initialization, the Linux kernel cedes control to the 
/sbin/init
 program in the root file-system.
The root file-system 
rootfs.ext2
 contains all the data files and programs that make up an embedded Linux distribution.
It can be built in the 
fs/
 directory in the Emulator SDK.
The components of the target application can reside in the root file-system itself, or in their own, separate file-systems.
The emulator can be instructed to execute whatever command is necessary to start the target application.
For a complete description of the Cartesi Machine architecture and the boot process, see the documentation for 
the target perspective
.
There are two distinct modes of operation.
In the first mode, a Cartesi Machine is initialized and tasked to run a target application until the machine 
halts
.
Inputs for the target application can be provided as additional flash drives.
Likewise, outputs can be sent to their own flash drives.
(These drives can contain entire file-systems or can contain raw data.)
Outputs are only available to the host after the machine halts.
Once it halts, the machine cannot perform any additional computations.
In the second mode of operation, the target application runs in a loop.
In each iteration, it obtains a request carrying an input, performs any necessary computations to service the request, and produces a number of responses.
After producing each response, the target application asks the machine to 
yield
 control back to the host.
The host extracts the response and 
resumes
 the machine.
When done with a given input, the target application once again asks the machine to yield control back to the host.
The host then prepares the input for the next request, and 
resumes
 the machine so the target application can service the next request in a new iteration of its loop.
Inputs and responses are transferred in special memory ranges (
rollup
 memory ranges).
Whatever state changes happen during the processing of a request will remain in effect when the next request is processed.
Indeed, this is much like a server in which the target application can interact with the outside world.
We say that a Cartesi Machine operating in this mode is a 
Rolling Cartesi Machine
.
Rolling Cartesi Machines and Cartesi Rollups
​
The stringent demands of reproducibility prevent a Cartesi Machine from communicating 
directly
 with the outside world.
Indeed, if two parties were to run the same Cartesi Machine and then disagree on the data each instance independently obtained from a network connection, there would be no way to settle their dispute.
Instead, Rolling Cartesi Machines communicate with the outside world under controlled conditions, through 
Cartesi Rollups
.
In a nutshell, Cartesi Rollups uses the blockchain to maintain a public record of requests made to advance the state of a Rolling Cartesi Machine.
Both the order and the inputs carried by these requests are recorded and made available in an indisputable fashion.
Since Cartesi Machines are deterministic, and since the inputs are agreed upon, the state of a Rolling Cartesi Machine can be advanced in a well-defined way, always producing the same set of responses, no matter who runs it.
Advancing the state of a Rolling Cartesi Machine can produce four types of response: 
vouchers
, 
notices
, 
reports
, and

exceptions
.
Vouchers allow a Rolling Cartesi Machine to interact back with the blockchain.
A voucher issued by the target application may, for example, grant a user the right to withdraw tokens locked into a custodial smart contract.
Notices are used to register noteworthy changes to the state of the target application.
A notice may be issued, for example, announcing the demise of a character in a game.
Disputes over the fact that a voucher or notice has been generated while advancing the state of a Rolling Cartesi Machine can be settled by Cartesi Rollups.
Reports, in contrast, are used to output any data that is irrelevant to the blockchain.
A report may, for example, provide diagnostic information on the reasons why an input has been rejected.
Finally, an exception is used to signal an irrecoverable error encountered by the target application.
It is also possible to inspect the state of a local Rolling Cartesi Machine, without modifying it.
State inspection produces only reports and exceptions.
Documentation
​
Cartesi Machines can be seen from 3 different perspectives:
The host perspective
 
—

This is the environment right outside the Cartesi Machine emulator.
It is most relevant to developers setting up Cartesi Machines, running them, or manipulating their contents.
It includes the emulator's API in all its flavors: C, C++, Lua, gRPC, and the command-line interface;
The target perspective 
 
—

This is the environment inside the Cartesi Machine.
It encompasses Cartesi's particular flavor of the RISC-V architecture, as well as the organization of the embedded Linux Operating System that runs on top of it.
It is most relevant to programmers responsible for the DApp components that run off-chain but must be verifiable.
The cross-compiling toolchain, and the tools used to build the Linux kernel and the embedded Linux root file-systems are also important from this perspective, even though they are used in the host;
The blockchain perspective
 
—

This is the view smart contracts have of Cartesi Machines.
It consists almost exclusively of the manipulation of cryptographic hashes of the state of Cartesi Machines and parts thereof.
In particular, using only hash operations, the blockchain can verify assertions concerning the contents of the state, and can obtain the state hash that results from modifications to the state (including the execution of RISC-V instructions).
As with every computer, the level of knowledge required to interact with Cartesi Machines depends on the nature of the application being created.
Simple applications will require target developers to code a few scripts invoking pre-installed software components, require host developers to simply fill out a configuration file specifying the location of the components needed to build a Cartesi Machine, and require blockchain developers to simply instantiate one of the high-level contracts provided by Cartesi.
At the other extreme are the developers working inside Cartesi, who regularly write, build, and deploy custom software components to run in the target, or even change the Linux kernel to support Cartesi-specific devices. Additionally, these developers programmatically control the creation and execution of Cartesi Machines in the host, and must also understand and use the hash-based state manipulation primitives the blockchain needs.
Although Cartesi's goal is to shield platform users from as much complexity as possible, there is value in making information available to the greatest feasible extent. To that end, this documentation of Cartesi Machines aims to provide enough information to cover all 3 perspectives, at all depths of understanding.
Scalability
Productivity
What's in a machine
Rolling Cartesi Machines and Cartesi Rollups
Documentation
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 53---










Run a private node | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
In this guide, you will learn how to run your own Cartesi node and participate in the staking system. By running a node and staking, you will receive CTSI rewards from Cartesi’s Mine Reserve for each block you produce.
The staking system runs on top of Ethereum. Each block is claimed on-chain by its producer, requiring the node to spend gas to execute the corresponding transaction. As you set up a node to produce blocks for you, you need to fund it with enough ETH to complete the setup and also to produce blocks for some time. You can find the cost associated with each required transaction on Ethereum in the 
FAQ
Prerequisites
​
The main prerequisites are:
Set up Ethereum node as the Cartesi node connects to the Ethereum network through a standard gateway. The Ethereum node works with any standard JSON-RPC Ethereum provider. It's important to use a stable and reliable provider, you can use 
Infura
 or 
Alchemy
 as Ehtereum gateway
Install Docker enginer, you can download it for 
macOS
 or for 
Windows
If your node is down, offline, or with insufficient ETH funds, you will fail to produce blocks and therefore be unable to gain rewards. However, there is no slashing due to any node failure at the moment. Your principal is never at risk and you can always recover it from the staking contract at any time by using the Cartesi Explorer and the wallet you used to stake.
All rewards associated with blocks that your node produces are directly distributed to your personal ERC-20 wallet and therefore not subject to any locking.
Steps to run a private node
​
Navigate to our 
Staking Portal
Click on the button "CONNECT TO WALLET" 
Navigate to the 
Node Runners
 option in the top menu
Click on the button "CREATE MY NODE" 
Navigate to the section 
Create a Node
 and make sure to follow all required steps
Prerequisites
Steps to run a private node
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 54---










The Blockchain OS | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Cartesi
, The Blockchain OS, is a layer-2 platform for the development and deployment of scalable decentralized applications. The 
Blockchain OS
 offers a Linux operating system coupled with a blockchain infrastructure, which allows DApps to be developed in familiar programming languages like Python without the need to write Solidity code.
Limitations, develop with The Blockchain OS!
​
Other blockchain platforms do not allow you to develop a DApp that uses a file-system, an SQL database or a machine learning model. Generally there are also harsh limitations related to gas limits and high fees when performing computations such as looping over arrays and manipulating strings, which are commonplace in regular mainstream applications.
Today there is a large number of developers and companies who want to enter the blockchain world but face a steep learning curve and a confusing landscape. Cartesi solves this with The Blockchain OS, so that you can develop a DApp using any traditional software stack.
Here comes the mission of Cartesi:
To offer a full operating system for blockchain applications.
To solve the 
scalability problem
 using Optimistic Rollups along with the Cartesi Machine to support complex computations.
To develop DApps of arbitrary complexity using mainstream development tools and software stacks, and have all of it sit on top of established blockchain networks such as Ethereum, Polygon, Avalanche and BNB Smart Chain.
Cartesi, The Blockchain OS provides lower gas and crypto costs. Additionally, if you are a web developer and you want to build a simple application as your first step in blockchain development, with Cartesi you will not be forced to use a specific language, such as Solidity for Ethereum, nor be forced to reinvent the wheel because a given functionality or math library is not available.
How are Cartesi Rollups different?
​
Most current general-purpose rollups layer 2 solutions, such as 
those based on Optimistic Rollups
, strive to be EVM-compatible because they are focusing on providing lower transaction costs and higher throughputs for the smart contracts that already run on Ethereum. However, Cartesi focuses on providing a true operating system for blockchain developers, allowing them for the first time to leverage decades of software development from the mainstream industry. With that goal in mind, 
Cartesi Rollups
 not only solves the scalability problem by using an Optimistic Rollups framework, but also takes advantage of the 
Cartesi Machine Emulator
 to boost productivity and application complexity by allowing developers to code their smart contracts using any software stack that is already available for Linux.
You can think of Cartesi Rollups as a special operating system that makes your life easier, allowing you to create computationally heavy DApps while providing you with the freedom to choose the programming languages, libraries and tools of your preference. At Cartesi, we believe that this freedom will help start a new era for blockchain application development.
See Also
​
Why Cartesi Rollups is Unique
Rollups On-Chain
Cartesi Node
Testnet
Transaction Manager
State Fold
Limitations, develop with The Blockchain OS!
How are Cartesi Rollups different?
See Also
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 55---










8 docs tagged with "learn" | Blockchain OS Documentation - Cartesi
























Skip to main content
Choose your Onboarding Path
Our onboarding paths answer the following questions:
Components
As explained in the previous section, the Cartesi Rollups framework achieves scalability by moving the bulk of the computation outside the blockchain, using the ledger as a data source but not as an execution environment. As such, the solution contains both on-chain (layer-1) and off-chain (layer-2) components.
DApp architecture
Borrowing from familiar mainstream terminology, from a developer’s point of view a Cartesi DApp is developed by implementing two main components: a front-end and a back-end.
DApp life cycle
Now that we have described the architecture of a Cartesi DApp and how the front-end and back-end communicate with the Cartesi Rollups framework, let’s step back a bit to discuss how a DApp can be implemented in practice.
Overview
The combination of an Optimistic Rollups framework and the Cartesi Machine Emulator enables the development of smart contracts and DApps using any package or library that is available for Linux. This allows developers to break free from the scalability limitations of the Ethereum Virtual Machine (EVM), and brings the rise of a new blockchain era to handle real-life and complex use-cases.
Rollups HTTP APIs
In a Cartesi DApp, the front-end and back-end parts of the application communicate with each other through the Rollups framework via a set of HTTP APIs.
Scalability
The scalability issue is one of the three parts of the Blockchain Trilemma, along with security and decentralization. Solving the scalability issue refers to any type of improvement within a blockchain system in terms of computational power, throughput, latency, bootstrap time, or cost per transaction. For example, high gas fees make it expensive for users to pay for their transactions within the Ethereum blockchain.
The Blockchain OS
Cartesi, The Blockchain OS, is a layer-2 platform for the development and deployment of scalable decentralized applications. The Blockchain OS offers a Linux operating system coupled with a blockchain infrastructure, which allows DApps to be developed in familiar programming languages like Python without the need to write Solidity code.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 56---










Verification game | Blockchain OS Documentation - Cartesi
























Skip to main content
EDITOR NOTE
This section is still under construction.
Meanwhile, for details on how the verification game works, please refer to our 
technical paper
.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 57---










Blockchain perspective | Blockchain OS Documentation - Cartesi
























Skip to main content
Introduction
This section describes Cartesi Machines from the perspective of the blockchain.
Hash view of state
One of the key goals of moving computations off-chain is to allow them to manipulate vast amounts of data: so much data that it becomes economically prohibitive to explicitly store them in the blockchain.
Verification game
This section is still under construction.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 58---










Scalability | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
The scalability issue is one of the three parts of the 
Blockchain Trilemma
, along with security and decentralization. Solving the scalability issue refers to any type of improvement within a blockchain system in terms of computational power, throughput, latency, bootstrap time, or cost per transaction. For example, high gas fees make it expensive for users to pay for their transactions within the Ethereum blockchain.
Given scalability has many different aspects, there are numerous alternative and often complementary solutions for tackling it. For instance, scaling the blockchain throughput (i.e., the number of transactions that can be processed over a period of time) can be achieved by increasing block size, reducing block interval, or other improvements to the consensus protocol such as breaking down transactions into smaller partitions (shards) to process them in parallel.
Proposed blockchain scaling solutions include Lightning Network, Ethereum Plasma, sharding, and off-chain (layer-2) protocols.
note
You can read the article 
Layer-1 and Layer-2 Blockchain Scaling Solutions
 to explore more scaling solutions.
Layer-2 solutions and the connection with rollups
​
A 
layer-2 protocol
 is a scaling solution in the sense that it scales blockchains without changing the layer-1 trust assumptions and without extending or replacing the consensus mechanism. This protocol reduces the transaction load on the underlying blockchain and allows users to execute off-chain transactions via private and authenticated communication instead of broadcasting every single transaction on the main layer-1 blockchain system.
A layer-2 protocol inherits two properties from the blockchain layer (layer-1):
Integrity that guarantees only valid transactions to be added to the blockchain ledger
Eventual synchronicity with an upper time-bound. For example, a valid transaction is eventually added to the blockchain ledger, before a critical timeout.
In general, layer-2 protocols belong to one of the following four categories:
Channels
 that are fully secured by a blockchain system such as Ethereum and work only for a specific set of applications.
Commit-chains
 that rely on one central intermediary who is trusted regarding availability
Side-chains
 that are usually EVM-compatible and can scale general-purpose applications, but are less secure because they do not rely on the security of the underlying blockchain and thus create their own consensus models.
Rollups
 that aim to achieve the best of all the above, and are described in more detail in the 
Cartesi Rollups overview section
.
See Also
​
How to truly tackle blockchain’s scalability problem
Layer-2 solutions and the connection with rollups
See Also
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 59---










8 docs tagged with "quickstart" | Blockchain OS Documentation - Cartesi
























Skip to main content
Choose your Onboarding Path
Our onboarding paths answer the following questions:
Deploying DApps
Please check the full documentation for deploying Rollups DApps to Cartesi's cloud-based execution infrastructure.
Overview of building DApps
Navigate to our Quick Start tutorial if you want to build DApps now!
Putting Things Together
To better understand how Cartesi Compute can be used, imagine the following simple Cartesi DApp with one claimer and one challenger. The DApp can be a skill-based game where players place their bets and challenge each other for the highest score over the blockchain. The winner takes the pot.
Quick Start
This article explains how to build and interact with a minimalistic Cartesi Rollups application.
Run back-end in Host Mode
When developing an application, it is often important to easily test and debug it. For that matter, it is possible to run the Cartesi Rollups environment in host mode, so that the DApp's back-end can be executed directly on the host machine, allowing it to be debugged using regular development tools such as an IDE.
Scalability
The scalability issue is one of the three parts of the Blockchain Trilemma, along with security and decentralization. Solving the scalability issue refers to any type of improvement within a blockchain system in terms of computational power, throughput, latency, bootstrap time, or cost per transaction. For example, high gas fees make it expensive for users to pay for their transactions within the Ethereum blockchain.
The Blockchain OS
Cartesi, The Blockchain OS, is a layer-2 platform for the development and deployment of scalable decentralized applications. The Blockchain OS offers a Linux operating system coupled with a blockchain infrastructure, which allows DApps to be developed in familiar programming languages like Python without the need to write Solidity code.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 60---










Homepage | Blockchain OS Documentation - Cartesi
























Skip to main content
Welcome to Cartesi docs.
Rollups
Browse our DApp tutorials, API references, and more to learn how to build on Cartesi.
Machine
Deep dive into the low level of Cartesi's core technology.
Staking
View and analyse assets, transactions and balances on the Cartesi network.
Learn
by goal
by role
by-goal
by-role
by product
Hands-on: Build Rollups DApps Now!
Step 1: Installing
Step 2: Building
Step 3: Running
Step 4: Interacting
Step 5: Deploying
Deep Dive: Explore the Cartesi Machine
Introduction to the Cartesi Machine
Setting up and running Cartesi Machines
Cartesi Machines from the inside: Linux environment and system architecture
How blockchains can benefit from Cartesi Machines
Beginner
New to Cartesi
Understand how Cartesi Rollups are different
Brief overview of The Blockchain OS
Understand the scalability problem
Developer
Onboarding path
Install technical prerequisites
Quick start to run an existing DApp
Create your first DApp
Run your DApp off-chain
Explore DApp architecture
Explore DApp life cycle
Researcher & Low-level developer
Introduction to the Cartesi Machine
Setting up and running Cartesi Machines
Cartesi Machines from the inside: Linux environment and system architecture
How blockchains can benefit from Cartesi Machines
Get Help
Feeling stuck? Don’t worry, come join us over on Discord or StackOverflow and connect with our core developers who’ll be happy to help.
Ask a question or learn from others:
Discord
StackOverflow
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 61---










Rollups HTTP APIs reference | Blockchain OS Documentation - Cartesi
























Skip to main content
Front-end APIs
3 items
Back-end API
6 items
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 62---










How to stake | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Prerequisites
​
First, you need to have 
Metamask installed
 or other crypto wallets such as Ledger, Coinbase wallet or using WalletConnect.
Staking delegation guide
​
Navigate to our 
Staking Portal
.
Click on the button 
CONNECT TO WALLET
 
.
Navigate to the 
Stake
 option in the top menu 
.
Now you should see the screen below with a different list of pools: 
.
Select a pool to delegate your stake and earn rewards. In the example below, we selected the 
first pool
. 
Navigate to the tab 
Stake
.
Click on the button 
Deposit
. 
Set an allowance for that particular pool, click on the button 
APPROVE
, and then confirm the transaction via Metamask. The allowance is the maximum amount of tokens the pool smart contract can transfer out of your wallet. You can set it to any value you want: equal to/larger than/less than the wallet amount. 
Click again on the button 
Deposit
 to specify the amount of CTSI tokens that you want to deposit to the pool and then confirm the transaction via Metamask. 
You should see results similar to the following: 
Finally, click on the button 
Stake
 to specify the amount of CTSI tokens that you want to delegate and then confirm the transaction via Metamask. 
From now on, for every block the pool produces you will get a share of the reward minus the commission taken by the pool. The rewards are automatically compounded.
Congratulations, you have successfully completed the staking process!
Unstaking
​
Whenever you decide, you can unstake a specific amount of your tokens or all of them and withdraw the tokens back to your wallet. You just need to navigate to the particular pool page and click on the button 
Unstake
:

Prerequisites
Staking delegation guide
Unstaking
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 63---










Rollups HTTP APIs | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
In a Cartesi DApp, the front-end and back-end parts of the application 
communicate with each other through the Rollups framework
 via a set of HTTP APIs.
When designing the APIs for this communication with the framework, we wanted to ensure developers could create their applications without worrying too much about the idiosyncrasies of blockchain technology or our rollups solution. In particular, we wanted to allow the back-end code to abstract away whether it was running inside a specific virtual machine or not.
With this in mind, we decided to offer APIs on top of HTTP as a convenience layer for this communication, leveraging a well-known and ubiquitous standard instead of having applications deal with any kernel-level or VM-specific devices, or having to understand how our rollups solution encodes and decodes data.
Back-end API
​
The DApp's back-end interacts with the Cartesi Rollups framework by retrieving processing requests and then submitting corresponding outputs. This is accomplished by calling a set of HTTP endpoints, as illustrated by the figure below:
First, the back-end retrieves a new request as follows:
Finish
 — Communicates that any previous processing or initialization has been completed, and that the back-end is now ready to handle the next request. This next request is itself returned as the call's response, and can be of the following types:
AdvanceState
 — Provides an input to be processed by the back-end in order to advance the application's state. When processing an AdvanceState request, the back-end can call the methods 
AddVoucher
, 
AddNotice
 and 
AddReport
, as detailed below. For such requests, the input data contains the payload and some metadata, such as the account address that submitted the input.
InspectState
 — Submits a query about the application's current state. When running inside a Cartesi Machine, this operation is guaranteed to leave the state unchanged, since the machine is reverted to its exact previous condition after processing is completed. For 
InspectState
 requests, the input data contains only a payload.
As the back-end processes each request, it can access a set of HTTP endpoints provided by the Rollups framework to inform it of the computed results and consequences, as shown below:
AddVoucher
 — Called to specify a collateral effect in the form of a transaction that can be carried out on layer-1 (e.g., a transfer of ERC-20 tokens). The back-end can only add new vouchers when processing an 
AdvanceState
 request.
AddNotice
 — Provides information in a form that can be verified by any third-party on layer-1. This can be used to notify about a new relevant state of the application, such as updated player rankings. As vouchers, notices can only be added when processing an 
AdvanceState
 request.
AddReport
 — Outputs arbitrary data in a non-provable form. This can be used to return results of 
InspectState
 calls, or to provide diagnostics and logs associated with the processing of any request.
As noted before, after each request is handled the back-end should always call 
Finish
 to notify that processing is complete, and retrieve as response the subsequent request to be processed. This call will also inform the request's final status as either "accept" or "reject". If an 
AdvanceState
 request is rejected, any vouchers and notices generated during its processing are discarded. On top of that, when the back-end is running inside a Cartesi Machine the Rollups framework will completely revert the machine to its previous state, so that rejected inputs have absolutely no effect on the application's subsequent behavior. Reports, on the other hand, are not discarded when a request is rejected, and can still be used for logging purposes.
It should also be noted that 
AdvanceState
 requests can originate both from the front-end or directly from a layer-1 smart contract. In particular, when a Cartesi DApp is deployed, the Rollups framework ensures that the very first request is an initial or 
setup
 input submitted by the application itself. This request's purpose is to securely inform the back-end of the DApp's configuration, such as its address on layer-1. This information is relevant for the back-end to be able to safely distinguish subsequent messages sent by the framework itself (such as deposit notifications) from any user-specified inputs.
Finally, it should be noted that the back-end API also provides a 
RegisterException
 endpoint to allow the DApp to inform that it has reached an unrecoverable state and cannot proceed with any further request processing. This effectively communicates that the DApp will no longer function, and as such represents the last method ever called by the back-end, which should not even expect the call to return.
tip
The complete specification for these endpoints can be found in the 
Rollups HTTP APIs reference
.
Front-end APIs
​
The front-end part of the DApp needs to access the Cartesi Rollups framework to submit user requests and retrieve the corresponding outputs produced by the back-end. The following figure and table detail some of the main use cases for these interactions:
AddInput
 — Submits input data to the 
Rollups smart contracts
 on layer-1 as a regular 
JSON-RPC blockchain transaction
. When that transaction is mined and executed, an event is emitted containing the submitted input’s identifier (
Input ID
), which the front-end can later use to query associated outputs. In the future, there will also be support for sending inputs via an aggregator service.
QueryOutputs
 — Submits a query to a layer-2 node to retrieve vouchers, notices and reports, as specified by the 
Cartesi Rollups GraphQL schema
.
InspectState
 — Submits a query to a layer-2 node to retrieve arbitrary DApp-specific application state. Note that this endpoint is not yet available at the time of writing.
ExecuteVoucher
 — Submits a JSON-RPC blockchain transaction to request a given voucher to be executed by the 
Rollups smart contracts
 on layer-1. This is how a DApp’s results, such as a transfer of assets, can take effect on the underlying blockchain. It should be noted that the contracts will only actually execute the voucher if it has been finalized, meaning that its contents can no longer be disputed. Finalization is explained in more detail in the 
Cartesi Rollups Components section
 and in the 
Rollups On-Chain article
.
tip
The complete specification for these front-end APIs, including additional endpoints, can be found in the 
Rollups HTTP APIs reference
.
Back-end API
Front-end APIs
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 64---










Components | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
As explained in the 
previous section
, the Cartesi Rollups framework achieves scalability by moving the bulk of the computation outside the blockchain, using the ledger as a data source but not as an execution environment. As such, the solution contains both on-chain (layer-1) and off-chain (layer-2) components.
note
In this section, we describe the internal components of the Cartesi Rollups framework in more detail, to clarify how the system works inside. DApp developers may chose to skip directly to the 
DApp architecture
 section to understand how to build applications.
Main concepts
​
Cartesi Nodes
​
As explained before, 
Cartesi Machines
 provide DApp developers with an environment in which large scale verifiable computations can be executed. These machines are integrated with the on-chain smart contracts by a 
middleware
 that manages and controls the communication between them. As such, this middleware is responsible for first reading data from the layer-1 smart contracts, then sending them to the machine to be processed, and finally publishing their results back to the blockchain.
The 
Cartesi Node
 is the layer-2 component that consists of the combination of the Cartesi Machine and this middleware, and can be used by anyone interested in the rollups state of affairs. Put simply, Cartesi Nodes play a role that is similar to what Geth does on the Ethereum ecosystem: execution and retrieval of information.
In practice, there are two distinct kinds of agents that run Cartesi Nodes: 
users
 and 
validators
. Each of them interacts with the on-chain rollups in different ways, and thus run different types of Cartesi Nodes:
User or Reader Nodes
, which are only involved in advancing the state of the off-chain machine, and making that state publicly available. They consume information from the blockchain but do not bother to enforce state updates, trusting that validators will ensure the validity of all on-chain state updates.
Validator Nodes
, which have more responsibility: they not only watch the blockchain but also fight possible dishonest validators to ensure the prevalence of honest claims for state updates. On the other hand, if Reader Nodes are available, validators do not need to expose endpoints for retrieving application state. Therefore, they can run in more secure environments and remain inaccessible to external clients and users.
Epochs
​
In order to avoid over interacting with the blockchain, validators don't checkpoint every new state update on the off-chain machine. They do it at the end of an 
epoch
, which are batched inputs that follow the same cycle.
We can imagine epochs in three different states:
Accumulating
, when the epoch is open and waiting for inputs.
Sealed
, when the inputs for that epoch are well defined and the validators are preparing to send their claims. Sealed epochs can also be under dispute.
Finalized
, when consensus was reached and the outputs can be safely executed.
The on-chain state, depending on what phase it is, can contain one or two epochs, as illustrated by the diagram below.
Input Accumulation
: there is a single accumulating epoch, active and waiting for the inputs it is going to batch.
Awaiting Consensus
: there are two epochs. A sealed one, for which validators are preparing to or sending their claims, and an accumulating one, which is active and receiving inputs.
Awaiting Dispute
: there are also two epochs. A sealed one and an accumulating one. The sealed epoch is under dispute. At least two conflicting claims were received and the validators are enrolling in a verification game to decide which claim stands. Since the sealed epoch's inputs are well defined, honest validators will always reach the same claim. A dispute necessarily means that a claim is provably false.
To better understand the whole process on a timeline, let's describe how the system schedules different rollups phases.
On a given epoch N, the involved validator nodes batch all the input messages that were enqueued on-chain from the beginning of the previous 
epoch’s processing
 slot until the beginning of the current epoch’s 
processing slot
.
The nodes then process every message of the batch through the Cartesi Machine, producing an output hash that summarizes the state transition of the entire epoch. Then, one of the validators, henceforth called 
claimer
, places on-chain the hash representing the layer-2 contract state at the end of epoch N, 
S(N)
.
After a challenge period is over, if there was no dispute, 
S(N)
 is assumed final by the system. Otherwise, disputes will follow until the correct state claim represented by its output hash is enforced. The 
settlement period
 displayed on the diagram above accounts for a 
challenge period
, with or without disputes.
To guarantee a minimum duration for each epoch, the rollups protocol also requires an 
accumulation slot
. This is a minimal latency imposed on on-chain finalization to prevent frequent claims being sent to layer-1, for the sake of Ethereum fee cost-effectiveness. The rollup developer can configure a specific accumulation slot period for their application to accommodate eventual specific requirements for balancing latency to finality and security.
Vouchers
​
A 
voucher
 is a combination of a target address and a payload in bytes. It is used by the off-chain machine to respond and interact with layer-1 smart contracts. Upon execution, a voucher sends a message to the target address with the payload as a parameter. Vouchers can be used for anything, ranging from providing liquidity in a DeFi protocol to withdrawing funds from the 
Portal
. Vouchers can only be executed when the epoch in which they are contained is 
finalized
, at which point a 
validity proof
 will be available to ensure layer-1 smart contracts can trust its content.
Notices
​
A 
notice
 is an arbitrary payload in bytes that is submitted by the off-chain machine for informational purposes. Similarly to vouchers, when the epoch containing a notice is finalized a proof will be produced so that the validity of the notice's content can be verified on-chain by any interested party.
Reports
​
A 
report
 is an application log or a piece of diagnostic information. Like a notice, it is represented by an arbitrary payload in bytes. However, a report is never associated with a proof and is thus not suitable for trustless interactions such as on-chain processing or convincing independent third parties of DApp outcomes. Reports are commonly used to indicate processing errors or to retrieve application information for display.
On-chain components
​
These consist of the Cartesi Rollups smart contracts that were designed to mediate the relationship of the off-chain components with other smart contracts and externally owned accounts. They include several modules, each with clear responsibilities and well-defined interfaces.
Cartesi Rollups Manager
​
The 
Cartesi Rollups Manager
 is responsible for synchronicity between the modules. It defines the duration of the different phases and notifies the other modules of any phase change. Among others, the responsibilities of this module are:
Define to which epoch an input is destined, depending on the current state and deadlines.
Receive and forward claims to the Validator Manager.
Forward disputes to the Dispute Resolution module.
Forward the result of disputes to the Validator Manager.
Forward the summary of finalized outputs (vouchers and notices) to the Output module.
Notify other modules of phase changes.
Input contract
​
As discussed above, the on-chain contracts often have two concurrent epochs: a sealed but unfinalized epoch, and an accumulating one. The 
Input contract
 keeps one inbox for each of those epochs, switching between them depending on the Cartesi Rollups Manager's notifications.
For anyone to be able to synchronize the machine from its beginning without needing to trust a data provider, the full content of inputs is always present in calldata on the blockchain. In on-chain storage, which needs to be used in a more parsimonious way, we keep a single hash for each input of an active epoch.
This input hash summarizes both the input itself and its metadata, which corresponds to the sender's address and the time of reception. Notice that this input implementation is permissionless: the permission layer is delegated to the off-chain machine which will, for example, judge if a sender is allowed to do what their input wants to do.
Output contract
​
Each input can generate a number of notices and vouchers that will have an accompanying 
validity proof
 available once the epoch containing them is finalized. These proofs can be used with the 
Output contract
 to execute vouchers or verify the validity of a notice's content.
For vouchers, while the Output contract is indifferent to their content, it does enforce some sanity checks before allowing their execution, since vouchers are unique and can only be successfully executed once. Vouchers are executed asynchronously and don't require an access check, and the order of execution is not enforced. As long as vouchers are contained in a finalized epoch and were not executed before, the contract will allow their execution by anyone.
Portal
​
The Portal, as the name suggests, is used to teleport assets from the Ethereum blockchain to DApps running on Cartesi Rollups. Once deposited, those layer-1 assets gain a representation in layer-2 and are owned, there, by whomever the depositor assigned them to. After being teleported, layer-2 assets can be moved around in a significantly cheaper way, using simple inputs that are understood by the Linux logic.
When an asset is deposited, the Portal contract sends an input to the DApp’s inbox, describing the type of asset, amount, receivers, and some data the depositor might want the DApp to read. This allows deposits and instructions to be sent as a single layer-1 interaction. One could think of the Portal as a bank account, owned by the off-chain machine.
Anyone can deposit assets there but only the DApp — through its Output contract — can decide on withdrawals. The withdrawal process is quite simple from a user perspective. They send an input requesting a withdrawal, which gets processed and interpreted off-chain. If everything is correct, the machine creates a voucher destined to the Portal contract, ordering and finalizing that withdrawal request. Currently, we support the following types of assets:
Ether (ETH)
ERC-20
ERC-721 (NFTs)
Validator Manager
​
The 
Validator Manager
 module was created to help DApps manage their claims, claim permissions, and punishments for bad behavior. Initially, our suggested implementation for this module includes the following characteristics: the set of payable validators is defined in construction time, validators send a claim for every epoch and those that lose a dispute are kicked off the validators set.
The 
Cartesi Rollups Manager
 receives claims and redirects them to the Validator Manager. When receiving a claim, the Validator Manager checks which other claims have arrived at that epoch and returns the information that Cartesi Rollups Manager needs to continue. The module can respond to received claims in one of the following ways:
If the sender is not a validator or the claim is invalid, the transaction reverts.
If the claim is valid, doesn’t disagree with any of the other claims in the epoch, and does not generate consensus, it returns a "No Conflict" response.
If the claim is valid but disagrees with another claim for that epoch, it warns the Cartesi Rollups Manager that a conflict is happening and what are the conflicting claims and claimants involved. When that dispute is resolved the Validator Manager module gets notified so it can deal however it likes with the validators involved. In our initially suggested implementation, the loser of a dispute is removed from the validator set.
If the claim is valid, agrees with all other claims in that epoch, and is the last claim to be received, it lets Cartesi Rollups know that consensus was reached. This allows the rollups DApp to finalize the epoch and allow for the execution of its vouchers. Regardless of what the name might suggest, validators do not interact with this module at all.
Fee Manager and Bank
​
The 
Fee Manager facet
 and 
Bank contract
 aim to create an economical incentive for validators to run a given DApp. When you develop an application, you will need to define two parameters:
A fee to be paid to the validators each time they submit a claim. This fee will be debited from the funds stored in the DApp's Bank contract.
An owner for the Fee Manager facet, who has the option to change the fee value, if needed.
Entities running validator nodes should configure them to either be 
altruistic
 or require a minimum retainer (i.e., a minimum fee to process inputs for the DApp). If they are altruistic, they will work regardless of any financial compensation. On the other hand, non-altruistic validators must ensure that the following two conditions are met before processing inputs and submitting claims:
The fee paid by the DApp must be bigger than their required retainer
The DApp's Bank must have enough funds to pay the validator
The fee value is given in CTSI and is reserved for a validator every time a claim is made. The validator is free to withdraw received CTSI fees at any time of its convenience. While the Fee Manager controls the fee value and the amount of claims made by each validator, the Bank stores - on a separate contract - the CTSI tokens that will be distributed to them.
The code does not enforce a way for the Bank to be funded. Therefore, DApps and communities are free to choose their preferred procedures, such as direct transfer, charging per input, creating a tax system on top of the Portal, or other methods. For convenience, a 
FundBank
 hardhat task is provided which transfers money from the signer to a DApp's Bank.
Dispute Resolution
​
Disputes occur when two validators claim different state updates to the same epoch. Because of the deterministic nature of our virtual machine and the fact that the inputs that constitute an epoch are agreed upon beforehand, conflicting claims imply dishonest behavior. When a conflict occurs, the module that mediates the interactions between both validators is the Dispute Resolution contract.
The code for rollups dispute resolution is not being published yet - but a big part of it is available on the Cartesi Rollups SDK, using the 
Arbitration dlib
.
Off-chain components
​
These consist of the internal modules of the 
Cartesi Node
. As explained before, Cartesi Nodes form the network that sustains the Cartesi Rollups solution, being responsible for executing the computations that arrive and presenting their results to the interested parties.
State Server
​
This service is responsible for ensuring that the remaining modules have access to a consistent view of the state of the blockchain. The service is an instance of  Cartesi's 
State Fold tool
 and monitors all relevant activity from the Cartesi Rollups smart contracts, consolidating the information that gets emitted by the blockchain.
Rollups Dispatcher
​
Responsible for interpreting the current state of the Cartesi Rollups smart contracts, this module informs the 
Server Manager
 about any incoming inputs and, in the case of Validator Nodes, also submits transactions to layer-1 corresponding to state update claims. It will also handle any disputes should they arise.
Server Manager
​
This module manages the Cartesi Machine, sending inputs to it and reading the produced outputs. It is responsible for starting and stopping the machine as appropriate, as well as providing an API for the other modules to query the machine's state.
The 
Host Server Manager
 is an alternative implementation of the Server Manager for development purposes. It implements the same API and mimics the behavior of an actual Server Manager, but does not in fact instantiate a Cartesi Machine. Instead, it makes HTTP requests directly to a DApp running in the host computer. The Host Server Manager is intended to be used in the 
implementation stage of the DApp life cycle
.
Rollups Indexer
​
This service is responsible for consolidating the state of the Cartesi Node. It queries blockchain information from the 
State Server
 as well as data produced by the DApp back-end through the 
Server Manager
, consolidating everything in a local database.
Query Server
​
Module that provides an externally accessible 
GraphQL API
 for querying the consolidated state of the Cartesi Node, as maintained by the 
Rollups Indexer
. This allows users and client applications to retrieve vouchers, notices and reports produced by the DApp back-end.
Main concepts
Cartesi Nodes
Epochs
Vouchers
Notices
Reports
On-chain components
Cartesi Rollups Manager
Input contract
Output contract
Portal
Validator Manager
Fee Manager and Bank
Dispute Resolution
Off-chain components
State Server
Rollups Dispatcher
Server Manager
Rollups Indexer
Query Server
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 65---










Overview | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Cartesi's reference off-chain implementation of Cartesi Machines is based on software emulation.
The emulator is written in C/C++ with POSIX dependencies restricted to the terminal, process, and memory-mapping facilities.
The 
emulator/
 directory in the 
Emulator SDK
 can be used to build and install the Cartesi Machine emulator.
It is written as a C++ class, but can be accessed in a variety of different ways.
When linked to a C++ application, the emulator can be controlled directly via the interface of the 
cartesi::machine
 class.
C applications can control the emulator in a similar way, by means of a matching C API.
The emulator can also be accessed from the Lua programming language, via a 
cartesi
 module that exposes a 
cartesi.machine
 interface to Lua programs.
Additionally, Cartesi provides a 
gRPC
 server that can run a Cartesi Machine instance that is controlled remotely.
Finally, there is a command-line utility (written in Lua) that can configure and run Cartesi Machines for rapid prototyping.
The C, C++, Lua APIs as well as the command-line utility can seamlessly instantiate local emulators or connect to remote gRPC servers.
The documentation starts from the command-line utility, 
cartesi-machine
.
This utility is used for most prototyping tasks.
The documentation then covers the Lua interface of 
cartesi.machine
.
The C/C++/gRPC interfaces are very similar, and are covered only within their reference manuals.
Machine playground
​
The setup of a new development environment is often a time-consuming task.
This is particularly true in case of cross-development environments (i.e., when the development happens in a host platform but software runs in a different target platform).
With this in mind, the Cartesi team provides the 
cartesi/playground
 Docker image for use while reading this documentation.
The Docker image enables immediate experimentation with Cartesi Machines.
It comes with a pre-built emulator and Lua interpreter accessible within the command-line, as well as a pre-built ROM image, RAM image, and root file-system.
It also comes with the cross-compiler for the RISC-V architecture on which the Cartesi Machine is based.
To enter the playground, open a terminal, download the Docker image from Cartesi's repository, and run it adequately mapping the current user and group information, as well as making the host's current directory available inside the container:
docker
 pull cartesi/playground:0.5.0
docker
 run -it --rm -h playground 
\
    -e 
USER
=
$(
id
 -u -n
)
 
\
    -e 
GROUP
=
$(
id
 -g -n
)
 
\
    -e 
UID
=
$(
id
 -u
)
 
\
    -e 
GID
=
$(
id
 -g
)
 
\
    -v 
`
pwd
`
:/home/
$(
id
 -u -n
)
 
\
    -w /home/
$(
id
 -u -n
)
 
\
    cartesi/playground:0.5.0 /bin/bash
Once inside, you can execute the 
cartesi-machine
 utility as follows:
cartesi-machine --help
Usage:
  /opt/cartesi/bin/cartesi-machine.lua [options] [command] [arguments]
where options are:
  --remote-address=<address>
    use a remote cartesi machine listenning to <address> instead of
    running a local cartesi machine.
    (requires --checkin-address)
  --checkin-address=<address>
    address of the local checkin server to run.
  --remote-shutdown
    shutdown the remote cartesi machine after the execution.
  --no-remote-create
    use existing cartesi machine in the remote server instead of creating a new one.
  --no-remote-destroy
    do not destroy the cartesi machine in the remote server after the execution.
  --ram-image=<filename>
    name of file containing RAM image (default: "linux.bin").
  --no-ram-image
    forget settings for RAM image.
  --ram-length=<number>
    set RAM length.
  --rom-image=<filename>
    name of file containing ROM image (default: "rom.bin").
  --no-rom-bootargs
    clear default bootargs.
  --append-rom-bootargs=<string>
    append <string> to bootargs.
  --no-root-flash-drive
    clear default root flash drive and associated bootargs parameters.
  --flash-drive=<key>:<value>[,<key>:<value>[,...]...]
    defines a new flash drive, or modify an existing flash drive definition
    flash drives appear as /dev/mtdblock[1-7].
    <key>:<value> is one of
        label:<label>
        filename:<filename>
        start:<number>
        length:<number>
        shared
        label (mandatory)
        identifies the flash drive. init attempts to mount it as /mnt/<label>.
        filename (optional)
        gives the name of the file containing the image for the flash drive.
        when omitted or set to the empty, the drive starts filled with 0.
        start (optional)
        sets the starting physical memory offset for flash drive in bytes.
        when omitted, drives start at 2 << 63 and are spaced by 2 << 60.
        if any start offset is set, all of them must be set.
        length (optional)
        gives the length of the flash drive in bytes (must be multiple of 4Ki).
        if omitted, the length is computed from the image in filename.
        if length and filename are set, the image file size must match length.
        shared (optional)
        target modifications to flash drive modify image file as well.
        by default, image files are not modified and changes are lost.
    (an option "--flash-drive=label:root,filename:rootfs.ext2" is implicit)
  --replace-flash-drive=<key>:<value>[,<key>:<value>[,...]...]
  --replace-memory-range=<key>:<value>[,<key>:<value>[,...]...]
    replaces an existing flash drive or rollup memory range right after
    machine instantiation.
    (typically used in conjunction with the --load=<directory> option.)
    <key>:<value> is one of
        filename:<filename>
        start:<number>
        length:<number>
        shared
    semantics are the same as for the --flash-drive option with the following
    difference: start and length are mandatory, and must match those of a
    previously existing flash drive or rollup memory memory range.
  --dhd=<key>:<value>[,<key>:<value>[,...]...]
    configures the dehashing device.
    by default, the device is not present.
    <key>:<value> is one of
        filename:<filename>
        tstart:<number>
        tlength:<number>
        filename (optional)
        gives the name of the file containing the initial dehashed data.
        when omitted or set to the empty, the data starts filled with 0.
        tstart (mandatory when device present)
        sets the start of target physical memory range for output data.
        must be aligned to tlength.
        tlength (mandatory when device present)
        gives the length of target physical memory range for output data.
        must be a power of 2 greater than 4Ki, or 0 when device not present.
  --dhd-source=<address>
    address of server acting as source for dehashed data.
  --rollup-rx-buffer=<key>:<value>[,<key>:<value>[,...]...]
  --rollup-tx-buffer=<key>:<value>[,<key>:<value>[,...]...]
  --rollup-input-metadata=<key>:<value>[,<key>:<value>[,...]...]
  --rollup-voucher-hashes=<key>:<value>[,<key>:<value>[,...]...]
  --rollup-notice-hashes=<key>:<value>[,<key>:<value>[,...]...]
    defines the individual the memory ranges used by rollups.
    <key>:<value> is one of
        filename:<filename>
        start:<number>
        length:<number>
        shared
    semantics are the same as for the --flash-drive option with the following
    difference: start and length are mandatory.
  --rollup
    defines appropriate values for rollup-rx-buffer, rollup-tx-buffer,
    rollup-input-metadata, rollup-voucher-hashes, rollup-notice hashes,
    and htif yield for use with rollups.
    equivalent to the following options:
    --rollup-rx-buffer=start:0x60000000,length:2<<20
    --rollup-tx-buffer=start:0x60200000,length:2<<20
    --rollup-input-metadata=start:0x60400000,length:4096
    --rollup-voucher-hashes=start:0x60600000,length:2<<20
    --rollup-notice-hashes=start:0x60800000,length:2<<20
    --htif-yield-manual
    --htif-yield-automatic
  --rollup-advance-state=<key>:<value>[,<key>:<value>[,...]...]
    advances the state of the machine through a number of inputs in an epoch
    <key>:<value> is one of
        epoch_index:<number>
        input:<filename-pattern>
        input_metadata:<filename-pattern>
        input_index_begin:<number>
        input_index_end:<number>
        voucher:<filename-pattern>
        voucher_hashes: <filename>
        notice:<filename-pattern>
        notice_hashes: <filename>
        report:<filename-pattern>
        hashes
        epoch_index
        the index of the epoch (the value of %e).
        input (default: "epoch-%e-input-%i.bin")
        the pattern that derives the name of the file read for input %i
        of epoch index %e.
        input_index_begin (default: 0)
        index of first input to advance (the first value of %i).
        input_index_end (default: 0)
        one past index of last input to advance (one past last value of %i).
        input_metadata (default: "epoch-%e-input-metadata-%i.bin")
        the pattern that derives the name of the file read for
        input metadata %i of epoch index %e.
        voucher (default: "epoch-%e-input-%i-voucher-%o.bin")
        the pattern that derives the name of the file written for voucher %o
        of input %i of epoch %e.
        voucher_hashes (default: "epoch-%e-input-%i-voucher-hashes.bin")
        the pattern that derives the name of the file written for the voucher
        hashes of input %i of epoch %e.
        notice (default: "epoch-%e-input-%i-notice-%o.bin")
        the pattern that derives the name of the file written for notice %o
        of input %i of epoch %e.
        notice_hashes (default: "epoch-%e-input-%i-notice-hashes.bin")
        the pattern that derives the name of the file written for the notice
        hashes of input %i of epoch %e.
        report (default: "epoch-%e-input-%i-report-%o.bin")
        the pattern that derives the name of the file written for report %o
        of input %i of epoch %e.
        hashes
        print out hashes before every input.
    the input index ranges in {input_index_begin, ..., input_index_end-1}.
    for each input, "%e" is replaced by the epoch index, "%i" by the
    input index, and "%o" by the voucher, notice, or report index.
  --rollup-inspect-state=<key>:<value>[,<key>:<value>[,...]...]
    inspect the state of the machine with a query.
    the query happens after the end of --rollup-advance-state.
    <key>:<value> is one of
        query:<filename>
        report:<filename-pattern>
        query (default: "query.bin")
        the name of the file from which to read the query.
        report (default: "query-report-%o.bin")
        the pattern that derives the name of the file written for report %o
        of the query.
    while the query is processed, "%o" is replaced by the current report index.
  --concurrency=<key>:<value>[,<key>:<value>[,...]...]
    configures the number of threads used in some implementation parts.
    <key>:<value> is one of
        update_merkle_tree:<number>
        update_merkle_tree (optional)
        defines the number of threads to use while calculating the merkle tree.
        when ommited or defined as 0, the number of hardware threads is used if
        it can be identified or else a single thread is used.
  --max-mcycle=<number>
    stop at a given mcycle (default: 2305843009213693952).
  -i or --htif-console-getchar
    run in interactive mode.
  --htif-yield-manual
    honor yield requests with manual reset by target.
  --htif-yield-automatic
    honor yield requests with automatic reset by target.
  --store=<directory>
    store machine to <directory>, where "%h" is substituted by the
    state hash in the directory name.
  --load=<directory>
    load machine previously stored in <directory>.
  --initial-hash
    print initial state hash before running machine.
  --final-hash
    print final state hash when done.
  --periodic-hashes=<number-period>[,<number-start>]
    prints root hash every <number-period> cycles. If <number-start> is given,
    the periodic hashing will start at that mcycle. This option implies
    --initial-hash and --final-hash.
    (default: none)
  --step
    print step log for 1 additional cycle when done.
  --json-steps=<filename>
    output json with step logs for all cycles to <filename>.
  --store-config[=<filename>]
    store initial machine config to <filename>. If <filename> is omitted,
    print the initial machine config to stderr.
  --load-config=<filename>
    load initial machine config from <filename>. If a field is omitted on
    machine_config table, it will fall back into the respective command-line
    argument or into the default value.
  --dump-pmas
    dump all PMA ranges to disk when done.
and command and arguments:
  command
    the full path to the program inside the target system.
    (default: /bin/sh)
  arguments
    the given command arguments.
<number> can be specified in decimal (e.g., 16) or hexadeximal (e.g., 0x10),
with a suffix multiplier (i.e., Ki, Mi, Gi for 2^10, 2^20, 2^30, respectively),
or a left shift (e.g., 2 << 20).
<address> is one of the following formats:
  <host>:<port>
   unix:<path>
<host> can be a host name, IPv4 or IPv6 address.
A final check can also be performed to verify if the contents inside the container are as expected:
sha256sum /opt/cartesi/share/images/linux.bin
76d90cd7eb6c66a76c192fefdc7bb236637f2f9f0eb4f0c5eb44f2f82240fcdd  /opt/cartesi/share/images/linux.bin
sha256sum /opt/cartesi/share/images/rom.bin
ed73b33741fb6ebb61a7e4d00ba23d30712ccb47e888b2b5ad3245d6928b8cfe  /opt/cartesi/share/images/rom.bin
sha256sum /opt/cartesi/share/images/rootfs.ext2
485f12ffd1a6df386f8be4e5e1695ecc220fd90d3a606f8ab3c0f2877199a1a3  /opt/cartesi/share/images/rootfs.ext2
Note that, if the hashes of the files you are using do not match the ones above, then when you attempt to replicate the examples in the documentation, you will obtain different hashes.
Moreover, the cycle counts and outputs may also differ.
Machine playground
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 66---










Cartesi Compute | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Cartesi Compute SDK
​
Overview
How it works
Architecture
Wallets
Execution timeline
Machines off-chain
Machines on-chain
On-chain API
Instantiate
Drives
Provider drives
Logger drives
Topologies
Supported networks
Cartesi Compute Tutorials
​
Introduction
General requirements
Cartesi Compute SDK Environment
Hello World DApp
​
Creating basic DApp
Hello World machine
Instantiating computation
Retrieving result
Deploying and running
Calculator DApp
​
Calculator project
Calculator machine
Full Calculator DApp
Generic Script DApp
​
Generic Script project
Custom root file-system
Generic Script machine
Full Generic Script DApp
GPG Verify DApp
​
GPG Verify project
Using ext2 files and GPG
GPG Verify machine
Full GPG Verify DApp
Processing larger files
Dogecoin Hash DApp
​
Dogecoin Hash project
Computing scrypt using C
Dogecoin Hash machine
Full Dogecoin Hash DApp
Cartesi Compute SDK
Cartesi Compute Tutorials
Hello World DApp
Calculator DApp
Generic Script DApp
GPG Verify DApp
Dogecoin Hash DApp
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 67---










Components | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
As explained in the 
previous section
, the Cartesi Rollups framework achieves scalability by moving the bulk of the computation outside the blockchain, using the ledger as a data source but not as an execution environment. As such, the solution contains both on-chain (layer-1) and off-chain (layer-2) components.
note
In this section, we describe the internal components of the Cartesi Rollups framework in more detail, to clarify how the system works inside. DApp developers may chose to skip directly to the 
DApp architecture
 section to understand how to build applications.
Main concepts
​
Cartesi Nodes
​
As explained before, 
Cartesi Machines
 provide DApp developers with an environment in which large scale verifiable computations can be executed. These machines are integrated with the on-chain smart contracts by a 
middleware
 that manages and controls the communication between them. As such, this middleware is responsible for first reading data from the layer-1 smart contracts, then sending them to the machine to be processed, and finally publishing their results back to the blockchain.
The 
Cartesi Node
 is the layer-2 component that consists of the combination of the Cartesi Machine and this middleware, and can be used by anyone interested in the rollups state of affairs. Put simply, Cartesi Nodes play a role that is similar to what Geth does on the Ethereum ecosystem: execution and retrieval of information.
In practice, there are two distinct kinds of agents that run Cartesi Nodes: 
users
 and 
validators
. Each of them interacts with the on-chain rollups in different ways, and thus run different types of Cartesi Nodes:
User or Reader Nodes
, which are only involved in advancing the state of the off-chain machine, and making that state publicly available. They consume information from the blockchain but do not bother to enforce state updates, trusting that validators will ensure the validity of all on-chain state updates.
Validator Nodes
, which have more responsibility: they not only watch the blockchain but also fight possible dishonest validators to ensure the prevalence of honest claims for state updates. On the other hand, if Reader Nodes are available, validators do not need to expose endpoints for retrieving application state. Therefore, they can run in more secure environments and remain inaccessible to external clients and users.
Epochs
​
In order to avoid over interacting with the blockchain, validators don't checkpoint every new state update on the off-chain machine. They do it at the end of an 
epoch
, which are batched inputs that follow the same cycle.
We can imagine epochs in three different states:
Accumulating
, when the epoch is open and waiting for inputs.
Sealed
, when the inputs for that epoch are well defined and the validators are preparing to send their claims. Sealed epochs can also be under dispute.
Finalized
, when consensus was reached and the outputs can be safely executed.
The on-chain state, depending on what phase it is, can contain one or two epochs, as illustrated by the diagram below.
Input Accumulation
: there is a single accumulating epoch, active and waiting for the inputs it is going to batch.
Awaiting Consensus
: there are two epochs. A sealed one, for which validators are preparing to or sending their claims, and an accumulating one, which is active and receiving inputs.
Awaiting Dispute
: there are also two epochs. A sealed one and an accumulating one. The sealed epoch is under dispute. At least two conflicting claims were received and the validators are enrolling in a verification game to decide which claim stands. Since the sealed epoch's inputs are well defined, honest validators will always reach the same claim. A dispute necessarily means that a claim is provably false.
To better understand the whole process on a timeline, let's describe how the system schedules different rollups phases.
On a given epoch N, the involved validator nodes batch all the input messages that were enqueued on-chain from the beginning of the previous 
epoch’s processing
 slot until the beginning of the current epoch’s 
processing slot
.
The nodes then process every message of the batch through the Cartesi Machine, producing an output hash that summarizes the state transition of the entire epoch. Then, one of the validators, henceforth called 
claimer
, places on-chain the hash representing the layer-2 contract state at the end of epoch N, 
S(N)
.
After a challenge period is over, if there was no dispute, 
S(N)
 is assumed final by the system. Otherwise, disputes will follow until the correct state claim represented by its output hash is enforced. The 
settlement period
 displayed on the diagram above accounts for a 
challenge period
, with or without disputes.
To guarantee a minimum duration for each epoch, the rollups protocol also requires an 
accumulation slot
. This is a minimal latency imposed on on-chain finalization to prevent frequent claims being sent to layer-1, for the sake of Ethereum fee cost-effectiveness. The rollup developer can configure a specific accumulation slot period for their application to accommodate eventual specific requirements for balancing latency to finality and security.
Vouchers
​
A 
voucher
 is a combination of a target address and a payload in bytes. It is used by the off-chain machine to respond and interact with layer-1 smart contracts. Upon execution, a voucher sends a message to the target address with the payload as a parameter. Vouchers can be used for anything, ranging from providing liquidity in a DeFi protocol to withdrawing funds from the 
Portal
. Vouchers can only be executed when the epoch in which they are contained is 
finalized
, at which point a 
validity proof
 will be available to ensure layer-1 smart contracts can trust its content.
Notices
​
A 
notice
 is an arbitrary payload in bytes that is submitted by the off-chain machine for informational purposes. Similarly to vouchers, when the epoch containing a notice is finalized a proof will be produced so that the validity of the notice's content can be verified on-chain by any interested party.
Reports
​
A 
report
 is an application log or a piece of diagnostic information. Like a notice, it is represented by an arbitrary payload in bytes. However, a report is never associated with a proof and is thus not suitable for trustless interactions such as on-chain processing or convincing independent third parties of DApp outcomes. Reports are commonly used to indicate processing errors or to retrieve application information for display.
On-chain components
​
These consist of the Cartesi Rollups smart contracts that were designed to mediate the relationship of the off-chain components with other smart contracts and externally owned accounts. They include several modules, each with clear responsibilities and well-defined interfaces.
Cartesi Rollups Manager
​
The 
Cartesi Rollups Manager
 is responsible for synchronicity between the modules. It defines the duration of the different phases and notifies the other modules of any phase change. Among others, the responsibilities of this module are:
Define to which epoch an input is destined, depending on the current state and deadlines.
Receive and forward claims to the Validator Manager.
Forward disputes to the Dispute Resolution module.
Forward the result of disputes to the Validator Manager.
Forward the summary of finalized outputs (vouchers and notices) to the Output module.
Notify other modules of phase changes.
Input contract
​
As discussed above, the on-chain contracts often have two concurrent epochs: a sealed but unfinalized epoch, and an accumulating one. The 
Input contract
 keeps one inbox for each of those epochs, switching between them depending on the Cartesi Rollups Manager's notifications.
For anyone to be able to synchronize the machine from its beginning without needing to trust a data provider, the full content of inputs is always present in calldata on the blockchain. In on-chain storage, which needs to be used in a more parsimonious way, we keep a single hash for each input of an active epoch.
This input hash summarizes both the input itself and its metadata, which corresponds to the sender's address and the time of reception. Notice that this input implementation is permissionless: the permission layer is delegated to the off-chain machine which will, for example, judge if a sender is allowed to do what their input wants to do.
Output contract
​
Each input can generate a number of notices and vouchers that will have an accompanying 
validity proof
 available once the epoch containing them is finalized. These proofs can be used with the 
Output contract
 to execute vouchers or verify the validity of a notice's content.
For vouchers, while the Output contract is indifferent to their content, it does enforce some sanity checks before allowing their execution, since vouchers are unique and can only be successfully executed once. Vouchers are executed asynchronously and don't require an access check, and the order of execution is not enforced. As long as vouchers are contained in a finalized epoch and were not executed before, the contract will allow their execution by anyone.
Portal
​
The Portal, as the name suggests, is used to teleport assets from the Ethereum blockchain to DApps running on Cartesi Rollups. Once deposited, those layer-1 assets gain a representation in layer-2 and are owned, there, by whomever the depositor assigned them to. After being teleported, layer-2 assets can be moved around in a significantly cheaper way, using simple inputs that are understood by the Linux logic.
When an asset is deposited, the Portal contract sends an input to the DApp’s inbox, describing the type of asset, amount, receivers, and some data the depositor might want the DApp to read. This allows deposits and instructions to be sent as a single layer-1 interaction. One could think of the Portal as a bank account, owned by the off-chain machine.
Anyone can deposit assets there but only the DApp — through its Output contract — can decide on withdrawals. The withdrawal process is quite simple from a user perspective. They send an input requesting a withdrawal, which gets processed and interpreted off-chain. If everything is correct, the machine creates a voucher destined to the Portal contract, ordering and finalizing that withdrawal request. Currently, we support the following types of assets:
Ether (ETH)
ERC-20
ERC-721 (NFTs)
Validator Manager
​
The 
Validator Manager
 module was created to help DApps manage their claims, claim permissions, and punishments for bad behavior. Initially, our suggested implementation for this module includes the following characteristics: the set of payable validators is defined in construction time, validators send a claim for every epoch and those that lose a dispute are kicked off the validators set.
The 
Cartesi Rollups Manager
 receives claims and redirects them to the Validator Manager. When receiving a claim, the Validator Manager checks which other claims have arrived at that epoch and returns the information that Cartesi Rollups Manager needs to continue. The module can respond to received claims in one of the following ways:
If the sender is not a validator or the claim is invalid, the transaction reverts.
If the claim is valid, doesn’t disagree with any of the other claims in the epoch, and does not generate consensus, it returns a "No Conflict" response.
If the claim is valid but disagrees with another claim for that epoch, it warns the Cartesi Rollups Manager that a conflict is happening and what are the conflicting claims and claimants involved. When that dispute is resolved the Validator Manager module gets notified so it can deal however it likes with the validators involved. In our initially suggested implementation, the loser of a dispute is removed from the validator set.
If the claim is valid, agrees with all other claims in that epoch, and is the last claim to be received, it lets Cartesi Rollups know that consensus was reached. This allows the rollups DApp to finalize the epoch and allow for the execution of its vouchers. Regardless of what the name might suggest, validators do not interact with this module at all.
Fee Manager and Bank
​
The 
Fee Manager facet
 and 
Bank contract
 aim to create an economical incentive for validators to run a given DApp. When you develop an application, you will need to define two parameters:
A fee to be paid to the validators each time they submit a claim. This fee will be debited from the funds stored in the DApp's Bank contract.
An owner for the Fee Manager facet, who has the option to change the fee value, if needed.
Entities running validator nodes should configure them to either be 
altruistic
 or require a minimum retainer (i.e., a minimum fee to process inputs for the DApp). If they are altruistic, they will work regardless of any financial compensation. On the other hand, non-altruistic validators must ensure that the following two conditions are met before processing inputs and submitting claims:
The fee paid by the DApp must be bigger than their required retainer
The DApp's Bank must have enough funds to pay the validator
The fee value is given in CTSI and is reserved for a validator every time a claim is made. The validator is free to withdraw received CTSI fees at any time of its convenience. While the Fee Manager controls the fee value and the amount of claims made by each validator, the Bank stores - on a separate contract - the CTSI tokens that will be distributed to them.
The code does not enforce a way for the Bank to be funded. Therefore, DApps and communities are free to choose their preferred procedures, such as direct transfer, charging per input, creating a tax system on top of the Portal, or other methods. For convenience, a 
FundBank
 hardhat task is provided which transfers money from the signer to a DApp's Bank.
Dispute Resolution
​
Disputes occur when two validators claim different state updates to the same epoch. Because of the deterministic nature of our virtual machine and the fact that the inputs that constitute an epoch are agreed upon beforehand, conflicting claims imply dishonest behavior. When a conflict occurs, the module that mediates the interactions between both validators is the Dispute Resolution contract.
The code for rollups dispute resolution is not being published yet - but a big part of it is available on the Cartesi Rollups SDK, using the 
Arbitration dlib
.
Off-chain components
​
These consist of the internal modules of the 
Cartesi Node
. As explained before, Cartesi Nodes form the network that sustains the Cartesi Rollups solution, being responsible for executing the computations that arrive and presenting their results to the interested parties.
State Server
​
This service is responsible for ensuring that the remaining modules have access to a consistent view of the state of the blockchain. The service is an instance of  Cartesi's 
State Fold tool
 and monitors all relevant activity from the Cartesi Rollups smart contracts, consolidating the information that gets emitted by the blockchain.
Rollups Dispatcher
​
Responsible for interpreting the current state of the Cartesi Rollups smart contracts, this module informs the 
Server Manager
 about any incoming inputs and, in the case of Validator Nodes, also submits transactions to layer-1 corresponding to state update claims. It will also handle any disputes should they arise.
Server Manager
​
This module manages the Cartesi Machine, sending inputs to it and reading the produced outputs. It is responsible for starting and stopping the machine as appropriate, as well as providing an API for the other modules to query the machine's state.
The 
Host Server Manager
 is an alternative implementation of the Server Manager for development purposes. It implements the same API and mimics the behavior of an actual Server Manager, but does not in fact instantiate a Cartesi Machine. Instead, it makes HTTP requests directly to a DApp running in the host computer. The Host Server Manager is intended to be used in the 
implementation stage of the DApp life cycle
.
Rollups Indexer
​
This service is responsible for consolidating the state of the Cartesi Node. It queries blockchain information from the 
State Server
 as well as data produced by the DApp back-end through the 
Server Manager
, consolidating everything in a local database.
Query Server
​
Module that provides an externally accessible 
GraphQL API
 for querying the consolidated state of the Cartesi Node, as maintained by the 
Rollups Indexer
. This allows users and client applications to retrieve vouchers, notices and reports produced by the DApp back-end.
Main concepts
Cartesi Nodes
Epochs
Vouchers
Notices
Reports
On-chain components
Cartesi Rollups Manager
Input contract
Output contract
Portal
Validator Manager
Fee Manager and Bank
Dispute Resolution
Off-chain components
State Server
Rollups Dispatcher
Server Manager
Rollups Indexer
Query Server
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 68---










Cartesi Compute | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Cartesi Compute SDK
​
Overview
How it works
Architecture
Wallets
Execution timeline
Machines off-chain
Machines on-chain
On-chain API
Instantiate
Drives
Provider drives
Logger drives
Topologies
Supported networks
Cartesi Compute Tutorials
​
Introduction
General requirements
Cartesi Compute SDK Environment
Hello World DApp
​
Creating basic DApp
Hello World machine
Instantiating computation
Retrieving result
Deploying and running
Calculator DApp
​
Calculator project
Calculator machine
Full Calculator DApp
Generic Script DApp
​
Generic Script project
Custom root file-system
Generic Script machine
Full Generic Script DApp
GPG Verify DApp
​
GPG Verify project
Using ext2 files and GPG
GPG Verify machine
Full GPG Verify DApp
Processing larger files
Dogecoin Hash DApp
​
Dogecoin Hash project
Computing scrypt using C
Dogecoin Hash machine
Full Dogecoin Hash DApp
Cartesi Compute SDK
Cartesi Compute Tutorials
Hello World DApp
Calculator DApp
Generic Script DApp
GPG Verify DApp
Dogecoin Hash DApp
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 69---










Homepage | Blockchain OS Documentation - Cartesi
























Skip to main content
Welcome to Cartesi docs.
Rollups
Browse our DApp tutorials, API references, and more to learn how to build on Cartesi.
Machine
Deep dive into the low level of Cartesi's core technology.
Staking
View and analyse assets, transactions and balances on the Cartesi network.
Learn
by goal
by role
by-goal
by-role
by product
Hands-on: Build Rollups DApps Now!
Step 1: Installing
Step 2: Building
Step 3: Running
Step 4: Interacting
Step 5: Deploying
Deep Dive: Explore the Cartesi Machine
Introduction to the Cartesi Machine
Setting up and running Cartesi Machines
Cartesi Machines from the inside: Linux environment and system architecture
How blockchains can benefit from Cartesi Machines
Beginner
New to Cartesi
Understand how Cartesi Rollups are different
Brief overview of The Blockchain OS
Understand the scalability problem
Developer
Onboarding path
Install technical prerequisites
Quick start to run an existing DApp
Create your first DApp
Run your DApp off-chain
Explore DApp architecture
Explore DApp life cycle
Researcher & Low-level developer
Introduction to the Cartesi Machine
Setting up and running Cartesi Machines
Cartesi Machines from the inside: Linux environment and system architecture
How blockchains can benefit from Cartesi Machines
Get Help
Feeling stuck? Don’t worry, come join us over on Discord or StackOverflow and connect with our core developers who’ll be happy to help.
Ask a question or learn from others:
Discord
StackOverflow
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 70---










Overview of building DApps | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
tip
Navigate to our 
Quick Start
 tutorial if you want to build DApps now!
Cartesi's vision is that creating a DApp should not be too different from the general development of desktop, web, and mobile applications. To that end, Cartesi provides a Blockchain OS for building decentralized logic, giving developers full flexibility to use the tools and libraries of their preference.
From a developer's point of view, a Cartesi DApp is composed of two main parts:
Front-end
: the user facing interface, which will often provide a UI (e.g., a web application) but may also be a command line interface (e.g., a hardhat task using ethers, or a command line using python).
Back-end
: the verifiable logic that will run inside the Cartesi Rollups infrastructure; this will store and update the application state given user input, and will produce outputs in the form of 
vouchers
 (transactions that can be carried out on layer-1) and 
notices
 (information that can be validated on layer-1).
The suggested development process for Cartesi DApps involves a 
series of stages
, from the design of the application up to its final deployment. Although some of those stages involve blockchain or Cartesi-specific procedures, the intention is that developers should be able to code normally using their usual mainstream development environment for 90+% of the work, and to make that possible Cartesi provides some tools and infrastructure.
In particular, during development the Cartesi Rollups infrastructure can be executed locally in two modes, as described below.
Production Mode
​
In 
Production Mode
, the DApp's back-end logic is packaged to run inside a 
Cartesi Machine emulator
, as will be the case when the application is deployed. This means that any code written in compiled languages such as C++ or Rust must be 
cross-compiled
 to the Cartesi Machine's RISC-V architecture. In this mode, the computation performed by the back-end is reproducible and hence verifiable, enabling a truly trustless and decentralized execution.
Host Mode
​
In 
Host Mode
, the back-end logic is executed natively on localhost, just as any regular application. This is made possible because the Cartesi Rollups Host Environment provides the very same APIs as the regular mode, mimicking the behavior of the actual layer-1 and layer-2 components. This allows the developer to test and debug the back-end logic using familiar tools, such as an IDE or a debugger.
Learn more
​
Cartesi Rollups overview
DApp life cycle explained
DApp architecture
Rollups HTTP APIs
Production Mode
Host Mode
Learn more
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 71---










Quick Start | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
This article explains how to build and interact with a minimalistic 
Cartesi Rollups
 application.
By the end of this tutorial, you will learn how to run a simple existing DApp written in 
Python
, called 
Echo-Python
.
note
You can inspect the 
full code of the Echo Python DApp
 in Cartesi's public Github repository.
Overview
​
The Echo-Python DApp simply copies (or "echoes") each input received as a corresponding output 
notice
. The DApp's back-end is written in 
Python
, and its front-end is a 
simple console application
 written in 
Typescript
 that can be executed from a terminal.
The 
Quick Start
 guide consists of 5 main steps:
Installing
Building
Running
Interacting
Deploying
Installing
​
note
You can use online development environments such as 
Gitpod
 and 
CodeSandbox
 to open the 
rollups-exmaples
 directly in your browser with all 
required dependencies
 already installed. These services allow you to start experimenting immediately, but keep in mind that they are provided by third-parties and are subject to unavailability and policy changes. They may also require access to your GitHub account in order to work properly.
There are two different options to setup the prerequisites, you can choose one of the following:
Using Gitpod
 as a fast option
Using manual setup
 to install all the necessary requirements locally
Using Gitpod
​
This is an easy and fast setup, you need to follow the steps:
Navigate to Gitpod rollups-examples
 to automate your development setup
When you click on the link above, it will forward you to login options.
Login with your preferable option via GitLab, GitHub, or Bitbucket.
Provide authorization to GitLab, GitHub, or Bitbucket.
Congratulations, you have successfully setup your development environment
Start Building our Echo DApp
Using manual setup
​
Follow the 
manual setup
 to  make sure you have installed all the necessary requirements locally.
Building
​
To build the 
echo-python
 example:
tip
If you are running your environment using the 
Gitpod option explained above
, then please start from 
step number 2
 as you will not need to clone the Github repository.
Clone the 
cartesi/rollups-examples
 Github repository by running the following command:
git
 clone https://github.com/cartesi/rollups-examples.git
Navigate to the DApp example directory by running the following command:
cd
 rollups-examples/echo-python
Build the Echo DApp by running the following command:
docker
 buildx bake --load
Running
​
To run the application, you can start an environment that includes a local blockchain with the Cartesi smart contracts deployed, as well as a Cartesi layer-2 node executing the DApp's back-end logic.
This can be done by running the following command:
docker
 compose -f 
..
/docker-compose.yml -f ./docker-compose.override.yml up
After you see the expected logs below, you can go to the 
Interacting Step
.
Expected logs
​
Allow some time for the infrastructure to be ready.
How much will depend on your system, but after some time showing the error 
"concurrent call in session"
, eventually the container logs will repeatedly show the following:
server_manager_1      
|
 Received GetVersion
server_manager_1      
|
 Received GetStatus
server_manager_1      
|
   default_rollups_id
server_manager_1      
|
 Received GetSessionStatus 
for
 session default_rollups_id
server_manager_1      
|
   
0
server_manager_1      
|
 Received GetEpochStatus 
for
 session default_rollups_id epoch 
0
Advancing time
​
When executing an example, it is possible to advance time to simulate the passing of epochs. To do that, run:
curl
 --data 
'{"id":1337,"jsonrpc":"2.0","method":"evm_increaseTime","params":[864010]}'
 http://localhost:8545
How to shutdown the environment
​
You can shutdown the environment by running the following command:
docker-compose
 -f 
..
/docker-compose.yml -f ./docker-compose.override.yml down -v
Interacting with the DApp
​
There are two ways to interact with the DApp:
Locally
Remotely
Interacting locally with the DApp
​
With the infrastructure in place, you can use our 
frontend-console application
 to interact with the Echo DApp by following the steps:
Open a separate terminal window
From the rollups-examples base directory, navigate to the 
frontend-console
 one:
cd
 frontend-console
Build the frontend console application:
yarn
yarn
 build
Send an input to the current locally deployed DApp:
yarn
 start input send --payload 
"Hello Blockchain OS!"
Verify the outputs (notices) generated by your input, to display your DApp notices run the following command:
yarn
 start notice list
After completing all the steps above, you should get a response similar to the following:
[ { epoch: '0', input: '1', notice: '0', payload: 'Hello Blockchain OS!' } ]
tip
You can run the Cartesi Rollups environment locally in 
host mode
. Please follow the guide on 
how to run DApp back-ends in Host Mode
, but before that make sure to 
shutdown the current running environment
.
note
For more information about the 
frontend-console
 application and its options, please check the 
frontend-console documentation
.
Interacting with remotely deployed DApps
​
The 
Echo DApp
 example is already deployed on a public blockchain test network called 
Goerli
, which is an Ethereum testnet.
You can use the same 
frontend-console application
 to interact with it, as described below.
note
Please refer to the 
frontend-console documentation
 for details on how to use it to 
send inputs
, 
list notices
 and 
deposit ERC-20 tokens
.
The following steps describe how to send an input to the Echo DApp instance that is already deployed on Goerli:
Open a separate terminal window
Navigate to the 
frontend-console
 directory:
cd
 frontend-console
Build the project:
yarn
yarn
 build
You can 
follow this tutorial to create an Ethereum account using Metamask
. Make sure to save the Secret Backup Phrase (MNEMONIC user sequence of twelve words)
Get testnet funds/tokens on Goerli to be able to submit transactions on that network. There are several faucets available, you may try 
https://goerlifaucet.com/
 or 
https://goerli-faucet.slock.it/
Create an 
Alchemy account
 to obtain an API key for reliable access to the Goerli network. Alternatively, you can use other options such as 
Infura
 or 
Moralis
Configure your account on Goerli by running the commands below, which specify the network and MNEMONIC (Secret Backup Phrase) to use:
export
 
NETWORK
=
goerli
export
 
MNEMONIC
=
<
paste here your user sequence of twelve words
>
Configure your 
Alchemy
 RPC gateway URL for Goerli by running the following command:
export
 
RPC_URL
=
https://eth-goerli.alchemyapi.io/v2/
<
Replace_This_With_Your_Alchemy_API_key
>
Send an input by running the command:
yarn
 start input send --payload 
"my new message"
 --dapp echo-python
Query the layer-2 Cartesi Node for notices produced by the DApp:
yarn
 start notice list --url https://echo-python.goerli.rollups.staging.cartesi.io/graphql
tip
As shown in the last step (number 10), to query the layer-2 Cartesi Node for DApp outputs, you will need to specify the URL of its GraphQL endpoint. You can find other existing examples endpoints in the 
DApp table below
.
Explore our DApps
​
You can find several Cartesi DApp 
examples on GitHub
, such as the following:
DApp Name
DApp Deployment Status on Goerli Testnet
GraphQL endpoint URL
Echo Python
Yes
https://echo-python.goerli.rollups.staging.cartesi.io/graphql
Echo C++
Yes
https://echo-cpp.goerli.rollups.staging.cartesi.io/graphql
Echo Rust
No
-
Echo Lua
Yes
https://echo-lua.goerli.rollups.staging.cartesi.io/graphql
Echo JS DApp
Yes
https://echo-js.goerli.rollups.staging.cartesi.io/graphql
Echo Low-Level
Yes
https://echo-low-level.goerli.rollups.staging.cartesi.io/graphql
Converter
No
-
Calculator
No
_
SQLite
Yes
https://sqlite.goerli.rollups.staging.cartesi.io/graphql
k-NN
Yes
https://knn.goerli.rollups.staging.cartesi.io/graphql
m2cgen
No
-
ERC-20
No
-
Auction
No
-
Overview
Installing
Using Gitpod
Using manual setup
Building
Running
Expected logs
Advancing time
How to shutdown the environment
Interacting with the DApp
Interacting locally with the DApp
Interacting with remotely deployed DApps
Explore our DApps
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 72---










39 docs tagged with "low-level developer" | Blockchain OS Documentation - Cartesi
























Skip to main content
Architecture
What follows is a summary of the architecture and the components that are involved in running a Cartesi Compute Application, meaning some DApp that makes use of our SDK. It is convenient to start with the description of the typical ingredients involved in a decentralized application. Namely, the blockchain node and the client software.
Calculator project
- create and initialize project for the Calculator Cartesi Compute DApp
Cartesi Compute SDK Environment
- describe easy-to-use environment available for developing Cartesi Compute DApps
Choose your Onboarding Path
Our onboarding paths answer the following questions:
Components
As explained in the previous section, the Cartesi Rollups framework achieves scalability by moving the bulk of the computation outside the blockchain, using the ledger as a data source but not as an execution environment. As such, the solution contains both on-chain (layer-1) and off-chain (layer-2) components.
Creating basic DApp
- create and initialize a basic project for a Cartesi Compute DApp
DApp architecture
Borrowing from familiar mainstream terminology, from a developer’s point of view a Cartesi DApp is developed by implementing two main components: a front-end and a back-end.
DApp life cycle
Now that we have described the architecture of a Cartesi DApp and how the front-end and back-end communicate with the Cartesi Rollups framework, let’s step back a bit to discuss how a DApp can be implemented in practice.
Dogecoin Hash project
- create and initialize project for the Dogecoin Hash Cartesi Compute DApp
Drives
This section describes in detail the Drive[] _inputDrives parameter of the instantiate call.
Execution timeline
At this point, an overview has been given of what constitutes a Cartesi computation, who are the parties involved, and what the software components of Cartesi Compute are. It is important to understand better what events happen during the execution of a Cartesi Machine.
General requirements
- ensure all dependencies necessary for running the tutorials are installed
Generic Script project
- create and initialize project for the Generic Script Cartesi Compute DApp
GPG Verify project
- understand use case of using GPG for document signature verification
Hash view of state
One of the key goals of moving computations off-chain is to allow them to manipulate vast amounts of data: so much data that it becomes economically prohibitive to explicitly store them in the blockchain.
How it works
Cartesi Compute SDK allows Cartesi DApps to specify and request verifiable computations to Cartesi Machines. Additionally, the SDK provides tools to facilitate and reduce the cost of inputting data into Cartesi Machines.
Instantiate
This section describes the main ingredient of the on-chain Cartesi Compute infrastructure.
Introduction
This section describes Cartesi Machines from the perspective of the blockchain.
Introduction
The Cartesi Machine is Cartesi's solution for verifiable computation.
Introduction
- give step by step instructions about how to build a DApp using the Cartesi Compute SDK
Logger drives
A relevant limitation of the Cartesi Machines as they have been described until now is the size of their input drives.
Lua interface
This entire chapter is for advanced users only, since typical users of the Cartesi platform will likely never need to programmatically control a Cartesi Machine.
Machines off-chain
Although an extensive documentation of Cartesi Machines can be found here, one may choose to skip this reading and jump right away to their usage inside the blockchain through Cartesi Compute. For that, it is enough to regard a Cartesi Machine as a black box that executes computations.
Machines on-chain
Having discussed the concept of Cartesi Machines off-chain, capable of booting a Linux operating system and loading heavy-weight libraries, one naturally wonders how this will ever be stored or executed on the limited environment of a blockchain. The simple answer is that it won’t be.
On-chain API
Having informally discussed how Cartesi Compute represents Cartesi Machines on-chain, one can now describe in more details the API for requesting and retrieving computations in Cartesi Compute.
Overview
The combination of an Optimistic Rollups framework and the Cartesi Machine Emulator enables the development of smart contracts and DApps using any package or library that is available for Linux. This allows developers to break free from the scalability limitations of the Ethereum Virtual Machine (EVM), and brings the rise of a new blockchain era to handle real-life and complex use-cases.
Overview
The Cartesi Compute documentation is a work in progress so please navigate to Quick Start for building DApps
Overview
Cartesi's reference off-chain implementation of Cartesi Machines is based on software emulation.
Platform services
Platform Services is a new product developed and maintained by the Cartesi team that hosts Cartesi Node infrastructure for DApps. The service is elastic, making resources available to DApps upon demand. Developers deploy their Cartesi DApps on Platform Services and it automatically allocates resources according to user activity.
Provider drives
After going through the last section, the reader is already able to specify drives if the data was available to the caller at the time of instantiation.
Putting Things Together
To better understand how Cartesi Compute can be used, imagine the following simple Cartesi DApp with one claimer and one challenger. The DApp can be a skill-based game where players place their bets and challenge each other for the highest score over the blockchain. The winner takes the pot.
Rollups HTTP APIs
In a Cartesi DApp, the front-end and back-end parts of the application communicate with each other through the Rollups framework via a set of HTTP APIs.
Scalability
The scalability issue is one of the three parts of the Blockchain Trilemma, along with security and decentralization. Solving the scalability issue refers to any type of improvement within a blockchain system in terms of computational power, throughput, latency, bootstrap time, or cost per transaction. For example, high gas fees make it expensive for users to pay for their transactions within the Ethereum blockchain.
Supported networks
Broadly speaking, the Cartesi layer-2 platform architecture should be perceived as blockchain-agnostic, given that in principle any network could use Cartesi Machines to move complex computations off-chain without compromising on decentralization.
The Blockchain OS
Cartesi, The Blockchain OS, is a layer-2 platform for the development and deployment of scalable decentralized applications. The Blockchain OS offers a Linux operating system coupled with a blockchain infrastructure, which allows DApps to be developed in familiar programming languages like Python without the need to write Solidity code.
The off-chain API
After the call for instantiate, the blockchain may already have all information that is necessary to execute the machine. But in many cases it also needs to get input from other users. In a game for example, the user may need to insert their decisions on input drives for later processing.
Topologies
When users interact with their blockchain DApps, they are free to manage and run their own blockchain nodes if so they wish. In a common scenario of the usage of the Ethereum network, DApps are accessed via browser and blockchain transaction requests are carried out by Metamask. The user signs the transaction which is typically sent to a remotely hosted node, such as Infura.
Verification game
This section is still under construction.
Wallets
Cartesi is a second layer solution.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 73---










Build DApps | Blockchain OS Documentation - Cartesi
























Skip to main content
Overview of building DApps
Navigate to our Quick Start tutorial if you want to build DApps now!
General requirements
To start developing applications using Cartesi Rollups, first make sure that the packages listed in this section are all installed and working in your system. The instructions listed below should be enough to turn a fresh copy of the latest Ubuntu LTS distribution into a fully fledged Cartesi development environment.
Quick Start
This article explains how to build and interact with a minimalistic Cartesi Rollups application.
Create your first DApp
Once you learned how to run a simple example, it is now time to create one of your own. In order to do this, we will make use of the DApp template available in Cartesi's rollups-examples Github repository. Once again, make sure you have installed all the necessary requirements before proceeding.
Run back-end in Host Mode
When developing an application, it is often important to easily test and debug it. For that matter, it is possible to run the Cartesi Rollups environment in host mode, so that the DApp's back-end can be executed directly on the host machine, allowing it to be debugged using regular development tools such as an IDE.
Deploying DApps
Please check the full documentation for deploying Rollups DApps to Cartesi's cloud-based execution infrastructure.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 74---










Homepage | Blockchain OS Documentation - Cartesi
























Skip to main content
Welcome to Cartesi docs.
Rollups
Browse our DApp tutorials, API references, and more to learn how to build on Cartesi.
Machine
Deep dive into the low level of Cartesi's core technology.
Staking
View and analyse assets, transactions and balances on the Cartesi network.
Learn
by goal
by role
by-goal
by-role
by product
Hands-on: Build Rollups DApps Now!
Step 1: Installing
Step 2: Building
Step 3: Running
Step 4: Interacting
Step 5: Deploying
Deep Dive: Explore the Cartesi Machine
Introduction to the Cartesi Machine
Setting up and running Cartesi Machines
Cartesi Machines from the inside: Linux environment and system architecture
How blockchains can benefit from Cartesi Machines
Beginner
New to Cartesi
Understand how Cartesi Rollups are different
Brief overview of The Blockchain OS
Understand the scalability problem
Developer
Onboarding path
Install technical prerequisites
Quick start to run an existing DApp
Create your first DApp
Run your DApp off-chain
Explore DApp architecture
Explore DApp life cycle
Researcher & Low-level developer
Introduction to the Cartesi Machine
Setting up and running Cartesi Machines
Cartesi Machines from the inside: Linux environment and system architecture
How blockchains can benefit from Cartesi Machines
Get Help
Feeling stuck? Don’t worry, come join us over on Discord or StackOverflow and connect with our core developers who’ll be happy to help.
Ask a question or learn from others:
Discord
StackOverflow
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 75---










7 docs tagged with "researcher" | Blockchain OS Documentation - Cartesi
























Skip to main content
Choose your Onboarding Path
Our onboarding paths answer the following questions:
Hash view of state
One of the key goals of moving computations off-chain is to allow them to manipulate vast amounts of data: so much data that it becomes economically prohibitive to explicitly store them in the blockchain.
Introduction
The Cartesi Machine is Cartesi's solution for verifiable computation.
Lua interface
This entire chapter is for advanced users only, since typical users of the Cartesi platform will likely never need to programmatically control a Cartesi Machine.
Scalability
The scalability issue is one of the three parts of the Blockchain Trilemma, along with security and decentralization. Solving the scalability issue refers to any type of improvement within a blockchain system in terms of computational power, throughput, latency, bootstrap time, or cost per transaction. For example, high gas fees make it expensive for users to pay for their transactions within the Ethereum blockchain.
The Blockchain OS
Cartesi, The Blockchain OS, is a layer-2 platform for the development and deployment of scalable decentralized applications. The Blockchain OS offers a Linux operating system coupled with a blockchain infrastructure, which allows DApps to be developed in familiar programming languages like Python without the need to write Solidity code.
Verification game
This section is still under construction.
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 76---










Quick Start | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
This article explains how to build and interact with a minimalistic 
Cartesi Rollups
 application.
By the end of this tutorial, you will learn how to run a simple existing DApp written in 
Python
, called 
Echo-Python
.
note
You can inspect the 
full code of the Echo Python DApp
 in Cartesi's public Github repository.
Overview
​
The Echo-Python DApp simply copies (or "echoes") each input received as a corresponding output 
notice
. The DApp's back-end is written in 
Python
, and its front-end is a 
simple console application
 written in 
Typescript
 that can be executed from a terminal.
The 
Quick Start
 guide consists of 5 main steps:
Installing
Building
Running
Interacting
Deploying
Installing
​
note
You can use online development environments such as 
Gitpod
 and 
CodeSandbox
 to open the 
rollups-exmaples
 directly in your browser with all 
required dependencies
 already installed. These services allow you to start experimenting immediately, but keep in mind that they are provided by third-parties and are subject to unavailability and policy changes. They may also require access to your GitHub account in order to work properly.
There are two different options to setup the prerequisites, you can choose one of the following:
Using Gitpod
 as a fast option
Using manual setup
 to install all the necessary requirements locally
Using Gitpod
​
This is an easy and fast setup, you need to follow the steps:
Navigate to Gitpod rollups-examples
 to automate your development setup
When you click on the link above, it will forward you to login options.
Login with your preferable option via GitLab, GitHub, or Bitbucket.
Provide authorization to GitLab, GitHub, or Bitbucket.
Congratulations, you have successfully setup your development environment
Start Building our Echo DApp
Using manual setup
​
Follow the 
manual setup
 to  make sure you have installed all the necessary requirements locally.
Building
​
To build the 
echo-python
 example:
tip
If you are running your environment using the 
Gitpod option explained above
, then please start from 
step number 2
 as you will not need to clone the Github repository.
Clone the 
cartesi/rollups-examples
 Github repository by running the following command:
git
 clone https://github.com/cartesi/rollups-examples.git
Navigate to the DApp example directory by running the following command:
cd
 rollups-examples/echo-python
Build the Echo DApp by running the following command:
docker
 buildx bake --load
Running
​
To run the application, you can start an environment that includes a local blockchain with the Cartesi smart contracts deployed, as well as a Cartesi layer-2 node executing the DApp's back-end logic.
This can be done by running the following command:
docker
 compose -f 
..
/docker-compose.yml -f ./docker-compose.override.yml up
After you see the expected logs below, you can go to the 
Interacting Step
.
Expected logs
​
Allow some time for the infrastructure to be ready.
How much will depend on your system, but after some time showing the error 
"concurrent call in session"
, eventually the container logs will repeatedly show the following:
server_manager_1      
|
 Received GetVersion
server_manager_1      
|
 Received GetStatus
server_manager_1      
|
   default_rollups_id
server_manager_1      
|
 Received GetSessionStatus 
for
 session default_rollups_id
server_manager_1      
|
   
0
server_manager_1      
|
 Received GetEpochStatus 
for
 session default_rollups_id epoch 
0
Advancing time
​
When executing an example, it is possible to advance time to simulate the passing of epochs. To do that, run:
curl
 --data 
'{"id":1337,"jsonrpc":"2.0","method":"evm_increaseTime","params":[864010]}'
 http://localhost:8545
How to shutdown the environment
​
You can shutdown the environment by running the following command:
docker-compose
 -f 
..
/docker-compose.yml -f ./docker-compose.override.yml down -v
Interacting with the DApp
​
There are two ways to interact with the DApp:
Locally
Remotely
Interacting locally with the DApp
​
With the infrastructure in place, you can use our 
frontend-console application
 to interact with the Echo DApp by following the steps:
Open a separate terminal window
From the rollups-examples base directory, navigate to the 
frontend-console
 one:
cd
 frontend-console
Build the frontend console application:
yarn
yarn
 build
Send an input to the current locally deployed DApp:
yarn
 start input send --payload 
"Hello Blockchain OS!"
Verify the outputs (notices) generated by your input, to display your DApp notices run the following command:
yarn
 start notice list
After completing all the steps above, you should get a response similar to the following:
[ { epoch: '0', input: '1', notice: '0', payload: 'Hello Blockchain OS!' } ]
tip
You can run the Cartesi Rollups environment locally in 
host mode
. Please follow the guide on 
how to run DApp back-ends in Host Mode
, but before that make sure to 
shutdown the current running environment
.
note
For more information about the 
frontend-console
 application and its options, please check the 
frontend-console documentation
.
Interacting with remotely deployed DApps
​
The 
Echo DApp
 example is already deployed on a public blockchain test network called 
Goerli
, which is an Ethereum testnet.
You can use the same 
frontend-console application
 to interact with it, as described below.
note
Please refer to the 
frontend-console documentation
 for details on how to use it to 
send inputs
, 
list notices
 and 
deposit ERC-20 tokens
.
The following steps describe how to send an input to the Echo DApp instance that is already deployed on Goerli:
Open a separate terminal window
Navigate to the 
frontend-console
 directory:
cd
 frontend-console
Build the project:
yarn
yarn
 build
You can 
follow this tutorial to create an Ethereum account using Metamask
. Make sure to save the Secret Backup Phrase (MNEMONIC user sequence of twelve words)
Get testnet funds/tokens on Goerli to be able to submit transactions on that network. There are several faucets available, you may try 
https://goerlifaucet.com/
 or 
https://goerli-faucet.slock.it/
Create an 
Alchemy account
 to obtain an API key for reliable access to the Goerli network. Alternatively, you can use other options such as 
Infura
 or 
Moralis
Configure your account on Goerli by running the commands below, which specify the network and MNEMONIC (Secret Backup Phrase) to use:
export
 
NETWORK
=
goerli
export
 
MNEMONIC
=
<
paste here your user sequence of twelve words
>
Configure your 
Alchemy
 RPC gateway URL for Goerli by running the following command:
export
 
RPC_URL
=
https://eth-goerli.alchemyapi.io/v2/
<
Replace_This_With_Your_Alchemy_API_key
>
Send an input by running the command:
yarn
 start input send --payload 
"my new message"
 --dapp echo-python
Query the layer-2 Cartesi Node for notices produced by the DApp:
yarn
 start notice list --url https://echo-python.goerli.rollups.staging.cartesi.io/graphql
tip
As shown in the last step (number 10), to query the layer-2 Cartesi Node for DApp outputs, you will need to specify the URL of its GraphQL endpoint. You can find other existing examples endpoints in the 
DApp table below
.
Explore our DApps
​
You can find several Cartesi DApp 
examples on GitHub
, such as the following:
DApp Name
DApp Deployment Status on Goerli Testnet
GraphQL endpoint URL
Echo Python
Yes
https://echo-python.goerli.rollups.staging.cartesi.io/graphql
Echo C++
Yes
https://echo-cpp.goerli.rollups.staging.cartesi.io/graphql
Echo Rust
No
-
Echo Lua
Yes
https://echo-lua.goerli.rollups.staging.cartesi.io/graphql
Echo JS DApp
Yes
https://echo-js.goerli.rollups.staging.cartesi.io/graphql
Echo Low-Level
Yes
https://echo-low-level.goerli.rollups.staging.cartesi.io/graphql
Converter
No
-
Calculator
No
_
SQLite
Yes
https://sqlite.goerli.rollups.staging.cartesi.io/graphql
k-NN
Yes
https://knn.goerli.rollups.staging.cartesi.io/graphql
m2cgen
No
-
ERC-20
No
-
Auction
No
-
Overview
Installing
Using Gitpod
Using manual setup
Building
Running
Expected logs
Advancing time
How to shutdown the environment
Interacting with the DApp
Interacting locally with the DApp
Interacting with remotely deployed DApps
Explore our DApps
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 77---










References | Blockchain OS Documentation - Cartesi
























Skip to main content
Code samples
Changelog
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 78---










Choose your Onboarding Path | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
Our onboarding paths answer the following questions:
What can the Blockchain OS do for you as a new blockchain user?
What can the Blockchain OS do for you as a developer?
What can the Blockchain OS do for you as a researcher/low-level developer?
Beginner
Developer
Researcher & Low-level developer
note
This section of documentation targets new blockchain users who want to learn more about blockchain technology, DApps, and Rollups.
You can start by watching our Blockchain Course (available on Youtube):
Smart Contracts With Ethereum & Solidity
How Does Ethereum Work?
Introduction To Solidity
Solidity NFT Auction
Blockchain Limitations
Ethereum Scaling Solutions 
tip
Read the article about 
Scalability
 to learn more about solving the scalability issue in a blockchain system.
note
This section targets developers who want to start building DApps.
As a developer, you can use all the programming languages, tools, libraries, software, and services you are already familiar with. By moving most of the complex logic of their DApps to portable off-chain components, developers are freed from the limitations and idiosyncrasies imposed by blockchains. In this way, Cartesi empowers developers to select the best run-time environment in which to host each part of their DApps.
Quick start to run your first DApp
​
The fastest way of getting started is by 
Running a Simple DApp
 that we already built using Python.
tip
Check the section 
Cartesi Rollups
 to learn theoretical concepts such as DApp architecture, available APIs, and how Cartesi's off-chain and on-chain components work under the hood.
Navigate to 
Build DApps
 section for more guides:
Technical Prerequisites
Steps to create a DApp
Check 
more examples on GitHub
 such as:
Echo Python DApp
Echo C++ DApp
Echo Rust DApp
Echo Lua DApp
Echo JS DApp
Echo Low-Level
Converter DApp
Calculator DApp
SQLite DApp
k-NN DApp
m2cgen DApp
ERC-20 DApp
Auction DApp
Run your DApp off-chain using Cartesi Compute SDK
​
You can use the 
Cartesi Compute SDK
 to leverage Cartesi to run one-off complex computations that could never be executed inside a normal smart contract. Instead, those computations are executed off-chain with automatic dispute resolution guarantees, and its results can later be used on-chain.
Navigate to 
Cartesi Compute Tutorials
 section for more examples:
HelloWorld
Calculator
Dogecoin Hash
Generic Script
GPG Verify
note
This section targets researchers and low-level programmers who want to dive into our core technology.
You can dive deeper into the Blockchain OS core technology by reading the section about 
The Cartesi Machine
, which is a virtual machine that allows for verifiable computing using a Linux operating system.
Quick start to run your first DApp
Run your DApp off-chain using Cartesi Compute SDK
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









---PAGE 79---










Quick Start | Blockchain OS Documentation - Cartesi
























Skip to main content
On this page
This article explains how to build and interact with a minimalistic 
Cartesi Rollups
 application.
By the end of this tutorial, you will learn how to run a simple existing DApp written in 
Python
, called 
Echo-Python
.
note
You can inspect the 
full code of the Echo Python DApp
 in Cartesi's public Github repository.
Overview
​
The Echo-Python DApp simply copies (or "echoes") each input received as a corresponding output 
notice
. The DApp's back-end is written in 
Python
, and its front-end is a 
simple console application
 written in 
Typescript
 that can be executed from a terminal.
The 
Quick Start
 guide consists of 5 main steps:
Installing
Building
Running
Interacting
Deploying
Installing
​
note
You can use online development environments such as 
Gitpod
 and 
CodeSandbox
 to open the 
rollups-exmaples
 directly in your browser with all 
required dependencies
 already installed. These services allow you to start experimenting immediately, but keep in mind that they are provided by third-parties and are subject to unavailability and policy changes. They may also require access to your GitHub account in order to work properly.
There are two different options to setup the prerequisites, you can choose one of the following:
Using Gitpod
 as a fast option
Using manual setup
 to install all the necessary requirements locally
Using Gitpod
​
This is an easy and fast setup, you need to follow the steps:
Navigate to Gitpod rollups-examples
 to automate your development setup
When you click on the link above, it will forward you to login options.
Login with your preferable option via GitLab, GitHub, or Bitbucket.
Provide authorization to GitLab, GitHub, or Bitbucket.
Congratulations, you have successfully setup your development environment
Start Building our Echo DApp
Using manual setup
​
Follow the 
manual setup
 to  make sure you have installed all the necessary requirements locally.
Building
​
To build the 
echo-python
 example:
tip
If you are running your environment using the 
Gitpod option explained above
, then please start from 
step number 2
 as you will not need to clone the Github repository.
Clone the 
cartesi/rollups-examples
 Github repository by running the following command:
git
 clone https://github.com/cartesi/rollups-examples.git
Navigate to the DApp example directory by running the following command:
cd
 rollups-examples/echo-python
Build the Echo DApp by running the following command:
docker
 buildx bake --load
Running
​
To run the application, you can start an environment that includes a local blockchain with the Cartesi smart contracts deployed, as well as a Cartesi layer-2 node executing the DApp's back-end logic.
This can be done by running the following command:
docker
 compose -f 
..
/docker-compose.yml -f ./docker-compose.override.yml up
After you see the expected logs below, you can go to the 
Interacting Step
.
Expected logs
​
Allow some time for the infrastructure to be ready.
How much will depend on your system, but after some time showing the error 
"concurrent call in session"
, eventually the container logs will repeatedly show the following:
server_manager_1      
|
 Received GetVersion
server_manager_1      
|
 Received GetStatus
server_manager_1      
|
   default_rollups_id
server_manager_1      
|
 Received GetSessionStatus 
for
 session default_rollups_id
server_manager_1      
|
   
0
server_manager_1      
|
 Received GetEpochStatus 
for
 session default_rollups_id epoch 
0
Advancing time
​
When executing an example, it is possible to advance time to simulate the passing of epochs. To do that, run:
curl
 --data 
'{"id":1337,"jsonrpc":"2.0","method":"evm_increaseTime","params":[864010]}'
 http://localhost:8545
How to shutdown the environment
​
You can shutdown the environment by running the following command:
docker-compose
 -f 
..
/docker-compose.yml -f ./docker-compose.override.yml down -v
Interacting with the DApp
​
There are two ways to interact with the DApp:
Locally
Remotely
Interacting locally with the DApp
​
With the infrastructure in place, you can use our 
frontend-console application
 to interact with the Echo DApp by following the steps:
Open a separate terminal window
From the rollups-examples base directory, navigate to the 
frontend-console
 one:
cd
 frontend-console
Build the frontend console application:
yarn
yarn
 build
Send an input to the current locally deployed DApp:
yarn
 start input send --payload 
"Hello Blockchain OS!"
Verify the outputs (notices) generated by your input, to display your DApp notices run the following command:
yarn
 start notice list
After completing all the steps above, you should get a response similar to the following:
[ { epoch: '0', input: '1', notice: '0', payload: 'Hello Blockchain OS!' } ]
tip
You can run the Cartesi Rollups environment locally in 
host mode
. Please follow the guide on 
how to run DApp back-ends in Host Mode
, but before that make sure to 
shutdown the current running environment
.
note
For more information about the 
frontend-console
 application and its options, please check the 
frontend-console documentation
.
Interacting with remotely deployed DApps
​
The 
Echo DApp
 example is already deployed on a public blockchain test network called 
Goerli
, which is an Ethereum testnet.
You can use the same 
frontend-console application
 to interact with it, as described below.
note
Please refer to the 
frontend-console documentation
 for details on how to use it to 
send inputs
, 
list notices
 and 
deposit ERC-20 tokens
.
The following steps describe how to send an input to the Echo DApp instance that is already deployed on Goerli:
Open a separate terminal window
Navigate to the 
frontend-console
 directory:
cd
 frontend-console
Build the project:
yarn
yarn
 build
You can 
follow this tutorial to create an Ethereum account using Metamask
. Make sure to save the Secret Backup Phrase (MNEMONIC user sequence of twelve words)
Get testnet funds/tokens on Goerli to be able to submit transactions on that network. There are several faucets available, you may try 
https://goerlifaucet.com/
 or 
https://goerli-faucet.slock.it/
Create an 
Alchemy account
 to obtain an API key for reliable access to the Goerli network. Alternatively, you can use other options such as 
Infura
 or 
Moralis
Configure your account on Goerli by running the commands below, which specify the network and MNEMONIC (Secret Backup Phrase) to use:
export
 
NETWORK
=
goerli
export
 
MNEMONIC
=
<
paste here your user sequence of twelve words
>
Configure your 
Alchemy
 RPC gateway URL for Goerli by running the following command:
export
 
RPC_URL
=
https://eth-goerli.alchemyapi.io/v2/
<
Replace_This_With_Your_Alchemy_API_key
>
Send an input by running the command:
yarn
 start input send --payload 
"my new message"
 --dapp echo-python
Query the layer-2 Cartesi Node for notices produced by the DApp:
yarn
 start notice list --url https://echo-python.goerli.rollups.staging.cartesi.io/graphql
tip
As shown in the last step (number 10), to query the layer-2 Cartesi Node for DApp outputs, you will need to specify the URL of its GraphQL endpoint. You can find other existing examples endpoints in the 
DApp table below
.
Explore our DApps
​
You can find several Cartesi DApp 
examples on GitHub
, such as the following:
DApp Name
DApp Deployment Status on Goerli Testnet
GraphQL endpoint URL
Echo Python
Yes
https://echo-python.goerli.rollups.staging.cartesi.io/graphql
Echo C++
Yes
https://echo-cpp.goerli.rollups.staging.cartesi.io/graphql
Echo Rust
No
-
Echo Lua
Yes
https://echo-lua.goerli.rollups.staging.cartesi.io/graphql
Echo JS DApp
Yes
https://echo-js.goerli.rollups.staging.cartesi.io/graphql
Echo Low-Level
Yes
https://echo-low-level.goerli.rollups.staging.cartesi.io/graphql
Converter
No
-
Calculator
No
_
SQLite
Yes
https://sqlite.goerli.rollups.staging.cartesi.io/graphql
k-NN
Yes
https://knn.goerli.rollups.staging.cartesi.io/graphql
m2cgen
No
-
ERC-20
No
-
Auction
No
-
Overview
Installing
Using Gitpod
Using manual setup
Building
Running
Expected logs
Advancing time
How to shutdown the environment
Interacting with the DApp
Interacting locally with the DApp
Interacting with remotely deployed DApps
Explore our DApps
We use cookies to ensure that we give you the best experience on our website. By using the website, you agree to the use of cookies.
OK
PRIVACY POLICY









